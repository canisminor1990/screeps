module.exports=function(e){var t={};function r(o){if(t[o])return t[o].exports;var a=t[o]={i:o,l:!1,exports:{}};return e[o].call(a.exports,a,a.exports,r),a.l=!0,a.exports}return r.m=e,r.c=t,r.d=function(e,t,o){r.o(e,t)||Object.defineProperty(e,t,{configurable:!1,enumerable:!0,get:o})},r.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return r.d(t,"a",t),t},r.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},r.p="",r(r.s=15)}([function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});t.CreepAction=class{constructor(e){this.maxPerTarget=1/0,this.maxPerAction=1/0,this.targetRange=1,this.reachedRange=1,this.renewTarget=!0,this.default={name:`default-${this.name}`,moveOptions:e=>e||{}},this.setDefault=(e=>{_.assign(this.default,e)}),this.getTargetId=(e=>e.id||e.name),this.getTargetById=(e=>Game.getObjectById(e)||Game.spawns[e]||Game.flags[e]),this.isValidAction=(e=>!0),this.isValidTarget=((e,t)=>null!=e),this.isAddableAction=(e=>this.maxPerAction===1/0||!e.room.population||!e.room.population.actionCount[this.name]||e.room.population.actionCount[this.name]<this.maxPerAction),this.isAddableTarget=((e,t)=>!e.targetOf||this.maxPerTarget===1/0||_.filter(e.targetOf,{actionName:this.name}).length<this.maxPerTarget),this.newTarget=(e=>null),this.unassign=(e=>{delete e.data.actionName,delete e.data.targetId,delete e.action,delete e.target}),this.step=(e=>{CHATTY&&e.say(this.name,SAY_PUBLIC);let t=e.pos.getRangeTo(e.target);if(t<=this.targetRange){let r=this.work(e);if(r!=OK)return e.handleError({errorCode:r,action:this,target:e.target,range:t,creep:e}),this.unassign(e);t=e.pos.getRangeTo(e.target)}if(e.target&&e.hasActiveBodyparts(MOVE))if(t>this.targetRange)e.travelTo(e.target,{range:this.targetRange});else if(t>this.reachedRange){const t=e.pos.getDirectionTo(e.target),r=Traveler.positionAtDirection(e.pos,t);e.room.isWalkable(r.x,r.y)?e.move(t):e.pos.isNearTo(e.target)||e.travelTo(e.target,{range:this.reachedRange})}}),this.work=(e=>ERR_INVALID_ARGS),this.validateActionTarget=((e,t)=>{if(this.isValidAction(e)){if(this.isValidTarget(t,e))return t;if(this.renewTarget)return delete e.data.path,this.newTarget(e)}return null}),this.assign=((e,t)=>(void 0===t&&(t=this.newTarget(e)),!(!t||!this.isAddableTarget(t,e)||(LOG_TRACE&&Log.trace("Action",{creepName:e.name,assign:this.name,target:!t||t.name||t.id,Action:"assign"}),e.action&&e.action.name==this.name&&e.target&&e.target.id===t.id&&e.target.name==t.name||(PopManager.registerAction(e,this,t),this.onAssignment(e,t)),0)))),this.showAssignment=((e,t)=>{SAY_ASSIGNMENT&&Util.emoji[_.snakeCase(this.name)]&&e.say(Util.emoji[_.snakeCase(this.name)],SAY_PUBLIC),(t instanceof RoomObject||t instanceof RoomPosition&&VISUALS.ACTION_ASSIGNMENT)&&Visuals.drawArrow(e,t)}),this.onAssignment=((e,t)=>{this.showAssignment(e,t)}),this.selectstate=(()=>[this.default]),this.isMember=(e=>_.find(e,e=>e.name===this.name,this)),this.getStrategy=((e,t,...r)=>_.isUndefined(r)?t.getStrategyHandler([this.name],e):t.getStrategyHandler([this.name],e,...r)),this.name=e}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});t.CreepBehaviour=class{constructor(e){this.state={default:{name:`default-${this.name}`}},this.setState=(e=>{_.assign(this.state,e)}),this.mergeState=(e=>{_.merge(this.state,e)}),this.actions=(e=>[]),this.inflowActions=(e=>[]),this.outflowActions=(e=>[]),this.assignAction=((e,t,r,o)=>{"string"==typeof t&&(t=CreepManager.action[t]);const a=t.isValidAction(e);if(LOG_TRACE&&Log.trace("Action",{actionName:t.name,behaviourName:this.name,creepName:e.name,valid:a,Action:"isValidAction"}),!a)return!1;const i=t.isAddableAction(e);if(LOG_TRACE&&Log.trace("Action",{actionName:t.name,behaviourName:this.name,creepName:e.name,addable:i,Action:"isAddableAction"}),!i)return!1;const n=t.assignDebounce?t.assignDebounce(e,o,r):t.assign(e,r);return n?(LOG_TRACE&&Log.trace("Behaviour",{actionName:t.name,behaviourName:this.name,creepName:e.name,assigned:n,Behaviour:"nextAction",Action:"assign",target:e.target.id||e.target.name}),e.data.lastAction=t.name,e.data.lastTarget=e.target.id,!0):(LOG_TRACE&&Log.trace("Action",{actionName:t.name,behaviourName:this.name,creepName:e.name,assigned:n,Behaviour:"assignAction",Action:"assign"}),!1)}),this.selectInflowAction=(e=>{const t={},r=this.outflowActions(e);for(let o of this.inflowActions(e))if(!t[o.name]&&(t[o.name]=!0,this.assignAction(e,o,void 0,r)))return;return CreepManager.action.idle.assign(e)}),this.selectAction=((e,t)=>{const r={};for(let o of t)if(!r[o.name]&&(r[o.name]=!0,this.assignAction(e,o)))return;return CreepManager.action.idle.assign(e)}),this.nextAction=(e=>this.selectAction(e,this.actions(e))),this.needEnergy=(e=>e.sum<e.carryCapacity/2),this.nextEnergyAction=(e=>{if(this.needEnergy(e))return this.selectInflowAction(e);if(e.data.nextAction&&e.data.nextTarget){const t=CreepManager.action[e.data.nextAction],r=Game.getObjectById(e.data.nextTarget);if(delete e.data.nextAction,delete e.data.nextTarget,this.assignAction(e,t,r))return!0}return this.selectAction(e,this.outflowActions(e))}),this.invalidAction=(e=>!e.action),this.run=(e=>{this.invalidAction(e)&&(e.data.destiny&&e.data.destiny.task&&TaskManager[e.data.destiny.task]&&TaskManager[e.data.destiny.task].nextAction?TaskManager[e.data.destiny.task].nextAction(e):this.nextAction(e)),e.action&&e.target?(LOG_TRACE&&Log.trace("Behaviour",{actionName:e.action.name,behaviourName:this.name,creepName:e.name,target:e.target.id||e.target.name,Action:"run"}),e.action.step(e)):Log.error("Creep without action/activity!\nCreep: "+e.name+"\ndata: "+JSON.stringify(e.data))}),this.assign=(e=>{e.data.creepType=this.name}),this.selectstate=(e=>[this.state.default,this.state[e]]),this.name=e}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});t.RoomExtra=class{constructor(e){this.extend=(()=>{this.prototypeExtend(),this.roomManagerExtend()}),this.prototypeExtend=(()=>{}),this.roomManagerExtend=(()=>{}),this.assignRoomPrototype=(e=>{Object.defineProperties(Room.prototype,e)}),this.assignRoomManager=(e=>{_.assign(RoomManager,e)}),this.name=e}}},function(e,t,r){"use strict";function o(e){for(var r in e)t.hasOwnProperty(r)||(t[r]=e[r])}Object.defineProperty(t,"__esModule",{value:!0}),o(r(14)),o(r(62))},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});t.TaskComponent=class{constructor(e){this.register=(()=>{}),this.name=e}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});t.CreepSetup=class{constructor(e){this.minControllerLevel=0,this.none={fixedBody:[],multiBody:[],minAbsEnergyAvailable:1/0,minEnergyAvailable:1,maxMulti:0,maxCount:0,maxWeight:0},this.globalMeasurement=!1,this.measureByHome=!1,this.sortedParts=!0,this.mixMoveParts=!1,this._fixedBody=(e=>this.getRCL(e,"fixedBody")),this._multiBody=(e=>this.getRCL(e,"multiBody")),this._minAbsEnergyAvailable=(e=>this.getRCL(e,"minAbsEnergyAvailable")),this._minEnergyAvailable=(e=>this.getRCL(e,"minEnergyAvailable")),this._minMulti=(e=>this.getRCL(e,"minMulti")),this._maxMulti=(e=>this.getRCL(e,"maxMulti")),this._maxCount=(e=>this.getRCL(e,"maxCount")),this._maxWeight=(e=>this.getRCL(e,"maxWeight")),this.buildParams=(e=>{let t={setup:null,name:null,parts:[],cost:0,mother:null,home:null,breeding:1};t.setup=this.type,t.parts=this.parts(e.room),t.cost=CreepManager.bodyCosts(t.parts),t.mother=e.name,t.home=e.pos.roomName;for(let e=1;null==t.name||Game.creeps[t.name]||Memory.population[t.name];e++)t.name=this.type+"-"+t.cost+"-"+e;return t}),this.isValidSetup=(e=>{if(e.RCL<this.minControllerLevel)return LOG_TRACE&&Log.trace("Setup",{setupType:this.type,room:e.name,rcl:e.RCL,Setup:"isValidSetup"},"low RCL"),!1;let t=this._minAbsEnergyAvailable(e),r=this._minEnergyAvailable(e);const o=e.remainingEnergyAvailable,a=e.relativeRemainingEnergyAvailable;if(o<t||a<r)return LOG_TRACE&&Log.trace("Setup",{setupType:this.type,room:e.name,absEnergy:o,energy:a,Setup:"isValidSetup"},"not enough energy"),!1;let i=this._maxCount(e),n=this._maxWeight(e);if(0===i||0===n)return LOG_TRACE&&Log.trace("Setup",{setupType:this.type,room:e.name,maxCount:i,maxWeight:n,Setup:"isValidSetup"},"too many creeps"),!1;null==i&&(i=1/0),null==n&&(n=1/0);let s=0,l=0;if(this.measureByHome){let t=e.name,r=e=>{e.creepType==this.type&&e.homeRoom==t&&CreepManager.isWorkingAge(e)&&(s++,l+=e.weight)};_.forEach(Memory.population,r)}else{let t=this.globalMeasurement?PopManager:e.population;if(!t||!t.typeCount[this.type])return!0;s=t.typeCount[this.type]||0,l=t.typeWeight[this.type]||0}const m=s<i&&l<n;return LOG_TRACE&&Log.trace("Setup",{setupType:this.type,room:e.name,returnVal:m,Setup:"isValidSetup"},"count:",s,"<",i,"weight:",l,"<",n),m}),this.existingWeight=(e=>{let t=0;if(this.measureByHome){let r=e.name,o=e=>{e.creepType==this.type&&e.homeRoom==r&&(t+=e.weight)};_.forEach(Memory.population,o)}else{let r=this.globalMeasurement?PopManager:e.population;t=r&&r.typeWeight[this.type]||0}return t}),this.parts=(e=>{const t=this._fixedBody(e),r=this._multiBody(e),o=this._minMulti(e),a=this._maxMulti(e),i=this._maxWeight(e);let n;return i&&(n=i-this.existingWeight(e)),LOG_TRACE&&Log.trace("Setup",{setupType:this.type,room:e.name,Setup:"parts",maxWeight:i,minMulti:o,maxMulti:a}),CreepManager.compileBody(e,{fixedBody:t,multiBody:r,minMulti:o,maxMulti:a,maxWeight:n,currentEnergy:!0,sort:this.sortedParts})}),this.mixParts=(e=>{let t=_.countBy(e),r=e.filter(e=>e!=MOVE),o=[];for(let e=r.length-1;e>=0;e--)t[MOVE]-- >0&&o.unshift(MOVE),o.unshift(r[e]);for(;t[MOVE]>0;)o.unshift(MOVE),t[MOVE]--;return o}),this.maxCost=(e=>CreepManager.bodyCosts(this._multiBody(e))*this._maxMulti(e)+CreepManager.bodyCosts(this._fixedBody(e))),this.maxPerFlag=((e,t,r)=>{if(!e)throw new Error("undefined flagFilter");return o=>{let a,i,n=0;return FlagManager.filter(e).forEach(e=>{(a=Util.routeRange(o.name,e.roomName))>t||(i=Game.flags[e.name],_.chain(i.targetOf).filter(e=>!r||e.homeRoom===o.name).every(CreepManager.isWorkingAge).value()?n++:n+=2)}),n}}),this.getRCL=((e,t)=>{const r=this.RCL[e.RCL][t];return _.isFunction(r)?r(e):r}),this.type=e}get RCL(){return{1:this.none,2:this.none,3:this.none,4:this.none,5:this.none,6:this.none,7:this.none,8:this.none}}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});t.VisualsBase=class{constructor(){this.getColourByPercentage=((e,t)=>`hsl(${(120*(t?e:1-e)).toString(10)}, 100%, 50%)`),this.resourcesColor={[RESOURCE_ENERGY]:"#FFE56D",[RESOURCE_POWER]:"#FF0000",[RESOURCE_CATALYST]:"#FF7A7A",[RESOURCE_GHODIUM]:"#FFFFFF",[RESOURCE_HYDROGEN]:"#CCCCCC",[RESOURCE_KEANIUM]:"#9370FF",[RESOURCE_LEMERGIUM]:"#89F4A5",[RESOURCE_OXYGEN]:"#CCCCCC",[RESOURCE_UTRIUM]:"#88D6F7",[RESOURCE_ZYNTHIUM]:"#F2D28B"},this.getResourceColour=(e=>{const t=this.resourcesColor[e];if(t)return t;let r=[RESOURCE_UTRIUM,RESOURCE_LEMERGIUM,RESOURCE_KEANIUM,RESOURCE_ZYNTHIUM,RESOURCE_GHODIUM,RESOURCE_HYDROGEN,RESOURCE_OXYGEN].find(t=>e.includes(t));return _.include([RESOURCE_UTRIUM_LEMERGITE,RESOURCE_ZYNTHIUM_KEANITE],e)&&(r=RESOURCE_OXYGEN),this.resourcesColor[r]}),this.randomColour=(()=>{let e="#";for(;e.length<7;)e+=Math.random().toString(16).substr(-7).substr(-1);return e}),this.creepPathStyle=(e=>(Util.set(e.data,"pathColour",this.randomColour),{width:.15,color:e.data.pathColour,lineStyle:"dashed"}))}}},function(e,t,r){"use strict";t.getArg=function(e,t,r){if(t in e)return e[t];if(3===arguments.length)return r;throw new Error('"'+t+'" is a required argument.')};var o=/^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.-]*)(?::(\d+))?(.*)$/,a=/^data:.+\,.+$/;function i(e){var t=e.match(o);return t?{scheme:t[1],auth:t[2],host:t[3],port:t[4],path:t[5]}:null}function n(e){var t="";return e.scheme&&(t+=e.scheme+":"),t+="//",e.auth&&(t+=e.auth+"@"),e.host&&(t+=e.host),e.port&&(t+=":"+e.port),e.path&&(t+=e.path),t}function s(e){var r=e,o=i(e);if(o){if(!o.path)return e;r=o.path}for(var a,s=t.isAbsolute(r),l=r.split(/\/+/),m=0,c=l.length-1;c>=0;c--)"."===(a=l[c])?l.splice(c,1):".."===a?m++:m>0&&(""===a?(l.splice(c+1,m),m=0):(l.splice(c,2),m--));return""===(r=l.join("/"))&&(r=s?"/":"."),o?(o.path=r,n(o)):r}function l(e,t){""===e&&(e="."),""===t&&(t=".");var r=i(t),o=i(e);if(o&&(e=o.path||"/"),r&&!r.scheme)return o&&(r.scheme=o.scheme),n(r);if(r||t.match(a))return t;if(o&&!o.host&&!o.path)return o.host=t,n(o);var l="/"===t.charAt(0)?t:s(e.replace(/\/+$/,"")+"/"+t);return o?(o.path=l,n(o)):l}t.urlParse=i,t.urlGenerate=n,t.normalize=s,t.join=l,t.isAbsolute=function(e){return"/"===e.charAt(0)||o.test(e)},t.relative=function(e,t){""===e&&(e="."),e=e.replace(/\/$/,"");for(var r=0;0!==t.indexOf(e+"/");){var o=e.lastIndexOf("/");if(o<0)return t;if((e=e.slice(0,o)).match(/^([^\/]+:\/)?\/*$/))return t;++r}return Array(r+1).join("../")+t.substr(e.length+1)};var m=!("__proto__"in Object.create(null));function c(e){return e}function u(e){if(!e)return!1;var t=e.length;if(t<9)return!1;if(95!==e.charCodeAt(t-1)||95!==e.charCodeAt(t-2)||111!==e.charCodeAt(t-3)||116!==e.charCodeAt(t-4)||111!==e.charCodeAt(t-5)||114!==e.charCodeAt(t-6)||112!==e.charCodeAt(t-7)||95!==e.charCodeAt(t-8)||95!==e.charCodeAt(t-9))return!1;for(var r=t-10;r>=0;r--)if(36!==e.charCodeAt(r))return!1;return!0}function d(e,t){return e===t?0:null===e?1:null===t?-1:e>t?1:-1}t.toSetString=m?c:function(e){return u(e)?"$"+e:e},t.fromSetString=m?c:function(e){return u(e)?e.slice(1):e},t.compareByOriginalPositions=function(e,t,r){var o=d(e.source,t.source);return 0!==o?o:0!=(o=e.originalLine-t.originalLine)?o:0!=(o=e.originalColumn-t.originalColumn)||r?o:0!=(o=e.generatedColumn-t.generatedColumn)?o:0!=(o=e.generatedLine-t.generatedLine)?o:d(e.name,t.name)},t.compareByGeneratedPositionsDeflated=function(e,t,r){var o=e.generatedLine-t.generatedLine;return 0!==o?o:0!=(o=e.generatedColumn-t.generatedColumn)||r?o:0!==(o=d(e.source,t.source))?o:0!=(o=e.originalLine-t.originalLine)?o:0!=(o=e.originalColumn-t.originalColumn)?o:d(e.name,t.name)},t.compareByGeneratedPositionsInflated=function(e,t){var r=e.generatedLine-t.generatedLine;return 0!==r?r:0!=(r=e.generatedColumn-t.generatedColumn)?r:0!==(r=d(e.source,t.source))?r:0!=(r=e.originalLine-t.originalLine)?r:0!=(r=e.originalColumn-t.originalColumn)?r:d(e.name,t.name)},t.parseSourceMapInput=function(e){return JSON.parse(e.replace(/^\)]}'[^\n]*\n/,""))},t.computeSourceURL=function(e,t,r){if(t=t||"",e&&("/"!==e[e.length-1]&&"/"!==t[0]&&(e+="/"),t=e+t),r){var o=i(r);if(!o)throw new Error("sourceMapURL could not be parsed");if(o.path){var a=o.path.lastIndexOf("/");a>=0&&(o.path=o.path.substring(0,a+1))}t=l(n(o),t)}return s(t)}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(52),a=r(53),i=r(54),n=r(55),s={emoji:r(56).Emoji,root:{all(){Util.root.killAll(),Util.root.memory()},killAll(){_.forEach(Game.creeps,e=>e.suicide())},memory(){_.forEach(Memory,(e,t)=>delete Memory[t])},memorySafe(){_.forEach(Memory,(e,t)=>!["population"].includes(t)&&delete Memory[t])}},define(e,t,r=!1){r?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t.prototype)):Object.defineProperties(e.prototype,Object.getOwnPropertyDescriptors(t.prototype))},getGame:{obj:e=>Game.getObjectById(e)||Game.creeps[e]||Game.rooms[e]||Game.flags[e],objs(e){const t=[];return _.forEach(e,e=>t.push(Util.getGame.obj(e))),_.compact(t)},objsToNameArray:e=>_.compact(_.map(e,"name")),objsToIdArray:e=>_.compact(_.map(e,"id")),objsToArray(e){let t=Util.getGame.objsToIdArray(e);return 0===t.length&&(t=Util.getGame.objsToNameArray(e)),t}},formatNumber(e){let t=Math.log10(e)/3;if(!e)return"0";let r=e.toString();return t<1?r:t<2?r.substring(0,r.length-3)+"k":t<3?r.substring(0,r.length-6)+"M":t<4?r.substring(0,r.length-9)+"B":e.toString()},pad:(e,t="0",r=2,o=!0)=>(o&&(r-=e.toString().length),_.times(r,()=>t).join("")+e),get(e,t,r,o=!0){const a=_.get(e,t);return _.isUndefined(a)&&!_.isUndefined(r)&&o?(r=Util.fieldOrFunction(r),_.set(e,t,r),_.get(e,t)):a},areEqual:(...e)=>e.length<=1||e.every((e,t,r)=>_.isEqual(e,r[0])),set(e,t,r,o=!0){o?Util.get(e,t,r):_.set(e,t,r)},callIfExists(e,...t){if(e)return e(...t)},fieldOrFunction:(e,...t)=>_.isFunction(e)?e(...t):e,addById(e,t){e||(e=[]);const r=Game.getObjectById(t);return r&&e.push(r),e},processReports(){if(!_.isUndefined(Memory.statistics)&&!_.isUndefined(Memory.statistics.reports)&&Memory.statistics.reports.length){let e;Memory.statistics.reports.length<=REPORTS_PER_LOOP?(e=Memory.statistics.reports,Memory.statistics.reports=[]):e=Memory.statistics.reports.splice(0,REPORTS_PER_LOOP),_.forEach(e,Game.notify)}},guid:()=>"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g,e=>{const t=16*Math.random()|0;return("x"===e?t:3&t|8).toString(16)}),inQueue:e=>!!e&&(e.link&&(e={behaviour:e}),!!(e.name||e.behaviour||e.setup)&&_(Game.rooms).filter("my").map("memory").map(e=>e.spawnQueueHigh.concat(e.spawnQueueMedium,e.spawnQueueLow)).flatten().some(t=>(!e.room||!t.destiny||t.destiny.room===e.room)&&(e.behaviour?t.behaviour&&t.behaviour===e.behaviour||t.name.includes(e.behaviour):e.setup?t.setup===e.setup:void 0))),memoryUsage(e){let t="",r=0,o="";for(const a in e){a.length>o.length&&(o=a);const i=JSON.stringify(e[a]).length/1024;r+=i,t+=`<tr><td>${a}</td><td>${_.round(i,2)}</td></tr>`}return t+=`<tr><td>Total</td><td>${_.round(r,2)}</td></tr></table>`,`<table><tr><th>Key${Array(o.length+2).join(" ")}</th><th>Size (kb)</th></tr>`.concat(t)},_resources:_.memoize(()=>_.chain(global).pick((e,t)=>t.startsWith("RESOURCE_")).value()),resources(){return this._resources()},valueOrZero:e=>e||0,chargeScale(e,t,r){if(r===t)return e>r?1/0:-1/0;return(e-r)*(1/(r-t))+1},resetBoostProduction(e){let t,r=_.filter(Game.rooms,{my:!0});for(let o of r)void 0!==e&&o.name!==e||(t=o.memory.resources,Log.success(o.name,"reset!"),_.isUndefined(t)?Log.warn(o.name,"has no memory.resources"):(t.offers=[],t.orders=[],t.terminal[0]&&(t.terminal[0].orders=[]),t.storage[0]&&(t.storage[0].orders=[]),t.reactions&&(t.reactions.orders=[]),t.lab&&(t.lab=[],_.values(Game.structures).filter(e=>"lab"===e.structureType).map(e=>e.room.setStore(e.id,RESOURCE_ENERGY,2e3))),t.boostTiming={roomState:""}));void 0===e&&delete Memory.boostTiming}};t.default=_.assign(s,i.roomUtils,a.logUtils,o.dateUtils,n.marketUtils),t.Install=((e,t,r=!1)=>{_.isString(e)?(global[e]=t,r&&_.assign(global[e],r)):(_.assign(e,t),r&&_.assign(e,r))}),t.getUsername=_(Game.rooms).map("controller").filter("my").map("owner.username").first()},function(e,t,r){"use strict";var o=r(10),a=r(7),i=r(11).ArraySet,n=r(19).MappingList;function s(e){e||(e={}),this._file=a.getArg(e,"file",null),this._sourceRoot=a.getArg(e,"sourceRoot",null),this._skipValidation=a.getArg(e,"skipValidation",!1),this._sources=new i,this._names=new i,this._mappings=new n,this._sourcesContents=null}s.prototype._version=3,s.fromSourceMap=function(e){var t=e.sourceRoot,r=new s({file:e.file,sourceRoot:t});return e.eachMapping(function(e){var o={generated:{line:e.generatedLine,column:e.generatedColumn}};null!=e.source&&(o.source=e.source,null!=t&&(o.source=a.relative(t,o.source)),o.original={line:e.originalLine,column:e.originalColumn},null!=e.name&&(o.name=e.name)),r.addMapping(o)}),e.sources.forEach(function(o){var i=o;null!==t&&(i=a.relative(t,o)),r._sources.has(i)||r._sources.add(i);var n=e.sourceContentFor(o);null!=n&&r.setSourceContent(o,n)}),r},s.prototype.addMapping=function(e){var t=a.getArg(e,"generated"),r=a.getArg(e,"original",null),o=a.getArg(e,"source",null),i=a.getArg(e,"name",null);this._skipValidation||this._validateMapping(t,r,o,i),null!=o&&(o=String(o),this._sources.has(o)||this._sources.add(o)),null!=i&&(i=String(i),this._names.has(i)||this._names.add(i)),this._mappings.add({generatedLine:t.line,generatedColumn:t.column,originalLine:null!=r&&r.line,originalColumn:null!=r&&r.column,source:o,name:i})},s.prototype.setSourceContent=function(e,t){var r=e;null!=this._sourceRoot&&(r=a.relative(this._sourceRoot,r)),null!=t?(this._sourcesContents||(this._sourcesContents=Object.create(null)),this._sourcesContents[a.toSetString(r)]=t):this._sourcesContents&&(delete this._sourcesContents[a.toSetString(r)],0===Object.keys(this._sourcesContents).length&&(this._sourcesContents=null))},s.prototype.applySourceMap=function(e,t,r){var o=t;if(null==t){if(null==e.file)throw new Error('SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, or the source map\'s "file" property. Both were omitted.');o=e.file}var n=this._sourceRoot;null!=n&&(o=a.relative(n,o));var s=new i,l=new i;this._mappings.unsortedForEach(function(t){if(t.source===o&&null!=t.originalLine){var i=e.originalPositionFor({line:t.originalLine,column:t.originalColumn});null!=i.source&&(t.source=i.source,null!=r&&(t.source=a.join(r,t.source)),null!=n&&(t.source=a.relative(n,t.source)),t.originalLine=i.line,t.originalColumn=i.column,null!=i.name&&(t.name=i.name))}var m=t.source;null==m||s.has(m)||s.add(m);var c=t.name;null==c||l.has(c)||l.add(c)},this),this._sources=s,this._names=l,e.sources.forEach(function(t){var o=e.sourceContentFor(t);null!=o&&(null!=r&&(t=a.join(r,t)),null!=n&&(t=a.relative(n,t)),this.setSourceContent(t,o))},this)},s.prototype._validateMapping=function(e,t,r,o){if(t&&"number"!=typeof t.line&&"number"!=typeof t.column)throw new Error("original.line and original.column are not numbers -- you probably meant to omit the original mapping entirely and only map the generated position. If so, pass null for the original mapping instead of an object with empty or null values.");if((!(e&&"line"in e&&"column"in e&&e.line>0&&e.column>=0)||t||r||o)&&!(e&&"line"in e&&"column"in e&&t&&"line"in t&&"column"in t&&e.line>0&&e.column>=0&&t.line>0&&t.column>=0&&r))throw new Error("Invalid mapping: "+JSON.stringify({generated:e,source:r,original:t,name:o}))},s.prototype._serializeMappings=function(){for(var e,t,r,i,n=0,s=1,l=0,m=0,c=0,u=0,d="",h=this._mappings.toArray(),g=0,p=h.length;g<p;g++){if(e="",(t=h[g]).generatedLine!==s)for(n=0;t.generatedLine!==s;)e+=";",s++;else if(g>0){if(!a.compareByGeneratedPositionsInflated(t,h[g-1]))continue;e+=","}e+=o.encode(t.generatedColumn-n),n=t.generatedColumn,null!=t.source&&(i=this._sources.indexOf(t.source),e+=o.encode(i-u),u=i,e+=o.encode(t.originalLine-1-m),m=t.originalLine-1,e+=o.encode(t.originalColumn-l),l=t.originalColumn,null!=t.name&&(r=this._names.indexOf(t.name),e+=o.encode(r-c),c=r)),d+=e}return d},s.prototype._generateSourcesContent=function(e,t){return e.map(function(e){if(!this._sourcesContents)return null;null!=t&&(e=a.relative(t,e));var r=a.toSetString(e);return Object.prototype.hasOwnProperty.call(this._sourcesContents,r)?this._sourcesContents[r]:null},this)},s.prototype.toJSON=function(){var e={version:this._version,sources:this._sources.toArray(),names:this._names.toArray(),mappings:this._serializeMappings()};return null!=this._file&&(e.file=this._file),null!=this._sourceRoot&&(e.sourceRoot=this._sourceRoot),this._sourcesContents&&(e.sourcesContent=this._generateSourcesContent(e.sources,e.sourceRoot)),e},s.prototype.toString=function(){return JSON.stringify(this.toJSON())},t.SourceMapGenerator=s},function(e,t,r){"use strict";var o=r(18);t.encode=function(e){var t,r="",a=function(e){return e<0?1+(-e<<1):0+(e<<1)}(e);do{t=31&a,(a>>>=5)>0&&(t|=32),r+=o.encode(t)}while(a>0);return r},t.decode=function(e,t,r){var a,i,n,s,l=e.length,m=0,c=0;do{if(t>=l)throw new Error("Expected more digits in base 64 VLQ value.");if(-1===(i=o.decode(e.charCodeAt(t++))))throw new Error("Invalid base64 digit: "+e.charAt(t-1));a=!!(32&i),m+=(i&=31)<<c,c+=5}while(a);r.value=(s=(n=m)>>1,1==(1&n)?-s:s),r.rest=t}},function(e,t,r){"use strict";var o=r(7),a=Object.prototype.hasOwnProperty,i="undefined"!=typeof Map;function n(){this._array=[],this._set=i?new Map:Object.create(null)}n.fromArray=function(e,t){for(var r=new n,o=0,a=e.length;o<a;o++)r.add(e[o],t);return r},n.prototype.size=function(){return i?this._set.size:Object.getOwnPropertyNames(this._set).length},n.prototype.add=function(e,t){var r=i?e:o.toSetString(e),n=i?this.has(e):a.call(this._set,r),s=this._array.length;n&&!t||this._array.push(e),n||(i?this._set.set(e,s):this._set[r]=s)},n.prototype.has=function(e){if(i)return this._set.has(e);var t=o.toSetString(e);return a.call(this._set,t)},n.prototype.indexOf=function(e){if(i){var t=this._set.get(e);if(t>=0)return t}else{var r=o.toSetString(e);if(a.call(this._set,r))return this._set[r]}throw new Error('"'+e+'" is not in the set.')},n.prototype.at=function(e){if(e>=0&&e<this._array.length)return this._array[e];throw new Error("No element indexed by "+e)},n.prototype.toArray=function(){return this._array.slice()},t.ArraySet=n},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.Strategy={decorateAgent(e,...r){e.customStrategy||(e.customStrategy=function(e){}),e.staticCustomStrategy||(e.staticCustomStrategy=function(e){}),e.getStrategyHandler=function(e,t,...r){const o=this.currentStrategy||this.strategy(e),a=o[t],i=o.key,n=o.name;if(LOG_TRACE&&Log.trace("Strategy",{agent:this.name,strategyKey:i,strategyName:n,method:t}),void 0===a)return void Log.error("strategy handler returned undefined",{agent:this.name||this.id,strategyKey:i,strategyName:n,method:t,stack:(new Error).stack});if(0===r.length)return a;const s=a.apply(this.currentStrategy,r);if(void 0!==s)return s;Log.error("handler returned undefined for args",{agent:this.name||this.id,strategyKey:i,strategyName:n,method:t,args:r.toString(),stack:(new Error).stack})},e._strategyCache={},e.strategyKey=function(e){const t=[];for(let o=r.length-1;o>=0;o--)e[o]?t[o]=e[o]:t[o]=r[o].default(this);return t},e.selectClient=function(e,t){return e[t]&&r[t].select(e[t])},e.strategy=function(e){const o=this.strategyKey(e);let a=t.Strategy.getCachedStrategy(this,o);return a?t.Strategy.customizeStrategy(this,o,a):(a=t.Strategy.buildStrategy(o,t.Strategy.strategyChainUtils,r,this.staticCustomStrategy.apply(this,o)))?(t.Strategy.putCachedStrategy(this,o,a),t.Strategy.customizeStrategy(this,o,a)):(Log.error("no strategy",{agent:this.name||this.id,key:o}),{})},e.explain=function(){const e=this.strategyKey([]);let t=this.toString()+": ";this.explainAgent&&(t+=this.explainAgent()+" "),t+=`assigned:[${e}]`;for(let r=0;r<e.length;r++){const o=this.selectClient(r);o&&o.explain&&(t+=`\n\t${e[r]}: ${o.explain(this)}`)}return t}},allocateStrategy(e,...t){e.currentStrategy=e.strategy.apply(e,t)},freeStrategy(e){t.Strategy.freeStrategyChain(e.currentStrategy),delete e.currentStrategy},buildStrategy(e,r,o,a){const i={key:e,name:[]};let n;t.Strategy.appendstate(i,void 0,[r]);for(let r=0;r<o.length;r++){const a=e[r],s=a&&o[r].selector(a),l=s&&s.selectstate&&s.selectstate.apply(s,e);n=t.Strategy.appendstate(i,n,l)}if(a&&(n=t.Strategy.appendstate(i,n,[a])),n)return i},appendstate(e,t,r){if(!r)return t;for(let o=0;o<r.length;o++){const a=r[o];a&&(t=a,_.assign(e,a,(e,t,r)=>"name"===r?(e.push(t),e):t))}return t},freeStrategyChain(e){},customizeStrategy(e,t,r){const o=e.customStrategy.apply(e,t);return o?_.assign({},r,o,(e,t,r)=>"name"===r?Array.isArray(t)?t.slice(0):(e.push(t),e):t):r},strategyChainUtils:{toString(){const e=this.name.toString();return t.Strategy.freeStrategy(this),e},[Symbol.toPrimitive](){return this.toString()}},getCachedStrategy:(e,t)=>_.get(e._strategyCache,t),putCachedStrategy(e,t,r){Object.freeze(r),_.set(e._strategyCache,t,r)}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),function(e){e[e.OK=0]="OK",e[e.ERR_NOT_OWNER=-1]="ERR_NOT_OWNER",e[e.ERR_NO_PATH=-2]="ERR_NO_PATH",e[e.ERR_NAME_EXISTS=-3]="ERR_NAME_EXISTS",e[e.ERR_BUSY=-4]="ERR_BUSY",e[e.ERR_NOT_FOUND=-5]="ERR_NOT_FOUND",e[e.ERR_NOT_ENOUGH_ENERGY=-6]="ERR_NOT_ENOUGH_ENERGY",e[e.ERR_NOT_ENOUGH_RESOURCES=-6]="ERR_NOT_ENOUGH_RESOURCES",e[e.ERR_INVALID_TARGET=-7]="ERR_INVALID_TARGET",e[e.ERR_FULL=-8]="ERR_FULL",e[e.ERR_NOT_IN_RANGE=-9]="ERR_NOT_IN_RANGE",e[e.ERR_INVALID_ARGS=-10]="ERR_INVALID_ARGS",e[e.ERR_TIRED=-11]="ERR_TIRED",e[e.ERR_NO_BODYPART=-12]="ERR_NO_BODYPART",e[e.ERR_NOT_ENOUGH_EXTENSIONS=-6]="ERR_NOT_ENOUGH_EXTENSIONS",e[e.ERR_RCL_NOT_ENOUGH=-14]="ERR_RCL_NOT_ENOUGH",e[e.ERR_GCL_NOT_ENOUGH=-15]="ERR_GCL_NOT_ENOUGH"}(t.ErrorType||(t.ErrorType={}))},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});t.Component=class{constructor(){this.extend=(e=>{}),this.fresh=(e=>{}),this.analyze=(e=>{}),this.register=(e=>{}),this.run=(e=>{}),this.cleanup=(e=>{})}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});r(16);const o=r(25),a=r(26);o.Splash();const i=()=>{Memory.pause||(_.isUndefined(global.isRoot)&&a.default.install(),a.default.loop(),Game.cacheTime=Game.time)};t.loop=i},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(17);class a{static get consumer(){return null==this._consumer&&(this._consumer=new o.SourceMapConsumer(r(24))),this._consumer}static sourceMappedStackTrace(e){const t=e instanceof Error?e.stack:e;if(this.cache.hasOwnProperty(t))return this.cache[t];const r=/^\s+at\s+(.+?\s+)?\(?([0-z._\-\\/]+):(\d+):(\d+)\)?$/gm;let o,a=e.toString();for(;(o=r.exec(t))&&"main"===o[2];){const e=this.consumer.originalPositionFor({column:parseInt(o[4],10),line:parseInt(o[3],10)});if(null==e.line)break;e.name?a+=`\n    at ${e.name} (${e.source}:${e.line}:${e.column})`:o[1]?a+=`\n    at ${o[1]} (${e.source}:${e.line}:${e.column})`:a+=`\n    at ${e.source}:${e.line}:${e.column}`}return this.cache[t]=a,a}static wrapLoop(e){return()=>{try{e()}catch(e){if(!(e instanceof Error))throw e;if("sim"in Game.rooms){const t="Source maps don't work in the simulator - displaying original error";console.log(`<span style='color:red'>${t}<br>${_.escape(e.stack)}</span>`)}else console.log(`<span style='color:red'>${_.escape(this.sourceMappedStackTrace(e))}</span>`)}}}}a.cache={},t.ErrorMapper=a},function(e,t,r){"use strict";t.SourceMapGenerator=r(9).SourceMapGenerator,t.SourceMapConsumer=r(20).SourceMapConsumer,t.SourceNode=r(23).SourceNode},function(e,t,r){"use strict";var o="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split("");t.encode=function(e){if(0<=e&&e<o.length)return o[e];throw new TypeError("Must be between 0 and 63: "+e)},t.decode=function(e){return 65<=e&&e<=90?e-65:97<=e&&e<=122?e-97+26:48<=e&&e<=57?e-48+52:43==e?62:47==e?63:-1}},function(e,t,r){"use strict";var o=r(7);function a(){this._array=[],this._sorted=!0,this._last={generatedLine:-1,generatedColumn:0}}a.prototype.unsortedForEach=function(e,t){this._array.forEach(e,t)},a.prototype.add=function(e){var t,r,a,i,n,s;t=this._last,r=e,a=t.generatedLine,i=r.generatedLine,n=t.generatedColumn,s=r.generatedColumn,i>a||i==a&&s>=n||o.compareByGeneratedPositionsInflated(t,r)<=0?(this._last=e,this._array.push(e)):(this._sorted=!1,this._array.push(e))},a.prototype.toArray=function(){return this._sorted||(this._array.sort(o.compareByGeneratedPositionsInflated),this._sorted=!0),this._array},t.MappingList=a},function(e,t,r){"use strict";var o=r(7),a=r(21),i=r(11).ArraySet,n=r(10),s=r(22).quickSort;function l(e,t){var r=e;return"string"==typeof e&&(r=o.parseSourceMapInput(e)),null!=r.sections?new u(r,t):new m(r,t)}function m(e,t){var r=e;"string"==typeof e&&(r=o.parseSourceMapInput(e));var a=o.getArg(r,"version"),n=o.getArg(r,"sources"),s=o.getArg(r,"names",[]),l=o.getArg(r,"sourceRoot",null),m=o.getArg(r,"sourcesContent",null),c=o.getArg(r,"mappings"),u=o.getArg(r,"file",null);if(a!=this._version)throw new Error("Unsupported version: "+a);l&&(l=o.normalize(l)),n=n.map(String).map(o.normalize).map(function(e){return l&&o.isAbsolute(l)&&o.isAbsolute(e)?o.relative(l,e):e}),this._names=i.fromArray(s.map(String),!0),this._sources=i.fromArray(n,!0),this._absoluteSources=this._sources.toArray().map(function(e){return o.computeSourceURL(l,e,t)}),this.sourceRoot=l,this.sourcesContent=m,this._mappings=c,this._sourceMapURL=t,this.file=u}function c(){this.generatedLine=0,this.generatedColumn=0,this.source=null,this.originalLine=null,this.originalColumn=null,this.name=null}function u(e,t){var r=e;"string"==typeof e&&(r=o.parseSourceMapInput(e));var a=o.getArg(r,"version"),n=o.getArg(r,"sections");if(a!=this._version)throw new Error("Unsupported version: "+a);this._sources=new i,this._names=new i;var s={line:-1,column:0};this._sections=n.map(function(e){if(e.url)throw new Error("Support for url field in sections not implemented.");var r=o.getArg(e,"offset"),a=o.getArg(r,"line"),i=o.getArg(r,"column");if(a<s.line||a===s.line&&i<s.column)throw new Error("Section offsets must be ordered and non-overlapping.");return s=r,{generatedOffset:{generatedLine:a+1,generatedColumn:i+1},consumer:new l(o.getArg(e,"map"),t)}})}l.fromSourceMap=function(e,t){return m.fromSourceMap(e,t)},l.prototype._version=3,l.prototype.__generatedMappings=null,Object.defineProperty(l.prototype,"_generatedMappings",{configurable:!0,enumerable:!0,get:function(){return this.__generatedMappings||this._parseMappings(this._mappings,this.sourceRoot),this.__generatedMappings}}),l.prototype.__originalMappings=null,Object.defineProperty(l.prototype,"_originalMappings",{configurable:!0,enumerable:!0,get:function(){return this.__originalMappings||this._parseMappings(this._mappings,this.sourceRoot),this.__originalMappings}}),l.prototype._charIsMappingSeparator=function(e,t){var r=e.charAt(t);return";"===r||","===r},l.prototype._parseMappings=function(e,t){throw new Error("Subclasses must implement _parseMappings")},l.GENERATED_ORDER=1,l.ORIGINAL_ORDER=2,l.GREATEST_LOWER_BOUND=1,l.LEAST_UPPER_BOUND=2,l.prototype.eachMapping=function(e,t,r){var a,i=t||null;switch(r||l.GENERATED_ORDER){case l.GENERATED_ORDER:a=this._generatedMappings;break;case l.ORIGINAL_ORDER:a=this._originalMappings;break;default:throw new Error("Unknown order of iteration.")}var n=this.sourceRoot;a.map(function(e){var t=null===e.source?null:this._sources.at(e.source);return{source:t=o.computeSourceURL(n,t,this._sourceMapURL),generatedLine:e.generatedLine,generatedColumn:e.generatedColumn,originalLine:e.originalLine,originalColumn:e.originalColumn,name:null===e.name?null:this._names.at(e.name)}},this).forEach(e,i)},l.prototype.allGeneratedPositionsFor=function(e){var t=o.getArg(e,"line"),r={source:o.getArg(e,"source"),originalLine:t,originalColumn:o.getArg(e,"column",0)};if(r.source=this._findSourceIndex(r.source),r.source<0)return[];var i=[],n=this._findMapping(r,this._originalMappings,"originalLine","originalColumn",o.compareByOriginalPositions,a.LEAST_UPPER_BOUND);if(n>=0){var s=this._originalMappings[n];if(void 0===e.column)for(var l=s.originalLine;s&&s.originalLine===l;)i.push({line:o.getArg(s,"generatedLine",null),column:o.getArg(s,"generatedColumn",null),lastColumn:o.getArg(s,"lastGeneratedColumn",null)}),s=this._originalMappings[++n];else for(var m=s.originalColumn;s&&s.originalLine===t&&s.originalColumn==m;)i.push({line:o.getArg(s,"generatedLine",null),column:o.getArg(s,"generatedColumn",null),lastColumn:o.getArg(s,"lastGeneratedColumn",null)}),s=this._originalMappings[++n]}return i},t.SourceMapConsumer=l,m.prototype=Object.create(l.prototype),m.prototype.consumer=l,m.prototype._findSourceIndex=function(e){var t,r=e;if(null!=this.sourceRoot&&(r=o.relative(this.sourceRoot,r)),this._sources.has(r))return this._sources.indexOf(r);for(t=0;t<this._absoluteSources.length;++t)if(this._absoluteSources[t]==e)return t;return-1},m.fromSourceMap=function(e,t){var r=Object.create(m.prototype),a=r._names=i.fromArray(e._names.toArray(),!0),n=r._sources=i.fromArray(e._sources.toArray(),!0);r.sourceRoot=e._sourceRoot,r.sourcesContent=e._generateSourcesContent(r._sources.toArray(),r.sourceRoot),r.file=e._file,r._sourceMapURL=t,r._absoluteSources=r._sources.toArray().map(function(e){return o.computeSourceURL(r.sourceRoot,e,t)});for(var l=e._mappings.toArray().slice(),u=r.__generatedMappings=[],d=r.__originalMappings=[],h=0,g=l.length;h<g;h++){var p=l[h],f=new c;f.generatedLine=p.generatedLine,f.generatedColumn=p.generatedColumn,p.source&&(f.source=n.indexOf(p.source),f.originalLine=p.originalLine,f.originalColumn=p.originalColumn,p.name&&(f.name=a.indexOf(p.name)),d.push(f)),u.push(f)}return s(r.__originalMappings,o.compareByOriginalPositions),r},m.prototype._version=3,Object.defineProperty(m.prototype,"sources",{get:function(){return this._absoluteSources.slice()}}),m.prototype._parseMappings=function(e,t){for(var r,a,i,l,m,u=1,d=0,h=0,g=0,p=0,f=0,R=e.length,y=0,_={},C={},E=[],T=[];y<R;)if(";"===e.charAt(y))u++,y++,d=0;else if(","===e.charAt(y))y++;else{for((r=new c).generatedLine=u,l=y;l<R&&!this._charIsMappingSeparator(e,l);l++);if(i=_[a=e.slice(y,l)])y+=a.length;else{for(i=[];y<l;)n.decode(e,y,C),m=C.value,y=C.rest,i.push(m);if(2===i.length)throw new Error("Found a source, but no line and column");if(3===i.length)throw new Error("Found a source and line, but no column");_[a]=i}r.generatedColumn=d+i[0],d=r.generatedColumn,i.length>1&&(r.source=p+i[1],p+=i[1],r.originalLine=h+i[2],h=r.originalLine,r.originalLine+=1,r.originalColumn=g+i[3],g=r.originalColumn,i.length>4&&(r.name=f+i[4],f+=i[4])),T.push(r),"number"==typeof r.originalLine&&E.push(r)}s(T,o.compareByGeneratedPositionsDeflated),this.__generatedMappings=T,s(E,o.compareByOriginalPositions),this.__originalMappings=E},m.prototype._findMapping=function(e,t,r,o,i,n){if(e[r]<=0)throw new TypeError("Line must be greater than or equal to 1, got "+e[r]);if(e[o]<0)throw new TypeError("Column must be greater than or equal to 0, got "+e[o]);return a.search(e,t,i,n)},m.prototype.computeColumnSpans=function(){for(var e=0;e<this._generatedMappings.length;++e){var t=this._generatedMappings[e];if(e+1<this._generatedMappings.length){var r=this._generatedMappings[e+1];if(t.generatedLine===r.generatedLine){t.lastGeneratedColumn=r.generatedColumn-1;continue}}t.lastGeneratedColumn=1/0}},m.prototype.originalPositionFor=function(e){var t={generatedLine:o.getArg(e,"line"),generatedColumn:o.getArg(e,"column")},r=this._findMapping(t,this._generatedMappings,"generatedLine","generatedColumn",o.compareByGeneratedPositionsDeflated,o.getArg(e,"bias",l.GREATEST_LOWER_BOUND));if(r>=0){var a=this._generatedMappings[r];if(a.generatedLine===t.generatedLine){var i=o.getArg(a,"source",null);null!==i&&(i=this._sources.at(i),i=o.computeSourceURL(this.sourceRoot,i,this._sourceMapURL));var n=o.getArg(a,"name",null);return null!==n&&(n=this._names.at(n)),{source:i,line:o.getArg(a,"originalLine",null),column:o.getArg(a,"originalColumn",null),name:n}}}return{source:null,line:null,column:null,name:null}},m.prototype.hasContentsOfAllSources=function(){return!!this.sourcesContent&&(this.sourcesContent.length>=this._sources.size()&&!this.sourcesContent.some(function(e){return null==e}))},m.prototype.sourceContentFor=function(e,t){if(!this.sourcesContent)return null;var r=this._findSourceIndex(e);if(r>=0)return this.sourcesContent[r];var a,i=e;if(null!=this.sourceRoot&&(i=o.relative(this.sourceRoot,i)),null!=this.sourceRoot&&(a=o.urlParse(this.sourceRoot))){var n=i.replace(/^file:\/\//,"");if("file"==a.scheme&&this._sources.has(n))return this.sourcesContent[this._sources.indexOf(n)];if((!a.path||"/"==a.path)&&this._sources.has("/"+i))return this.sourcesContent[this._sources.indexOf("/"+i)]}if(t)return null;throw new Error('"'+i+'" is not in the SourceMap.')},m.prototype.generatedPositionFor=function(e){var t=o.getArg(e,"source");if((t=this._findSourceIndex(t))<0)return{line:null,column:null,lastColumn:null};var r={source:t,originalLine:o.getArg(e,"line"),originalColumn:o.getArg(e,"column")},a=this._findMapping(r,this._originalMappings,"originalLine","originalColumn",o.compareByOriginalPositions,o.getArg(e,"bias",l.GREATEST_LOWER_BOUND));if(a>=0){var i=this._originalMappings[a];if(i.source===r.source)return{line:o.getArg(i,"generatedLine",null),column:o.getArg(i,"generatedColumn",null),lastColumn:o.getArg(i,"lastGeneratedColumn",null)}}return{line:null,column:null,lastColumn:null}},t.BasicSourceMapConsumer=m,u.prototype=Object.create(l.prototype),u.prototype.constructor=l,u.prototype._version=3,Object.defineProperty(u.prototype,"sources",{get:function(){for(var e=[],t=0;t<this._sections.length;t++)for(var r=0;r<this._sections[t].consumer.sources.length;r++)e.push(this._sections[t].consumer.sources[r]);return e}}),u.prototype.originalPositionFor=function(e){var t={generatedLine:o.getArg(e,"line"),generatedColumn:o.getArg(e,"column")},r=a.search(t,this._sections,function(e,t){var r=e.generatedLine-t.generatedOffset.generatedLine;return r||e.generatedColumn-t.generatedOffset.generatedColumn}),i=this._sections[r];return i?i.consumer.originalPositionFor({line:t.generatedLine-(i.generatedOffset.generatedLine-1),column:t.generatedColumn-(i.generatedOffset.generatedLine===t.generatedLine?i.generatedOffset.generatedColumn-1:0),bias:e.bias}):{source:null,line:null,column:null,name:null}},u.prototype.hasContentsOfAllSources=function(){return this._sections.every(function(e){return e.consumer.hasContentsOfAllSources()})},u.prototype.sourceContentFor=function(e,t){for(var r=0;r<this._sections.length;r++){var o=this._sections[r].consumer.sourceContentFor(e,!0);if(o)return o}if(t)return null;throw new Error('"'+e+'" is not in the SourceMap.')},u.prototype.generatedPositionFor=function(e){for(var t=0;t<this._sections.length;t++){var r=this._sections[t];if(-1!==r.consumer._findSourceIndex(o.getArg(e,"source"))){var a=r.consumer.generatedPositionFor(e);if(a)return{line:a.line+(r.generatedOffset.generatedLine-1),column:a.column+(r.generatedOffset.generatedLine===a.line?r.generatedOffset.generatedColumn-1:0)}}}return{line:null,column:null}},u.prototype._parseMappings=function(e,t){this.__generatedMappings=[],this.__originalMappings=[];for(var r=0;r<this._sections.length;r++)for(var a=this._sections[r],i=a.consumer._generatedMappings,n=0;n<i.length;n++){var l=i[n],m=a.consumer._sources.at(l.source);m=o.computeSourceURL(a.consumer.sourceRoot,m,this._sourceMapURL),this._sources.add(m),m=this._sources.indexOf(m);var c=null;l.name&&(c=a.consumer._names.at(l.name),this._names.add(c),c=this._names.indexOf(c));var u={source:m,generatedLine:l.generatedLine+(a.generatedOffset.generatedLine-1),generatedColumn:l.generatedColumn+(a.generatedOffset.generatedLine===l.generatedLine?a.generatedOffset.generatedColumn-1:0),originalLine:l.originalLine,originalColumn:l.originalColumn,name:c};this.__generatedMappings.push(u),"number"==typeof u.originalLine&&this.__originalMappings.push(u)}s(this.__generatedMappings,o.compareByGeneratedPositionsDeflated),s(this.__originalMappings,o.compareByOriginalPositions)},t.IndexedSourceMapConsumer=u},function(e,t,r){"use strict";t.GREATEST_LOWER_BOUND=1,t.LEAST_UPPER_BOUND=2,t.search=function(e,r,o,a){if(0===r.length)return-1;var i=function e(r,o,a,i,n,s){var l=Math.floor((o-r)/2)+r,m=n(a,i[l],!0);return 0===m?l:m>0?o-l>1?e(l,o,a,i,n,s):s==t.LEAST_UPPER_BOUND?o<i.length?o:-1:l:l-r>1?e(r,l,a,i,n,s):s==t.LEAST_UPPER_BOUND?l:r<0?-1:r}(-1,r.length,e,r,o,a||t.GREATEST_LOWER_BOUND);if(i<0)return-1;for(;i-1>=0&&0===o(r[i],r[i-1],!0);)--i;return i}},function(e,t,r){"use strict";function o(e,t,r){var o=e[t];e[t]=e[r],e[r]=o}function a(e,t,r,i){if(r<i){var n=r-1;o(e,(c=r,u=i,Math.round(c+Math.random()*(u-c))),i);for(var s=e[i],l=r;l<i;l++)t(e[l],s)<=0&&o(e,n+=1,l);o(e,n+1,l);var m=n+1;a(e,t,r,m-1),a(e,t,m+1,i)}var c,u}t.quickSort=function(e,t){a(e,t,0,e.length-1)}},function(e,t,r){"use strict";var o=r(9).SourceMapGenerator,a=r(7),i=/(\r?\n)/,n="$$$isSourceNode$$$";function s(e,t,r,o,a){this.children=[],this.sourceContents={},this.line=null==e?null:e,this.column=null==t?null:t,this.source=null==r?null:r,this.name=null==a?null:a,this[n]=!0,null!=o&&this.add(o)}s.fromStringWithSourceMap=function(e,t,r){var o=new s,n=e.split(i),l=0,m=function(){return e()+(e()||"");function e(){return l<n.length?n[l++]:void 0}},c=1,u=0,d=null;return t.eachMapping(function(e){if(null!==d){if(!(c<e.generatedLine)){var t=(r=n[l]||"").substr(0,e.generatedColumn-u);return n[l]=r.substr(e.generatedColumn-u),u=e.generatedColumn,h(d,t),void(d=e)}h(d,m()),c++,u=0}for(;c<e.generatedLine;)o.add(m()),c++;if(u<e.generatedColumn){var r=n[l]||"";o.add(r.substr(0,e.generatedColumn)),n[l]=r.substr(e.generatedColumn),u=e.generatedColumn}d=e},this),l<n.length&&(d&&h(d,m()),o.add(n.splice(l).join(""))),t.sources.forEach(function(e){var i=t.sourceContentFor(e);null!=i&&(null!=r&&(e=a.join(r,e)),o.setSourceContent(e,i))}),o;function h(e,t){if(null===e||void 0===e.source)o.add(t);else{var i=r?a.join(r,e.source):e.source;o.add(new s(e.originalLine,e.originalColumn,i,t,e.name))}}},s.prototype.add=function(e){if(Array.isArray(e))e.forEach(function(e){this.add(e)},this);else{if(!e[n]&&"string"!=typeof e)throw new TypeError("Expected a SourceNode, string, or an array of SourceNodes and strings. Got "+e);e&&this.children.push(e)}return this},s.prototype.prepend=function(e){if(Array.isArray(e))for(var t=e.length-1;t>=0;t--)this.prepend(e[t]);else{if(!e[n]&&"string"!=typeof e)throw new TypeError("Expected a SourceNode, string, or an array of SourceNodes and strings. Got "+e);this.children.unshift(e)}return this},s.prototype.walk=function(e){for(var t,r=0,o=this.children.length;r<o;r++)(t=this.children[r])[n]?t.walk(e):""!==t&&e(t,{source:this.source,line:this.line,column:this.column,name:this.name})},s.prototype.join=function(e){var t,r,o=this.children.length;if(o>0){for(t=[],r=0;r<o-1;r++)t.push(this.children[r]),t.push(e);t.push(this.children[r]),this.children=t}return this},s.prototype.replaceRight=function(e,t){var r=this.children[this.children.length-1];return r[n]?r.replaceRight(e,t):"string"==typeof r?this.children[this.children.length-1]=r.replace(e,t):this.children.push("".replace(e,t)),this},s.prototype.setSourceContent=function(e,t){this.sourceContents[a.toSetString(e)]=t},s.prototype.walkSourceContents=function(e){for(var t=0,r=this.children.length;t<r;t++)this.children[t][n]&&this.children[t].walkSourceContents(e);var o=Object.keys(this.sourceContents);for(t=0,r=o.length;t<r;t++)e(a.fromSetString(o[t]),this.sourceContents[o[t]])},s.prototype.toString=function(){var e="";return this.walk(function(t){e+=t}),e},s.prototype.toStringWithSourceMap=function(e){var t={code:"",line:1,column:0},r=new o(e),a=!1,i=null,n=null,s=null,l=null;return this.walk(function(e,o){t.code+=e,null!==o.source&&null!==o.line&&null!==o.column?(i===o.source&&n===o.line&&s===o.column&&l===o.name||r.addMapping({source:o.source,original:{line:o.line,column:o.column},generated:{line:t.line,column:t.column},name:o.name}),i=o.source,n=o.line,s=o.column,l=o.name,a=!0):a&&(r.addMapping({generated:{line:t.line,column:t.column}}),i=null,a=!1);for(var m=0,c=e.length;m<c;m++)10===e.charCodeAt(m)?(t.line++,t.column=0,m+1===c?(i=null,a=!1):a&&r.addMapping({source:o.source,original:{line:o.line,column:o.column},generated:{line:t.line,column:t.column},name:o.name})):t.column++}),this.walkSourceContents(function(e,t){r.setSourceContent(e,t)}),{code:t.code,map:r}},t.SourceNode=s},function(e,t){e.exports=require("main.js.map")},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.Splash=(()=>{console.log('<p style="color:#AE81FF">\n _____ _____ _____ _____ _____ _____ _____    _____    __ _____ _____ \n|   __|     | __  |   __|   __|  _  |   __|  |     |__|  | __  |  |  |\n|__   |   --|    -|   __|   __|   __|__   |  |  |  |  |  | __ -|    -|\n|_____|_____|__|__|_____|_____|__|  |_____|  |_____|_____|_____|__|__|\nVersion: 1.0.0   |   Build Time: April 25th 2018, 1:24:20 pm \n</p>\n')})},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(27);t.default=new class{constructor(){this.loop=(()=>{CPU.fresh(),this.fresh(),this.register(),this.run(),this.cleanup(),this.addon(),CPU.handleData()}),this.install=(()=>{o.install(),this.extend()}),this.extend=(()=>{RoomManager.extend(),FlagManager.extend(),TaskManager.extend(),CreepManager.extend(),MemoryManager.extend()}),this.fresh=(()=>{CPU.check("fresh"),FlagManager.fresh(),PopManager.fresh(),RoomManager.fresh(),TaskManager.fresh(),CreepManager.fresh(),MemoryManager.fresh(),CPU.end("fresh")}),this.analyze=(()=>{CPU.check("analyze","FlagManager"),FlagManager.analyze(),CPU.end("analyze","FlagManager"),CPU.check("analyze","RoomManager"),RoomManager.analyze(),CPU.end("analyze","RoomManager"),CPU.check("analyze","PopManager"),PopManager.analyze(),CPU.end("analyze","PopManager")}),this.register=(()=>{CPU.check("register","RoomManager"),RoomManager.register(),CPU.end("register","RoomManager"),this.analyze(),CPU.check("register","CreepManager"),CreepManager.register(),CPU.end("register","CreepManager"),CPU.check("register","SpawnManager"),SpawnManager.register(),CPU.end("register","SpawnManager"),CPU.check("register","TaskManager"),TaskManager.register(),CPU.end("register","TaskManager")}),this.run=(()=>{CPU.check("run","PopManager"),PopManager.run(),CPU.end("run","PopManager"),CPU.check("run","FlagManager"),FlagManager.run(),CPU.end("run","FlagManager"),CPU.check("run","RoomManager"),RoomManager.run(),CPU.end("run","RoomManager"),CPU.check("run","CreepManager"),CreepManager.run(),CPU.end("run","CreepManager"),CPU.check("run","StructureSpawn"),SpawnManager.run(),CPU.end("run","StructureSpawn"),CPU.check("run","TaskManager"),TaskManager.run(),CPU.end("run","TaskManager")}),this.cleanup=(()=>{CPU.check("cleanup"),FlagManager.cleanup(),PopManager.cleanup(),RoomManager.cleanup(),MemoryManager.cleanup(),CPU.end("cleanup")}),this.addon=(()=>{SEND_STATISTIC_REPORTS&&((!Memory.statistics||Memory.statistics.tick&&Memory.statistics.tick+TIME_REPORT<=Game.time)&&Statistics.run(),Util.processReports()),CPU.check("addon","Visuals"),ROOM_VISUALS&&!Memory.CPU_CRITICAL&&Visuals.run(),CPU.end("addon","Visuals"),CPU.check("run","Layout"),AUTO_LAYOUT&&Game.time%AUTO_LAYOUT_INTERVAL==0&&Layout.run(),CPU.end("run","Layout"),CPU.check("addon","Grafana"),GRAFANA&&Game.time%GRAFANA_INTERVAL==0&&Grafana.run(),CPU.end("addon","Grafana")})}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(28),a=r(50),i=r(8);t.install=(()=>{console.log(String.fromCodePoint(8987),"Code Reloading ...");const e=Game.cpu.getUsed();i.Install("_ME",i.getUsername),i.Install(global,r(57)),i.Install("Util",r(8).default,{DiamondIterator:r(58).default,SpiralIterator:r(59).default}),o.ProtoypeInstall(),a.TravelerInstall(),i.Install(global,r(60).default,{CPU:r(61).default,Dye:r(63).default,Log:r(64).default,Statistics:r(66).default,PopManager:r(67).default,MemoryManager:r(68).default,FlagManager:r(69).default}),i.Install("TaskManager",r(70).default,{guard:r(71).default,defense:r(72).default,mining:r(73).default,claim:r(74).default,reserve:r(75).default,pioneer:r(76).default,attackController:r(77).default,robbing:r(78).default,reputation:r(79).default,delivery:r(80).default,labTech:r(81).default,safeGen:r(82).default,scheduler:r(83).default}),i.Install("CreepManager",r(84).default,{Action:r(3).CreepAction,Behaviour:r(3).Behaviour,Setup:r(3).CreepSetup}),i.Install(CreepManager.action={},{attackController:r(85).default,avoiding:r(86).default,boosting:r(87).default,building:r(88).default,bulldozing:r(89).default,charging:r(90).default,claiming:r(91).default,defending:r(92).default,dismantling:r(93).default,dropping:r(94).default,feeding:r(95).default,fortifying:r(96).default,fueling:r(97).default,guarding:r(98).default,harvesting:r(99).default,healing:r(100).default,idle:r(101).default,invading:r(102).default,mining:r(103).default,picking:r(104).default,reallocating:r(105).default,recycling:r(106).default,repairing:r(107).default,reserving:r(108).default,robbing:r(109).default,safeGen:r(110).default,storing:r(111).default,travelling:r(112).default,uncharging:r(113).default,upgrading:r(114).default,withdrawing:r(115).default}),i.Install(CreepManager.behaviour={},{claimer:r(116).default,collapseWorker:r(117).default,hauler:r(118).default,healer:r(119).default,labTech:r(120).default,melee:r(121).default,miner:r(122).default,mineralMiner:r(123).default,remoteMiner:r(124).default,remoteHauler:r(125).default,remoteWorker:r(126).default,pioneer:r(127).default,privateer:r(128).default,recycler:r(129).default,ranger:r(130).default,upgrader:r(131).default,worker:r(132).default,safeGen:r(133).default}),i.Install(CreepManager.setup={},{hauler:r(134).default,healer:r(135).default,miner:r(136).default,mineralMiner:r(137).default,privateer:r(138).default,upgrader:r(139).default,worker:r(140).default}),i.Install("RoomManager",r(141).default,{extra:{construction:r(142).default,containers:r(143).default,defense:r(144).default,extensions:r(145).default,labs:r(146).default,links:r(147).default,nuker:r(148).default,observers:r(149).default,orders:r(150).default,power:r(151).default,resources:r(152).default,spawns:r(153).default,towers:r(154).default,fillRoomOrders:r(155).default,boostProduction:r(156).default}}),i.Install(global,{SpawnManager:r(157).default,TowerManager:r(158).default}),i.Install(global,{Layout:AUTO_LAYOUT?r(159).default:void 0,Grafana:GRAFANA?r(160).default:void 0,Visuals:r(161).default,Command:r(168)}),i.Install("isRoot",!0);const t=Game.cpu.getUsed();Log.success("Root Done",Dye(COLOR_GREY,`cpu-cost:${(t-e).toFixed(2)}`))})},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.ProtoypeInstall=(()=>{r(29),r(30),r(31),r(32),r(34),r(35),r(36),r(37),r(38),r(39),r(40),r(41),r(42),r(43),r(44),r(45),r(46),r(47),r(48),r(49)})},function(e,t){Util.define(global,class{constructor(){}get observerRequests(){return Util.get(global,"_observerRequests",[])}set observerRequests(e){Util.get(global,"_observerRequests",[]).push(e)}get cacheValid(){return Memory.cacheValid}},!0)},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(12);Util.define(Creep,class extends Creep{constructor(){}cache(e,t,r){return r?(_.isUndefined(this[`_${e}`])||this[`_${e}Set`]!==Game.time)&&(this[`_${e}Set`]=Game.time,this[`_${e}`]=t()):_.isUndefined(this[`_${e}`])&&(this[`_${e}`]=t()),this[`_${e}`]}run(e){if(!this.spawning){if(!e&&this.data&&this.data.creepType){if(e=CreepManager.behaviour[this.data.creepType],this.room.skip)return;if(Memory.CPU_CRITICAL&&!CRITICAL_ROLES.includes(this.data.creepType))return}if(this.data&&!_.contains(["remoteMiner","miner","upgrader"],this.data.creepType)&&(this.repairNearby(),this.buildNearby()),LOG_TRACE&&Log.trace("Creep",{creepName:this.name,pos:this.pos,Behaviour:e&&e.name,Creep:"run"}),e)e.run(this);else if(!this.data){LOG_TRACE&&Log.trace("Creep",{creepName:this.name,pos:this.pos,Creep:"run"},"memory init");let e=this.memory.setup,t=this.memory.cost,r=this.memory.home,o=this.memory.mother,a=this.memory.breeding;if(e&&t&&r&&o&&a){Log.module("Creep","Fixing corrupt creep without population entry: "+this.name);let i=PopManager.setCreep({creepName:this.name,creepType:e,weight:t,roomName:this.pos.roomName,homeRoom:r,motherSpawn:o,actionName:this.action?this.action.name:null,targetId:this.target?this.target.id||this.target.name:null,spawningTime:a,flagName:null,body:_.countBy(this.body,"type")});PopManager.countCreep(this.room,i)}else{Log.error("[Creep] Corrupt creep without population entry! : "+this.name,Log.stack());let e=_.countBy(this.body,"type");if(e[WORK]&&e[CARRY]){let t=e[WORK]*BODYPART_COST[WORK]+e[CARRY]*BODYPART_COST[CARRY]+e[MOVE]*BODYPART_COST[MOVE],r=PopManager.setCreep({creepName:this.name,creepType:"worker",weight:t,roomName:this.pos.roomName,homeRoom:this.pos.roomName,motherSpawn:null,actionName:null,targetId:null,spawningTime:-1,flagName:null,body:_.countBy(this.body,"type")});PopManager.countCreep(this.room,r)}else this.suicide()}}this.flee&&(this.fleeMove(),CreepManager.behaviour.ranger.heal(this),SAY_ASSIGNMENT&&this.say(String.fromCharCode(10133),SAY_PUBLIC))}o.Strategy.freeStrategy(this)}travelTo(e,t={}){return e=e.pos||e,global.traveler&&global.travelerTick!==Game.time&&(global.traveler=new Traveler),t=this.getStrategyHandler([],"moveOptions",t),_.defaults(t,{allowSK:!0,avoidSKCreeps:!0,debug:DEBUG,reportThreshold:TRAVELER_THRESHOLD,useFindRoute:_.get(global,"ROUTE_PRECALCULATION",!0),routeCallback:RoomManager.routeCallback(this.pos.roomName,e.roomName,t),getStructureMatrix:e=>RoomManager.getStructureMatrix(e.name||e,t),getCreepMatrix:e=>e.getCreepMatrix(t.getStructureMatrix(e))}),t.respectRamparts&&this.room.situation.invasion&&_.filter(this.pos.lookFor(LOOK_STRUCTURES),{my:!0,structureType:STRUCTURE_RAMPART}).length?OK:traveler.travelTo(this,e,t)}fleeMove(){if(LOG_TRACE&&Log.trace("Creep",{creepName:this.name,pos:this.pos,Action:"fleeMove",Creep:"run"}),_.forEach(Object.keys(this.carry),e=>{this.carry[e]>0&&this.drop(e)}),this.fatigue>0)return;let e;if(!this.data.fleePath||this.data.fleePath.length<2||this.data.fleePath[0].x!==this.pos.x||this.data.fleePath[0].y!==this.pos.y||this.data.fleePath[0].roomName!==this.pos.roomName){const t=_.map(this.room.hostiles,e=>({pos:e.pos,range:5}));e=PathFinder.search(this.pos,t,{flee:!0,plainCost:2,swampCost:10,maxOps:500,maxRooms:2,roomCallback:e=>{let t=Game.rooms[e];if(t)return t.creepMatrix}}).path,this.data.fleePath=e}else this.data.fleePath.shift(),e=this.data.fleePath;e&&e.length>0&&this.move(this.pos.getDirectionTo(new RoomPosition(e[0].x,e[0].y,e[0].roomName)))}idleMove(){if(!(this.fatigue>0)&&_(this.room.structures.piles).filter("pos",this.pos).concat(this.pos.lookFor(LOOK_STRUCTURES)).concat(this.pos.lookFor(LOOK_CONSTRUCTION_SITES)).size()){if(this.data.idle&&this.data.idle.path&&this.data.idle.path.length&&!this.pos.isEqualTo(this.data.idle.lastPos))this.data.idle.path=this.data.idle.path.substr(1);else{const e=FlagManager.find(FLAG_COLOR.command.idle,this.pos,!0,(e,t)=>{const r=Game.flags[t.name].pos.lookFor(LOOK_CREEPS);return r&&r.length?1/0:e});let t;if(e)t=PathFinder.search(this.pos,{pos:e.pos,range:0},{plainCost:2,swampCost:10,maxOps:350,maxRooms:1,roomCallback:e=>{let t=Game.rooms[e];if(t)return t.structureMatrix}});else{let e=this.room.structures.all.map(e=>({pos:e.pos,range:1})).concat(this.room.sources.map(e=>({pos:e.pos,range:2}))).concat(this.pos.findInRange(FIND_EXIT,2).map(e=>({pos:e,range:1}))).concat(this.room.myConstructionSites.map(e=>({pos:e.pos,range:1})));t=PathFinder.search(this.pos,e,{flee:!0,plainCost:2,swampCost:10,maxOps:350,maxRooms:1,roomCallback:e=>{let t=Game.rooms[e];if(t)return t.structureMatrix}})}this.data.idle={path:Traveler.serializePath(this.pos,t.path),lastPos:this.pos}}const e=parseInt(this.data.idle.path[0],10);e&&(this.data.idle.lastPos=this.pos,this.move(e)),this.data.idle.path&&!this.data.idle.path.length&&delete this.data.idle}}get trace(){return Memory.debugTrace.creepName===this.name}set trace(e){e?Memory.debugTrace.creepName=this.name:this.trace&&delete Memory.debugTrace.creepName}get flee(){if(this.data)return this.data.flee?this.data.flee=this.hits!==this.hitsMax:this.data.flee=this.hits/this.hitsMax<.35,this.data.flee}set flee(e){this.data.flee=e}get sum(){return this.cache("sum",()=>_.sum(this.carry),!0)}get carries(){return this.cache("carries",()=>this.carry,!0)}get threat(){return this.cache("threat",()=>CreepManager.bodyThreat(this.body))}get behaviour(){return CreepManager.behaviour[this.data.creepType]}assignAction(e,t){if(_.isString(e)&&(e=CreepManager.action[e]),e&&e instanceof CreepManager.Action)return e.assign(this,t)}assignBehaviour(e){if(_.isString(e)&&(e=CreepManager.behaviour[e]),e&&e instanceof CreepManager.Behaviour)return e.assign(this)}findGroupMemberByType(e,t){return this.findGroupMemberBy(t=>t.creepType===e,t)}findGroupMemberBy(e,t){if(_.isUndefined(t)&&(t=this.data.flagName),!_.isUndefined(e)&&t){const r=_(Memory.population).filter({flagName:t}).find(e);return r?r.creepName:null}return Log.error(`${this.name} - Invalid arguments for CreepManager.findGroupMemberBy ${t} ${e}`),null}findByType(e){let t;for(let r in Memory.population)if((t=Memory.population[r]).creepType===e)return r}getBodyparts(e){return _(this.body).filter({type:e}).value().length}hasActiveBodyparts(e){return this.hasBodyparts(e,this.body.length-Math.ceil(.01*this.hits))}hasBodyparts(e,t=0){const r=this.body,o=r.length;Array.isArray(e)||(e=[e]);for(let a=t;a<o;a++)if(e.includes(r[a].type))return!0;return!1}leaveBorder(){let e=0;return 0===this.pos.y?e=BOTTOM:0===this.pos.x?e=RIGHT:49===this.pos.y?e=TOP:49===this.pos.x&&(e=LEFT),e&&this.move(e),e}honk(){HONK&&this.say("",SAY_PUBLIC)}honkEvade(){HONK&&this.say("",SAY_PUBLIC)}repairNearby(){if(!this.room.controller||!this.room.controller.owner||this.room.my||this.room.reserved||this.room.ally)if(this.carry.energy>0&&this.hasActiveBodyparts(WORK)){const e=this.data&&"remoteHauler"===this.data.creepType?REMOTE_HAULER.DRIVE_BY_REPAIR_RANGE:DRIVE_BY_REPAIR_RANGE,t=_(this.pos.findInRange(FIND_STRUCTURES,e)).find(e=>RoomManager.shouldRepair(this.room,e));t&&(LOG_TRACE&&Log.trace("Creep",{creepName:this.name,Action:"repairing",Creep:"repairNearby"},t.pos),this.repair(t))}else LOG_TRACE&&Log.trace("Creep",{creepName:this.name,pos:this.pos,Action:"repairing",Creep:"repairNearby"},"not repairing")}buildNearby(){if(!REMOTE_HAULER.DRIVE_BY_BUILDING||!this.data||"remoteHauler"!==this.data.creepType)return;const e=_(this.pos.findInRange(FIND_MY_CONSTRUCTION_SITES,REMOTE_HAULER.DRIVE_BY_BUILD_RANGE)).find(e=>REMOTE_HAULER.DRIVE_BY_BUILD_ALL||e.structureType===STRUCTURE_CONTAINER||e.structureType===STRUCTURE_ROAD);e?(LOG_TRACE&&Log.trace("Creep",{creepName:this.name,Action:"building",Creep:"buildNearby"},e.pos),this.build(e)):LOG_TRACE&&Log.trace("Creep",{creepName:this.name,Action:"building",Creep:"buildNearby"},"not building")}controllerSign(){const e=Util.fieldOrFunction(CONTROLLER_SIGN_MESSAGE,this.room);CONTROLLER_SIGN&&(!this.room.controller.sign||this.room.controller.sign.username!==this.owner.username||CONTROLLER_SIGN_UPDATE&&this.room.controller.sign.text!==e)&&this.signController(this.room.controller,e)}handleError(e){CreepManager.resolvingError||(this.resolvingError=e,e.preventDefault=(()=>{CreepManager.resolvingError=null}),CreepManager.error.trigger(e),CreepManager.resolvingError&&(Log.errorCode(this,e.errorCode),delete this.data.actionName,delete this.data.targetId,CreepManager.resolvingError=null))}explainAgent(){return this.action&&this.action.showAssignment(this,this.target),`ttl:${this.ticksToLive} pos:${this.pos}`}})},function(e,t){Util.define(Flag,class extends Flag{constructor(){}get print(){return Util.makeFlagUrl(this.name)}get cloaking(){return this.memory.cloaking||0}set cloaking(e){this.memory.cloaking=e}compareTo(e){return FlagManager.compare(this,e)}})},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(33);Room.prototype._find=Room.prototype.find;Util.define(Room,class extends Room{constructor(){}cache(e,t){return _.isUndefined(this[`_${e}`])&&(this[`_${e}`]=t()),this[`_${e}`]}memoryCache(e,t){return _.isUndefined(this.memory[e])&&(this.memory[e]=t()),this.memory[e]}get my(){return this.cache("my",()=>this.controller&&this.controller.my)}get ally(){return this.cache("ally",()=>{let e=!1;return this.reserved?e=!0:this.controller&&(e=TaskManager.reputation.isAlly(this.owner)||TaskManager.reputation.isAlly(this.reservation)),e})}get RCL(){if(!_.isUndefined(this.controller))return this.memoryCache("RCL",()=>this.controller.level)}checkRCL(){this.controller&&this.memory.RCL!==this.controller.level&&(RoomManager.RCLChange.trigger(this),this.memory.RCL=this.controller.level)}get skip(){return this.cache("skip",()=>!!FlagManager.find(FLAG_COLOR.command.skipRoom,this))}get reservation(){return this.cache("reservation",()=>{let e=!1;return this.controller&&this.controller.reservation&&(e=this.controller.reservation.username),e})}get myReservation(){return this.cache("myReservation",()=>this.reservation===ME)}get reserved(){return this.cache("reserved",()=>{let e=!1;if(this.controller){const t=_.find(Game.spawns).owner.username;e=this.controller.my||this.controller.reservation&&this.controller.reservation.username===t}return e})}get owner(){return this.cache("owner",()=>!(!this.controller||!this.controller.owner)&&this.controller.owner.username)}get print(){return Util.makeRoomUrl(this.name)}get creeps(){return this.cache("creeps",()=>this.find(FIND_MY_CREEPS))}get allCreeps(){return this.cache("allCreeps",()=>this.find(FIND_CREEPS))}get immobileCreeps(){return this.cache("allCreeps",()=>_.filter(this.creeps,e=>{const t=e.data&&e.data.determinatedSpot;return t&&e.pos.isEqualTo(e.room.getPositionAt(t.x,t.y))}))}countMySites(){const e=_.size(this.myConstructionSites);_.isUndefined(this.memory.myTotalSites)||e===this.memory.myTotalSites||RoomManager.costMatrixInvalid.trigger(this),e>0?this.memory.myTotalSites=e:delete this.memory.myTotalSites}countMyStructures(){const e=_.size(this.structures.my);_.isUndefined(this.memory.myTotalStructures)||e===this.memory.myTotalStructures?delete this.memory.myTotalStructures:(RoomManager.costMatrixInvalid.trigger(this),this.saveExtensions(),this.saveSpawns())}get flags(){return this.cache("flags",()=>_.filter(FlagManager.list,{roomName:this.name}))}newFlag(e,t,r){return t||(t=this.getPositionAt(25,25)),t.newFlag(e,r)}get structures(){return this.cache("structures",()=>new o.RoomStructures(this))}get combatCreeps(){return this.cache("combatCreeps",()=>this.creeps.filter(e=>["melee","ranger","healer","warrior"].includes(e.data.creepType)))}get hurtCreeps(){return this.cache("hurtCreeps",()=>_.sortBy(_.filter(this.creeps,e=>e.hits<e.hitsMax&&(void 0===e.towers||0===e.towers.length)),"hits"))}get hostile(){return this.memory.hostile}registerIsHostile(){this.controller&&(_.isUndefined(this.hostile)||_.isNumber(this.hostile))&&(!this.controller.owner||this.controller.my||this.ally?delete this.memory.hostile:this.memory.hostile=this.controller.level)}get hostiles(){return this.cache("hostiles",()=>this.find(FIND_HOSTILE_CREEPS,{filter:TaskManager.reputation.hostileOwner}))}get hostileIds(){return this.cache("hostileIds",()=>Util.getGame.objsToIdArray(this.hostiles))}get hostileThreatLevel(){return this.cache("hostileThreatLevel",()=>{let e=0;return this.hostiles.forEach(t=>{e+=t.threat}),e})}processInvaders(){_.isUndefined(this.memory.hostileIds)&&(this.memory.hostileIds=[]),SEND_STATISTIC_REPORTS?_.isUndefined(this.memory.statistics)&&(this.memory.statistics={}):delete this.memory.statistics,_.forEach(this.hostiles,e=>{if(!RoomManager.isCenterNineRoom(this.name)&&!this.memory.hostileIds.includes(e.id)&&(this.memory.hostileIds.push(e.id),this.newInvader.push(e),SEND_STATISTIC_REPORTS)){const t=JSON.stringify(_.countBy(e.body,"type"));_.isUndefined(this.memory.statistics.invaders)&&(this.memory.statistics.invaders=[]),this.memory.statistics.invaders.push({owner:e.owner.username,id:e.id,body:t,enter:Game.time,time:Date.now()})}}),_.forEach(this.memory.hostileIds,e=>{const t=Game.getObjectById(e);if((!t||!TaskManager.reputation.hostileOwner(t))&&(this.goneInvader.push(e),SEND_STATISTIC_REPORTS&&this.memory.statistics&&void 0!==this.memory.statistics.invaders&&this.memory.statistics.invaders.length>0)){const t=t=>t.id===e&&_.isUndefined(t.leave),r=_.find(this.memory.statistics.invaders,t);_.isUndefined(r)||(r.leave=Game.time)}}),this.memory.hostileIds=this.hostileIds}get lowDefenseEnergy(){return this.my&&this.storage&&this.storage.charge<0}get defenseLevel(){return this.cache("defenseLevel",()=>{let e={towers:0,creeps:0,sum:0};return this.combatCreeps.forEach(t=>e.creeps+=t.threat),e.towers=this.structures.towers.length,e.sum=e.creeps+e.towers*CREEP_PART_THREAT.tower,e})}get isCriticallyFortifyable(){return _.some(this.structures.fortifyable,"isCriticallyFortifyable")}get relativeEnergyAvailable(){return this.energyCapacityAvailable>0?this.energyAvailable/this.energyCapacityAvailable:0}get relativeRemainingEnergyAvailable(){return this.energyCapacityAvailable>0?this.remainingEnergyAvailable/this.energyCapacityAvailable:0}get remainingEnergyAvailable(){return this.energyAvailable-this.reservedSpawnEnergy}get reservedSpawnEnergy(){return _.isUndefined(this._reservedSpawnEnergy)&&(this._reservedSpawnEnergy=0),this._reservedSpawnEnergy}set reservedSpawnEnergy(e){this._reservedSpawnEnergy=e}get situation(){return this.cache("situation",()=>({noEnergy:0==this.sourceEnergyAvailable,invasion:this.hostiles.length>0&&(!this.controller||!this.controller.safeMode)}))}get collapsed(){return this.cache("collapsed",()=>!!this.my&&(!this.population||(this.population.typeCount.worker?this.population.typeCount.worker:0)+(this.population.typeCount.hauler?this.population.typeCount.hauler:0)+(this.population.typeCount.pioneer?this.population.typeCount.pioneer:0)===0))}get adjacentRooms(){return this.memoryCache("adjacentRooms",()=>RoomManager.adjacentRooms(this.name))}get adjacentAccessibleRooms(){return this.memoryCache("adjacentAccessibleRooms",()=>RoomManager.adjacentAccessibleRooms(this.name))}find(e,t){return _.isArray(e)?_(e).map(e=>this._find(e,t)).flatten().value():this._find(e,t)}get privateerMaxWeight(){return this.cache("privateerMaxWeight",()=>{let e=0;if(!this.situation.invasion&&!this.lowDefenseEnergy){const t=1e3*this.controller.level;let r,o,a,i;const n=e=>{e!=this.name&&RoomManager.isMine(e)&&o++},s=s=>{this.adjacentAccessibleRooms.includes(s.roomName)&&((a=Game.rooms[s.roomName])?(r=a.adjacentAccessibleRooms,i=a.sources.length):(r=RoomManager.adjacentAccessibleRooms(s.roomName),i=1),o=1,r.forEach(n),e+=i*t/o)};FlagManager.filter(FLAG_COLOR.invade.exploit).forEach(s)}return e})}get claimerMaxWeight(){return this.cache("claimerMaxWeight",()=>{let e,t,r,o=0;return FlagManager.filter([FLAG_COLOR.claim,FLAG_COLOR.claim.reserve,FLAG_COLOR.invade.exploit]).forEach(a=>{if(this.RCL>3||a.color==FLAG_COLOR.claim.color&&a.secondaryColor==FLAG_COLOR.claim.secondaryColor){if((e=RoomManager.roomDistance(this.name,a.roomName))>2)return;if((r=Game.flags[a.name]).room&&r.room.controller&&r.room.controller.reservation&&r.room.controller.reservation.ticksToEnd>2500)return;t=r.targetOf&&r.targetOf?_.sum(r.targetOf.map(e=>"claimer"==e.creepType?e.weight:0)):0,o+=1250-t}}),o})}findRoute(e,t=!0,r=!0,o=!0){if(this.name==e)return[];const a={checkOwner:t,preferHighway:r,allowSK:o};return Game.map.findRoute(this,e,{routeCallback:RoomManager.routeCallback(this.name,e,a)})}getBorder(e){return _.findKey(Game.map.describeExits(this.name),function(e){return this.name===e},{name:e})}exits(e,t){let r,o,a;!0===t&&(t=.5),r=0===e?_.chain(this.find(FIND_STRUCTURES)).filter(function(e){return e.structureType===STRUCTURE_PORTAL}).map("pos").value():this.find(e);let i=-1,n={};const s=[];for(let e=0;e<r.length;e++){const l=r[e];_.get(n,[l.x-1,l.y])||_.get(n,[l.x,l.y-1])||(t&&-1!==i&&(s[i].x+=Math.ceil(t*(o-s[i].x)),s[i].y+=Math.ceil(t*(a-s[i].y))),s[++i]=_.pick(l,["x","y"]),o=l.x,a=l.y,n={}),_.set(n,[l.x,l.y],!0),o=Math.max(o,l.x),a=Math.max(a,l.y)}return t&&-1!==i&&(s[i].x+=Math.ceil(t*(o-s[i].x)),s[i].y+=Math.ceil(t*(a-s[i].y))),s}isWalkable(e,t,r){return 0===(r=r?r[t][e]:this.lookAt(e,t)).filter(e=>e.type==LOOK_TERRAIN&&"wall"==e.terrain||OBSTACLE_OBJECT_TYPES.includes(e[e.type].structureType)).length}get highwayHasWalls(){return this.cache("highwayHasWalls",()=>!!RoomManager.isHighwayRoom(this.name)&&!!_.find(this.getPositionAt(25,25).lookFor(LOOK_STRUCTURES),e=>e instanceof StructureWall))}recordMove(e){if(!ROAD_CONSTRUCTION_ENABLE&&(!ROAD_CONSTRUCTION_FORCED_ROOMS[Game.shard.name]||ROAD_CONSTRUCTION_FORCED_ROOMS[Game.shard.name]&&-1==ROAD_CONSTRUCTION_FORCED_ROOMS[Game.shard.name].indexOf(this.name)))return;let t=e.pos.x,r=e.pos.y;if(0==t||0==r||49==t||49==r||0==e.carry.energy||"building"==e.data.actionName)return;let o=`${String.fromCharCode(32+t)}${String.fromCharCode(32+r)}_x${t}-y${r}`;this.roadConstructionTrace[o]?this.roadConstructionTrace[o]++:this.roadConstructionTrace[o]=1}isTargetAccessible(e,t){if(!e||!t)return!1;e instanceof RoomObject&&(e=e.pos),t instanceof RoomObject&&(t=t.pos);for(const r of["x","y","roomName"])if(!Reflect.has(e,r)||!Reflect.has(t,r))return!1;if(!RoomManager.isHighwayRoom(this.name))return!1;if(!this.highwayHasWalls)return!0;const[r,o]=RoomManager.calcCoordinates(this.name,(e,t)=>[e,t]),a=e=>0===Math.floor(e.x/25)?LEFT:RIGHT,i=e=>0===Math.floor(e.y/25)?TOP:BOTTOM,n=e=>{const t=a(e),r=i(e);return t===LEFT?r===TOP?TOP_LEFT:BOTTOM_LEFT:r===TOP?TOP_RIGHT:BOTTOM_RIGHT};if(r%10==0){if(o%10==0){const r=!!_.find(this.getPositionAt(25,24).lookFor(LOOK_STRUCTURES),e=>e instanceof StructureWall),o=!!_.find(this.getPositionAt(24,25).lookFor(LOOK_STRUCTURES,e=>e instanceof StructureWall)),s=!!_.find(this.getPositionAt(25,26).lookFor(LOOK_STRUCTURES,e=>e instanceof StructureWall)),l=!!_.find(this.getPositionAt(26,25).lookFor(LOOK_STRUCTURES,e=>e instanceof StructureWall));if(n(e)===n(t))return!0;if(r&&o&&s&&l)return n(e)===n(t);if(r){if(s)return o?Util.areEqual(RIGHT,a(e),a(t)):Util.areEqual(LEFT,a(e),a(t));if(o&&l)return i(e)===i(t)&&Util.areEqual(BOTTOM,i(e),i(t));if(Util.areEqual(BOTTOM,i(e),i(t)))return!0;if(o){if(Util.areEqual(RIGHT,a(e),a(t)))return!0;if(n(e)===TOP_LEFT&&n(t)!==TOP_LEFT)return!1}else{if(Util.areEqual(LEFT,a(e),a(t)))return!0;if(n(e)===TOP_RIGHT&&n(t)!==TOP_RIGHT)return!1}}else{if(o&&l)return i(e)===i(t)&&Util.areEqual(TOP,i(e),i(t));if(Util.areEqual(TOP,i(e),i(t)))return!0;if(o){if(Util.areEqual(RIGHT,a(e),a(t)))return!0;if(n(e)===BOTTOM_LEFT&&n(t)!==BOTTOM_LEFT)return!1}else{if(Util.areEqual(LEFT,a(e),a(t)))return!0;if(n(e)===BOTTOM_RIGHT&&n(t)!==BOTTOM_RIGHT)return!1}}return!0}if(a(e)===a(t))return!0}return o%10==0&&(i(e),i(t)),!0}targetAccessible(e){if(!e)return!1;e instanceof RoomObject&&(e=e.pos);for(const t of["x","y","roomName"])if(!Reflect.has(e,t))return!1;if(!RoomManager.isHighwayRoom(this.name))return!1;if(!this.highwayHasWalls)return!0;const t=_(Game.rooms).filter("my").min(e=>Game.map.getRoomLinearDistance(e.name,this.name));if(t===1/0)return!1;const[r,o]=RoomManager.calcGlobalCoordinates(this.name,(e,t)=>[e,t]),[a,i]=RoomManager.calcGlobalCoordinates(t,(e,t)=>[e,t]);let n="";if(o-i<0?n+="south":o-i>0&&(n+="north"),r-a<0?n+="east":r-a>0&&(n+="west"),r%10==0){if(o%10==0){if(n.includes("south")&&n.includes("east"))return this.isTargetAccessible(this.getPositionAt(49,49),e);if(n.includes("south")&&n.includes("west"))return this.isTargetAccessible(this.getPositionAt(0,49),e);if(n.includes("north")&&n.includes("east"))return this.isTargetAccessible(this.getPositionAt(49,0),e);if(n.includes("north")&&n.includes("west"))return this.isTargetAccessible(this.getPositionAt(0,0),e)}if(n.includes("east"))return this.isTargetAccessible(this.getPositionAt(49,25),e);if(n.includes("west"))return this.isTargetAccessible(this.getPositionAt(0,25),e)}if(o%10==0){if(n.includes("south"))return this.isTargetAccessible(this.getPositionAt(25,49),e);if(n.includes("north"))return this.isTargetAccessible(this.getPositionAt(25,0),e)}return!0}get structureMatrix(){return this.cache("structureMatrix",()=>{let e;const t=RoomManager.getCachedStructureMatrix(this.name);if(t)e=t;else{Log.room(this.name,"Matrix: Calculating cost matrix");const t=new PathFinder.CostMatrix,r=e=>{const r=e instanceof ConstructionSite;if(r&&!e.my&&TaskManager.reputation.allyOwner(e))return t.set(e.pos.x,e.pos.y,255);if(e.structureType===STRUCTURE_ROAD){if(!r||USE_UNBUILT_ROADS)return t.set(e.pos.x,e.pos.y,1)}else{if(e.structureType===STRUCTURE_PORTAL)return t.set(e.pos.x,e.pos.y,255);if(OBSTACLE_OBJECT_TYPES.includes(e.structureType)){if(!r||TaskManager.reputation.allyOwner(e))return t.set(e.pos.x,e.pos.y,255)}else if(e.structureType===STRUCTURE_RAMPART&&!e.my&&!e.isPublic&&(!r||TaskManager.reputation.allyOwner(e)))return t.set(e.pos.x,e.pos.y,255)}},o=e=>t.set(e.pos.x,e.pos.y,255);this.structures.all.forEach(r),this.constructionSites.forEach(r),this.immobileCreeps.forEach(o);const a=_.get(RoomManager.pathfinderCache,[this.name,"updated"]);RoomManager.pathfinderCache[this.name]={costMatrix:t,updated:Game.time,version:RoomManager.COSTMATRIX_CACHE_VERSION},RoomManager.pathfinderCacheDirty=!0,LOG_TRACE&&Log.trace("PathFinder",{roomName:this.name,prevTime:a,structures:this.structures.all.length,PathFinder:"CostMatrix"},"updated costmatrix"),e=t}return e})}getCreepMatrix(e=this.structureMatrix){return this.cache("creepMatrix",()=>{const t=e.clone();return this.allCreeps.forEach(function(e){t.set(e.pos.x,e.pos.y,255)}),t})}invalidateCostMatrix(){RoomManager.costMatrixInvalid.trigger(this.name)}get avoidSKMatrix(){return this.cache("avoidSKMatrix",()=>{const e=this.hostiles.filter(e=>"Source Keeper"===e.owner.username);return this.getAvoidMatrix({"Source Keeper":e})})}getAvoidMatrix(e){const t=this.structureMatrix.clone();for(const r in e){const o=e[r];for(const e of o)for(let r=Math.max(0,e.pos.x-3);r<=Math.min(49,e.pos.x+3);r++){const o=r<e.pos.x?e.pos.x-r:r-e.pos.x;for(let a=Math.max(0,e.pos.y-3);a<=Math.min(49,e.pos.y+3);a++)if(this.isWalkable(r,a)){const i=a<e.pos.y?e.pos.y-a:a-e.pos.y,n=17-2*Math.max(o,i);t.set(r,a,n)}}}return t}showCostMatrix(e=this.structureMatrix,t){const r=new RoomVisual(this.name);let o=0,a=50,i=0,n=50;t&&(o=Math.max(0,t.y-3),a=Math.min(50,t.y+4),i=Math.max(0,t.x-3),n=Math.min(50,t.x+4));const s=_.max(e._bits);for(let t=o;t<a;t++)for(let o=i;o<n;o++){const a=e.get(o,t);a&&r.text(a,o,t),r.rect(o-.5,t-.5,1,1,{fill:Visuals.getColourByPercentage(a/s)})}}get pavementArt(){return this.memoryCache("pavementArt",()=>[])}})},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});class o{constructor(e){this.room=e}cache(e,t,r=[]){return _.isUndefined(this[`_${e}`])&&(r&&(this[`_${e}`]=r),this[`_${e}`]=t()),this[`_${e}`]}memoryCache(e,t){return _.isUndefined(this.memory[e])&&(this.memory[e]=Util.getGame.objsToIdArray(t())),Util.getGame.objs(this.memory[e])}get memory(){return this.room.memory}set memory(e){this.room.memory=e}get all(){return this.cache("all",()=>this.room.find(FIND_STRUCTURES))}get my(){return this.cache("my",()=>this.room.find(FIND_MY_STRUCTURES))}get towers(){return this.cache("towers",()=>Util.getGame.objs(this.memory.towers))}get container(){return this.cache("container",()=>new RoomManager.Containers(this.room))}get links(){return this.cache("links",()=>new RoomManager.Links(this.room))}get labs(){return this.cache("labs",()=>new RoomManager.Labs(this.room))}get extensions(){return this.memoryCache("extensions",()=>_.filter(this.all,e=>e.structureType===STRUCTURE_EXTENSION))}get spawns(){return this.cache("spawns",()=>Util.getGame.objs(this.memory.spawns))}get powerSpawns(){return this.cache("powerSpawns",()=>new RoomManager.PowerSpawn(this.room))}get nuker(){return this.cache("nuker",()=>{if(this.memory.nukers&&this.memory.nukers.length>0)return Game.getObjectById(this.memory.nukers[0].id)})}get nukers(){return this.cache("nukers",()=>new RoomManager.Nuker(this.room))}get observer(){return this.cache("observer",()=>{if(this.memory.observer)return Game.getObjectById(this.memory.observer.id)})}get feedable(){return this.cache("feedable",()=>this.extensions.concat(this.spawns))}get repairable(){return this.cache("repairable",()=>_.sortBy(this.all.filter(e=>RoomManager.shouldRepair(this.room,e)),"hits"))}get urgentRepairable(){return this.cache("urgentRepairable",()=>{return _.filter(this.repairable,e=>e.hits<LIMIT_URGENT_REPAIRING+(DECAY_AMOUNT[e.structureType]||0))})}get fortifyable(){return this.cache("fortifyable",()=>_.sortBy(this.all.filter(e=>this.room.my&&e.hits<e.hitsMax&&e.hits<MAX_FORTIFY_LIMIT[this.room.RCL]&&(e.structureType!=STRUCTURE_CONTAINER||e.hits<MAX_FORTIFY_CONTAINER)&&(!DECAYABLES.includes(e.structureType)||e.hitsMax-e.hits>3*GAP_REPAIR_DECAYABLE)&&(void 0===Memory.pavementArt[this.room.name]||Memory.pavementArt[this.room.name].indexOf("x"+e.pos.x+"y"+e.pos.y+"x")<0)&&!FlagManager.list.some(t=>t.roomName==e.pos.roomName&&t.color==COLOR_ORANGE&&t.x==e.pos.x&&t.y==e.pos.y)),"hits"))}get fuelable(){return this.cache("fuelable",()=>{const e=this.room.situation.invasion?1:.82;return _.sortBy(_.filter(this.towers,t=>t.energy<t.energyCapacity*e),"energy")})}get piles(){return this.cache("piles",()=>{const e=this.room;return FlagManager.filter(FLAG_COLOR.command.drop,e.getPositionAt(25,25),!0).map(t=>{const r=Game.flags[t.name],o=e.lookForAt(LOOK_ENERGY,r.pos.x,r.pos.y);return o.length&&o[0]||r})})}get virtual(){return this.cache("virtual",()=>_(this.all).concat(this.piles))}}t.RoomStructures=class{constructor(e){this.extend=(()=>{Util.define(this,o,!0)}),this.room=e,this.extend()}}},function(e,t){Util.define(RoomPosition,class extends RoomPosition{constructor(){}cache(e,t){return _.isUndefined(this[`_${e}`])&&(this[`_${e}`]=t()),this[`_${e}`]}get adjacent(){return this.cache("adjacent",()=>{let e=[];for(let t=this.x-1;t<this.x+2;t++)for(let r=this.y-1;r<this.y+2;r++)t>0&&t<49&&r>0&&r<49&&e.push(new RoomPosition(t,r,this.roomName));return e})}radius(e=1){if(1===e)return this.adjacent;if(e<1)return[this];const t=[];for(let r=this.x-e;r<=this.x+e;r++)for(let o=this.y-e;o<=this.y+e;o++){const e=new RoomPosition(r,o,this.roomName);r<50&&r>0&&o>0&&o<50&&!_.isEqual(this,e)&&t.push(e)}return t}findClosestByPathFinder(e,t=_.identity){let r=_.map(e,t);if(_.isEmpty(r))return{goal:null};let o=PathFinder.search(this,r,{maxOps:16e3,roomCallback:e=>{let t=Game.rooms[e];if(t)return t.structureMatrix}}),a=_.last(o.path);void 0==a&&(a=this);let i=_.min(e,e=>a.getRangeTo(e.pos));return{goal:Math.abs(i)!==1/0?i:null,cost:o.cost,ops:o.ops,incomplete:o.incomplete}}findClosestSpawn(){return this.findClosestByPathFinder(Game.spawns,e=>({pos:e.pos,range:1})).goal}newFlag(e,t){if(e||(e=_.get(FLAG_COLOR,e)),e)return this.createFlag(t,e.color,e.secondaryColor)}})},function(e,t){Util.define(RoomObject,class extends RoomObject{constructor(){}get accessibleFields(){if(this.memory&&!_.isUndefined(this.memory.accessibleFields))return this.memory.accessibleFields;{let e=this.room.lookForAtArea(LOOK_TERRAIN,this.pos.y-1,this.pos.x-1,this.pos.y+1,this.pos.x+1,!0),t=_.countBy(e,"terrain").wall,r=void 0===t?9:9-t;return this.memory?this.memory.accessibleFields=r:r}}get cloak(){const e=Memory.cloaked[this.id];return!!e&&(_.isNumber(e)&&Game.time>e?(delete Memory.cloaked[this.id],!1):e)}set cloak(e){if(e)return _.isNumber(e)?e<Game.time&&(e=Game.time+e):e=!0,Memory.cloaked[this.id]=e;delete Memory.cloaked[this.id]}})},function(e,t){Util.define(Source,class extends Source{constructor(){}get memory(){if(_.isUndefined(Memory.sources)&&(Memory.sources={}),_.isObject(Memory.sources))return Memory.sources[this.id]=Memory.sources[this.id]||{}}set memory(e){if(_.isUndefined(Memory.sources)&&(Memory.sources={}),!_.isObject(Memory.sources))throw new Error("Could not set memory extension for sources");Memory.sources[this.id]=e}get container(){return _.isUndefined(this.memory.container)&&this.room.saveContainers(),_.isUndefined(this._container)&&(this.memory.storage?(this._container=Game.getObjectById(this.memory.storage),this._container||delete this.memory.storage):this.memory.terminal?(this._container=Game.getObjectById(this.memory.terminal),this._container||delete this.memory.terminal):this.memory.container?(this._container=Game.getObjectById(this.memory.container),this._container||delete this.memory.container):this._container=null),this._container}get link(){return _.isUndefined(this._link)&&(this.memory.link?(this._link=Game.getObjectById(this.memory.link),this._link||delete this.memory.link):this._link=null),this._link}}),Util.define(Mineral,class extends Mineral{constructor(){}get memory(){if(_.isUndefined(Memory.minerals)&&(Memory.minerals={}),_.isObject(Memory.minerals))return Memory.minerals[this.id]=Memory.minerals[this.id]||{}}set memory(e){if(_.isUndefined(Memory.minerals)&&(Memory.minerals={}),!_.isObject(Memory.minerals))throw new Error("Could not set memory extension for minerals");Memory.minerals[this.id]=e}get container(){return _.isUndefined(this.memory.container)&&this.room.saveContainers(),_.isUndefined(this._container)&&(this.memory.terminal?(this._container=Game.getObjectById(this.memory.terminal),this._container||delete this.memory.terminal):this.memory.storage?(this._container=Game.getObjectById(this.memory.storage),this._container||delete this.memory.storage):this.memory.container?(this._container=Game.getObjectById(this.memory.container),this._container||delete this.memory.container):this._container=null),this._container}})},function(e,t){Util.define(Structure,class extends Structure{constructor(){}get active(){return this.room.controller?!!this.room.owner&&(!this.owner||this.room.owner===this.owner.username)&&_.get(this.room.memory,["structures",this.id,"active"],!0):_.get(this.room.memory,["structures",this.id,"active"],!0)}get towers(){return(_.isUndefined(this._towers)||this._towersSet!==Game.time)&&(this._towersSet=Game.time,this._towers=[]),this._towers}set towers(e){this._towers=e}})},function(e,t){Util.define(StructureContainer,class extends StructureContainer{constructor(){this.active=!0}cache(e,t,r){return r?(_.isUndefined(this[`_${e}`])||this[`_${e}Set`]!==Game.time)&&(this[`_${e}Set`]=Game.time,this[`_${e}`]=t()):_.isUndefined(this[`_${e}`])&&(this[`_${e}`]=t()),this[`_${e}`]}get sum(){return this.cache("sum",()=>_.sum(this.store),!0)}getNeeds(e){if(!this.room.memory.resources)return 0;let t=this.room.memory.resources.container.find(e=>e.id==this.id);if(t){let r=t.orders.find(t=>t.type==e);if(r){let t=Math.max(r.orderRemaining+(this.store[e]||0),r.storeAmount),o=r.orderAmount+r.storeAmount;o<0&&(o=0);let a=this.store[e]||0;if(a<t)return Math.min(t-a,this.storeCapacity-this.sum);if(a>1.05*o)return o-a}}return 0}})},function(e,t){Util.define(StructureController,class extends StructureController{constructor(){}get memory(){if(_.isUndefined(Memory.controllers)&&(Memory.controllers={}),_.isObject(Memory.controllers))return Memory.controllers[this.id]=Memory.controllers[this.id]||{}}set memory(e){if(_.isUndefined(Memory.controllers)&&(Memory.controllers={}),!_.isObject(Memory.controllers))throw new Error("Could not set memory extension for controller");Memory.controllers[this.id]=e}})},function(e,t){Util.define(StructureLab,class extends StructureLab{constructor(){}get active(){return!!this.room.owner&&this.room.owner===this.owner.username&&!(this.room.RCL<6)&&_.get(this.room.memory,["structures",this.id,"active"],!0)}getNeeds(e){if(!this.room.memory.resources)return 0;let t=0,r=0,o=this.room.memory.resources.reactions,a=this.room.memory.resources.lab.find(e=>e.id===this.id);if(a){let o=a.orders.find(t=>t.type===e);if(o){let a=0;e===RESOURCE_ENERGY?a=this.energy:e===this.mineralType&&(a=this.mineralAmount),t=Math.max(o.orderRemaining+a,o.storeAmount),(r=o.orderAmount+o.storeAmount)<0&&(r=0)}}let i=0,n=0,s=0;if(e===RESOURCE_ENERGY?(i=this.energy,n=this.energyCapacity-this.energy,s=this.energyCapacity):(this.mineralType===e&&(i=this.mineralAmount),n=this.mineralCapacity-this.mineralAmount,s=this.mineralCapacity),a&&o&&o.orders.length>0&&(this.id===o.seed_a||this.id===o.seed_b)&&(e!==LAB_REACTIONS[o.orders[0].type][0]||e!==LAB_REACTIONS[o.orders[0].type][1])&&i>r)return r-i;if(i<Math.min(t,s)/2)return Math.min(t-i,n);if(a&&a.reactionType===this.mineralType){if(i>r+(s-Math.min(r,s))/2)return r-i}else if(i>r)return r-i;return 0}})},function(e,t){Util.define(StructureNuker,class extends StructureNuker{constructor(){}getNeeds(e){if(!this.room.isCriticallyFortifyable)return e==RESOURCE_ENERGY&&this.energy<this.energyCapacity?this.energyCapacity-this.energy:e==RESOURCE_GHODIUM&&this.ghodium<this.ghodiumCapacity?this.ghodiumCapacity-this.ghodium:0;if(!this.room.memory.resources||!this.room.memory.resources.nuker)return 0;let t=0,r=0,o=this.room.memory.resources.nuker.find(e=>e.id==this.id);if(o){let a=o.orders.find(t=>t.type==e);if(a){let o=0;e==RESOURCE_ENERGY?o=this.energy:e==RESOURCE_GHODIUM&&(o=this.ghodium),t=Math.max(a.orderRemaining+o,a.storeAmount),(r=a.orderAmount+a.storeAmount)<0&&(r=0)}}let a=0,i=0;return e==RESOURCE_ENERGY?(a=this.energy,i=this.energyCapacity-this.energy):e==RESOURCE_GHODIUM&&(a=this.ghodium,i=this.ghodiumCapacity-this.ghodium),a<t?Math.min(t-a,i):a>1.05*r?r-a:0}})},function(e,t){Util.define(StructurePowerSpawn,class extends StructurePowerSpawn{constructor(){}getNeeds(e){if(FILL_POWERSPAWN&&!this.room.isCriticallyFortifyable)return e===RESOURCE_ENERGY&&this.energy<.75*this.energyCapacity?this.energyCapacity-this.energy:e===RESOURCE_POWER&&this.power<.25*this.powerCapacity?this.powerCapacity-this.power:0;if(!this.room.memory.resources||!this.room.memory.resources.powerSpawn)return 0;let t=0,r=0,o=this.room.memory.resources.powerSpawn.find(e=>e.id===this.id);if(o){let a=o.orders.find(t=>t.type===e);if(a){let o=0;e===RESOURCE_ENERGY?o=this.energy:e===RESOURCE_POWER&&(o=this.power),t=Math.max(a.orderRemaining+o,a.storeAmount),(r=a.orderAmount+a.storeAmount)<0&&(r=0)}}let a=0,i=0;return e===RESOURCE_ENERGY?(a=this.energy,i=this.energyCapacity-this.energy):e===RESOURCE_POWER&&(a=this.power,i=this.powerCapacity-this.power),a<t?Math.min(t-a,i):a>1.05*r?r-a:0}})},function(e,t){Util.define(StructureRampart,class extends StructureRampart{constructor(){}get active(){return this.room.RCL>1}get isCriticallyFortifyable(){return this.hits<=MIN_FORTIFY_LIMIT[this.room.RCL]}})},function(e,t){Util.define(StructureRoad,class extends StructureRoad{constructor(){this.active=!0}})},function(e,t){Util.define(StructureSpawn,class extends StructureSpawn{constructor(){}run(){if(this.spawning)return;let e=this.room;const t=t=>t.isValidSetup(e)&&this.createCreepBySetup(t),r=Util.get(this.room.memory,"spawnDelay",{});let o=this.createCreepByQueue(e.spawnQueueHigh,"High");return o||0!==e.spawnQueueHigh.length&&e.spawnQueueHigh.length!==r.High||Game.time%SPAWN_INTERVAL!=0||((o=_.some(SpawnManager.priorityHigh,t))||(o=this.createCreepByQueue(e.spawnQueueMedium,"Medium")),o||0!==e.spawnQueueMedium.length&&e.spawnQueueMedium.length!==r.Medium||(o=_.some(SpawnManager.priorityLow,t))||(o=this.createCreepByQueue(e.spawnQueueLow,"Low"))),o}createCreepBySetup(e){LOG_TRACE&&Log.trace("Spawn",{setupType:this.type,rcl:this.room.RCL,energy:this.room.energyAvailable,maxEnergy:this.room.energyCapacityAvailable,Spawn:"createCreepBySetup"},"creating creep");const t=e.buildParams(this);return this.create(t.parts,t.name,t.setup)?t:null}createCreepByQueue(e,t){const r=Util.get(this.room.memory,"spawnDelay",{});if(!e)return null;if(Memory.CPU_CRITICAL&&r[t]===e.length)return null;let o;for(const t in e){const r=e[t];Memory.CPU_CRITICAL&&!CRITICAL_ROLES.includes(r.behaviour)||(o=e.splice(t,1)[0])}if(!o)return e.length&&Log.module(this.pos.roomName,"No non-CRITICAL creeps to spawn, delaying spawn until CPU is not CRITICAL, or new entries are added."),r[t]=e.length,null;delete r[t];let a,i=0;if(o.parts.forEach(e=>{i+=BODYPART_COST[e]}),0===i)return Log.error(`[${this.pos.roomName}]`,"Zero parts body creep queued. Removed."),!1;if(i>this.room.remainingEnergyAvailable)return i>this.room.energyCapacityAvailable||i>300&&!this.room.creeps.length?(Log.error(`[${this.pos.roomName}]`,"Queued creep too big for room: "+JSON.stringify(o)),!1):(e.unshift(o),!0);let n=o.name;for(let e=1;null==a||Game.creeps[a]||Memory.population[a];e++)a=o.name+"-"+e;o.name=a;let s=this.create(o.parts,o.name,o.behaviour||o.setup,o.destiny);return s||(o.name=n,e.unshift(o)),s}create(e,t,r,o){if(0==e.length)return!1;let a=this.spawnCreep(e,t);if(a===OK){let a=0;return e.forEach(function(e){a+=BODYPART_COST[e]}),this.room.reservedSpawnEnergy+=a,PopManager.registerCreep(t,r,a,this.room,this.name,e,o),this.newSpawn={name:t},CreepManager.spawningStarted.trigger({spawn:this.name,name:t,body:e,destiny:o,spawnTime:e.length*CREEP_SPAWN_TIME}),CENSUS_ANNOUNCEMENTS&&Log.room(this.pos.roomName,Dye(COLOR_YELLOW,Util.emoji.baby,"Spawning "+t+"!")),!0}return CENSUS_ANNOUNCEMENTS&&Log.error(`[${this.pos.roomName}]`,"Offspring failed: "+Util.translateErrorCode(a)+"<br/> - body: "+JSON.stringify(_.countBy(e))+"<br/> - name: "+t+"<br/> - behaviour: "+r+"<br/> - destiny: "+o),!1}})},function(e,t){Util.define(StructureStorage,class extends StructureStorage{constructor(){}cache(e,t,r){return r?(_.isUndefined(this[`_${e}`])||this[`_${e}Set`]!==Game.time)&&(this[`_${e}Set`]=Game.time,this[`_${e}`]=t()):_.isUndefined(this[`_${e}`])&&(this[`_${e}`]=t()),this[`_${e}`]}get sum(){return this.cache("sum",()=>_.sum(this.store),!0)}get charge(){const e=this.room.RCL;return Util.chargeScale(this.store.energy,MIN_STORAGE_ENERGY[e],MAX_STORAGE_ENERGY[e])}getNeeds(e){let t=0;if(!this.room.memory.resources)return 0;const r=this.room.memory.resources.storage[0];let o=null;r&&(o=r.orders.find(t=>t.type===e)),o||(o={orderAmount:0,orderRemaining:0,storeAmount:0});const a=this.room.RCL,i=Math.max(o.orderRemaining+(this.store[e]||0),o.storeAmount+(e===RESOURCE_ENERGY?MIN_STORAGE_ENERGY[a]:MAX_STORAGE_MINERAL));let n=e===RESOURCE_ENERGY?this.storeCapacity-this.sum+this.store.energy:o.orderAmount+o.storeAmount+MAX_STORAGE_MINERAL;n<0&&(n=0);let s=this.store[e]||0;return s<i?t=Math.min(i-s,this.storeCapacity-this.sum):s>1.05*n&&(t=n-s),t}})},function(e,t){Util.define(StructureTerminal,class extends StructureTerminal{constructor(){this.active=!0}cache(e,t,r){return r?(_.isUndefined(this[`_${e}`])||this[`_${e}Set`]!==Game.time)&&(this[`_${e}Set`]=Game.time,this[`_${e}`]=t()):_.isUndefined(this[`_${e}`])&&(this[`_${e}`]=t()),this[`_${e}`]}get sum(){return this.cache("sum",()=>_.sum(this.store),!0)}get charge(){const e=this.getNeeds(RESOURCE_ENERGY),t=e?this.store[RESOURCE_ENERGY]+e:TERMINAL_ENERGY;return Util.chargeScale(this.store.energy,t,2*t)}getNeeds(e){let t=0;if(!this.room.memory.resources)return 0;const r=this.room.memory.resources.terminal[0];let o=null;r&&(o=r.orders.find(t=>t.type===e)),o||(o={orderAmount:0,orderRemaining:0,storeAmount:0});const a=Math.max(o.orderRemaining+(this.store[e]||0),o.storeAmount+(e===RESOURCE_ENERGY?TERMINAL_ENERGY:0));let i=o.orderAmount+o.storeAmount+(e===RESOURCE_ENERGY?TERMINAL_ENERGY:0);i<0&&(i=0);let n=this.store[e]||0;return n<a?t=Math.min(a-n,this.storeCapacity-this.sum):n>1.05*i&&(t=i-n),t}})},function(e,t){Util.define(StructureTower,class extends StructureTower{constructor(){}get active(){return!!this.room.owner&&this.room.owner===this.owner.username&&!(this.room.RCL<3)&&_.get(this.room.memory,["structures",this.id,"active"],!0)}})},function(e,t){Util.define(StructureWall,class extends StructureWall{constructor(){}get active(){return this.room.RCL>1}get isCriticallyFortifyable(){return this.hits<=MIN_FORTIFY_LIMIT[this.room.RCL]}})},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(51);class a{constructor(){this.opts={maxOps:TRAVELER_MAX_OPS,defaultStuckValue:TRAVELER_STUCK_TICKS,reportThreshold:TRAVELER_THRESHOLD,roomRange:TRAVELLING_BORDER_RANGE},this.findAllowedRooms=((e,t,r={})=>{if(_.defaults(r,{restrictDistance:10}),Game.map.getRoomLinearDistance(e,t)>r.restrictDistance)return;let o={[e]:!0,[t]:!0},a=Game.map.findRoute(e,t,{routeCallback:o=>{if(r.routeCallback){let e=r.routeCallback(o);if(void 0!==e)return e}if(Game.map.getRoomLinearDistance(e,o)>r.restrictDistance)return!1;let a;if(r.preferHighway){if((a=/^[WE]([0-9]+)[NS]([0-9]+)$/.exec(o))[1]%10==0||a[2]%10==0)return 1}if(!r.allowSK&&!Game.rooms[o]){a||(a=/^[WE]([0-9]+)[NS]([0-9]+)$/.exec(o));let e=a[1]%10,t=a[2]%10;if(!(5===e&&5===t)&&e>=4&&e<=6&&t>=4&&t<=6)return 10}return!r.allowHostile&&this.getHostileRoom(o)&&o!==t&&o!==e?Number.POSITIVE_INFINITY:2.5}});if(!r.debug||_.isArray(a)){for(let e of a)o[e.room]=!0;return o.route=a,o}Log.error(`couldn't findRoute to ${t}`)}),this.findTravelPath=((e,t,r={})=>{_.defaults(r,{ignoreCreeps:!0,range:1,maxOps:this.opts.maxOps,obstacles:[]});const o=e.pos||e,i=t.pos||t;let n;(r.useFindRoute||void 0===r.useFindRoute&&Game.map.getRoomLinearDistance(o.roomName,i.roomName)>2)&&(n=this.findAllowedRooms(o.roomName,i.roomName,r));const s=PathFinder.search(o,{pos:i,range:r.range},{maxOps:r.maxOps,plainCost:r.ignoreRoads?1:2,roomCallback:t=>{if(r.roomCallback){let e=r.roomCallback(t,r.ignoreCreeps);if(void 0!==e)return e}if(n){if(!n[t])return!1}else if(this.getHostileRoom(t)&&!r.allowHostile&&t!==o.roomName&&t!==i.roomName)return!1;let s,l=Game.rooms[t];l?r.ignoreStructures?(s=new PathFinder.CostMatrix,r.ignoreCreeps||a.addCreepsToMatrix(l,s)):s=r.ignoreCreeps||t!==e.pos.roomName?this.getStructureMatrix(l,r):this.getCreepMatrix(l,r):s=this.getStructureMatrix(t,r);for(let e of r.obstacles)s.set(e.pos.x,e.pos.y,255);return s},swampCost:r.ignoreRoads?5:10});if(r.respectRamparts){const e=Game.rooms[o.roomName];if(e&&e.find(FIND_MY_STRUCTURES,{filter:{structureType:STRUCTURE_RAMPART}}).length)for(let e=0;e<s.path.length;e++)if(_.filter(s.path[e].lookFor(LOOK_STRUCTURES),{structureType:STRUCTURE_RAMPART}).length){s.path=s.path.slice(0,e+1);break}}return s.route=n&&n.route,s}),this.travelTo=((e,t,r={})=>{const o=e.pos,i=t.pos||t;this.registerHostileRoom(e.room),e.memory._travel||(e.memory._travel={stuck:0,tick:Game.time,cpu:0,count:0});let n=e.memory._travel;if(e.fatigue>0)return n.tick=Game.time,ERR_BUSY;if(!t)return ERR_INVALID_ARGS;let s=e.pos.getRangeTo(i);if(s<=r.range)return OK;if(s<=1)return 1!==s||r.range?OK:(r.returnData&&(r.returnData.nextPos=t.pos),e.move(e.pos.getDirectionTo(t)));let l=!0;if(n.prev){const t=e=>0===e.x||49===e.x||0===e.y||49===e.y,r=(e,r)=>t(e)&&t(r)&&e.roomName!==r.roomName&&(e.x===r.x||e.y===r.y);n.prev=a.initPosition(n.prev),o.inRangeTo(n.prev,0)||r(e.pos,n.prev)?(l=!1,n.stuck++):(e.room.recordMove(e),n.stuck=0)}if(n.stuck>=this.opts.defaultStuckValue&&!r.ignoreStuck&&(r.ignoreCreeps=!1,delete n.path),n.tick=Game.time,n.dest&&n.dest.x===i.x&&n.dest.y===i.y&&n.dest.roomName===i.roomName||delete n.path,!n.path){if(e.spawning)return ERR_BUSY;n.dest=i,n.prev=void 0;let t=Game.cpu.getUsed(),o=this.findTravelPath(e,i,r);if(n.cpu+=Game.cpu.getUsed()-t,n.count++,n.avg=_.round(n.cpu/n.count,2),n.count>25&&n.avg>r.reportThreshold&&r.debug&&(Log.module("Traveler",Dye(COLOR_ORANGE,`heavy cpu use...${e.room.print}`)),Log.table({creep:e.name,avg:n.cpu/n.count,total:_.round(n.cpu,2),from:e.pos,to:i})),o.incomplete){const t=o.route&&o.route.length;r.debug&&(0===r.range?(Log.module("Traveler",Dye(COLOR_ORANGE,`incomplete path, destination may be blocked...${e.room.print}`)),Log.table({creep:e.name,from:e.pos,to:i})):(Log.module("Traveler",Dye(COLOR_ORANGE,`incomplete path . Route length ${t}...${e.room.print}`)),Log.table({creep:e.name,from:e.pos,to:i,range:r.range}))),t>1&&(o=this.findTravelPath(e,new RoomPosition(25,25,o.route[1].room),_.create(r,{range:this.opts.roomRange,useFindRoute:!1})),r.debug&&Log.module("Traveler",Dye(o.incomplete?COLOR_RED:COLOR_GREEN,`attempting path through next room using known route was ${o.incomplete?"not ":""}successful`))),o.incomplete&&o.ops<2e3&&n.stuck<this.opts.defaultStuckValue&&(r.useFindRoute=!1,o=this.findTravelPath(e,i,r),r.debug&&Log.info(`attempting path without findRoute was ${o.incomplete?"not ":""}successful`))}n.path=a.serializePath(e.pos,o.path),n.stuck=0}if(!n.path||0===n.path.length)return ERR_NO_PATH;n.prev&&0===n.stuck&&(n.path=n.path.substr(1)),n.prev=e.pos;let m=parseInt(n.path[0],10);return r.returnData&&(r.returnData.nextPos=a.positionAtDirection(e.pos,m)),e.move(m)}),this.getStructureMatrix=((e,t)=>{if(t.getStructureMatrix)return t.getStructureMatrix(e);if(this.refreshMatrices(),!this.structureMatrixCache[e.name]){let t=new PathFinder.CostMatrix;this.structureMatrixCache[e.name]=a.addStructuresToMatrix(e,t,1)}return this.structureMatrixCache[e.name]}),this.getCreepMatrix=((e,t)=>t.getCreepMatrix?t.getCreepMatrix(e):(this.refreshMatrices(),this.creepMatrixCache[e.name]||(this.creepMatrixCache[e.name]=a.addCreepsToMatrix(e,this.getStructureMatrix(e,t).clone())),this.creepMatrixCache[e.name])),this.refreshMatrices=(()=>{Game.time!==this.currentTick&&(this.currentTick=Game.time,this.structureMatrixCache={},this.creepMatrixCache={})}),this.opts=_.defaults({maxOps:1e3,defaultStuckValue:3,reportThreshold:50,roomRange:22},this.opts),this.getHostileRoom=(e=>_.get(Memory,["rooms",e,"hostile"])),this.registerHostileRoom=(e=>e.registerIsHostile())}}a.initPosition=(e=>new RoomPosition(e.x,e.y,e.roomName)),a.addStructuresToMatrix=((e,t,r)=>{for(let o of e.find(FIND_STRUCTURES))o instanceof StructureRampart?o.my||o.isPublic||t.set(o.pos.x,o.pos.y,255):o instanceof StructureRoad?t.set(o.pos.x,o.pos.y,r):o.structureType!==STRUCTURE_CONTAINER&&t.set(o.pos.x,o.pos.y,255);for(let r of e.find(FIND_CONSTRUCTION_SITES))r.structureType!==STRUCTURE_CONTAINER&&r.structureType!==STRUCTURE_ROAD&&r.structureType!==STRUCTURE_RAMPART&&t.set(r.pos.x,r.pos.y,255);return t}),a.addCreepsToMatrix=((e,t)=>(e.find(FIND_CREEPS).forEach(e=>t.set(e.pos.x,e.pos.y,255)),t)),a.serializePath=((e,t)=>{let r="",o=e;for(let e of t)e.roomName===o.roomName&&(r+=o.getDirectionTo(e)),o=e;return r}),a.positionAtDirection=((e,t)=>{return new RoomPosition(e.x+[0,0,1,1,1,0,-1,-1,-1][t],e.y+[0,-1,-1,0,1,1,1,0,-1][t],e.roomName)}),t.TravelerInstall=(()=>{_.assign(global,{CompressedMatrix:new o.CompressedMatrix,Traveler:a,traveler:new a,travelerTick:Game.time})})},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});t.CompressedMatrix=class{constructor(){this.state={nSize:0,cSize:0},this.serialize=(e=>{let t=`${e._bits[0]}x`,r=1;for(let o=1;o<e._bits.length;o++){let a=e._bits[o];a!==e._bits[o-1]?(t+=`${r},${a}x`,r=1):r++}return t+=`${r}`}),this.deserialize=(e=>{const t=new PathFinder.CostMatrix;let r,o,a,i=0;return e.split(",").forEach(e=>{r=e.split("x"),o=r[0],a=r[1],o?_.times(a,e=>{t._bits[i]=o,i++}):i+=a}),t}),this.compareEfficiency=((e,t=new PathFinder.CostMatrix,r=!0)=>{let o,a,i,n;for(let s=0;s<e;s++)o=t.serialize(),r&&Log.module("Matrix","normal",o),i=a=JSON.stringify(o),r&&Log.module("Matrix","normal-deserialize",PathFinder.CostMatrix.deserialize(JSON.parse(a)).serialize()),o=this.serialize(t),r&&Log.module("Matrix","comp-serialize",o),n=a=JSON.stringify(o),r&&Log.module("Matrix","comp-deserialize",this.deserialize(JSON.parse(a)).serialize());this.state.nSize=i.length/1024,this.state.cSize=n.length/1024,Log.module("Matrix","normal size:",_.round(this.state.nSize,2),"compressed size:",_.round(this.state.cSize,2),"reduction(% of original size):",_.round(this.state.cSize/this.state.nSize,2))})}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.dateUtils={toLocalDate(e){e||(e=new Date);let t=TIME_ZONE;return USE_SUMMERTIME&&Util.isSummerTime(e)&&t++,new Date(e.getTime()+36e5*t)},toDateTimeString(e){const t=Util.pad;return t(e.getFullYear(),0,4)+"-"+t(e.getMonth()+1)+"-"+t(e.getDate())+" "+Util.toTimeString(e)},toTimeString(e){const t=Util.pad;return t(e.getHours())+":"+t(e.getMinutes())+":"+t(e.getSeconds())},isSummerTime:e=>(Reflect.has(Date.prototype,"stdTimezoneOffset")||Object.defineProperty(Date.prototype,"stdTimezoneOffset",{value(){const e=new Date(this.getFullYear(),0,1),t=new Date(this.getFullYear(),6,1);return Math.max(e.getTimezoneOffset(),t.getTimezoneOffset())}}),Reflect.has(Date.prototype,"dst")||Object.defineProperty(Date.prototype,"dst",{get(){return this.getTimezoneOffset()<this.stdTimezoneOffset()}}),e.dst)}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(13);t.logUtils={translateErrorCode:e=>o.ErrorType[e],css(e){let t="";return _.forEach(e,(e,r)=>{t+=`${_.kebabCase(r)}: ${e};`}),t},jsonToTable(e){let t="";const r=Util.css({background:"rgba(0,0,0,.25)",border:"1px solid rgba(0,0,0,.5)"}),o=Util.css({padding:"2px 5px"});return _.forEach(e,(e,r)=>{const a=Dye(COLOR_GREEN,r)+Dye(COLOR_RED,":");let i="";_.isNumber(e)?(-1!==e.toString().indexOf(".")&&(e=e.toFixed(3)),i=Dye(COLOR_PURPLE,e)):_.isObject(e)||_.isArray(e)?(e=JSON.stringify(e).replace(/(\{|\}|\[|\]|,)/g,(e,t)=>Dye(COLOR_GREY,t)),i=Dye(COLOR_YELLOW,e)):i=Dye(COLOR_YELLOW,e),t+=`<tr><td style="${o}">${a}</td><td style="${o}">${i}</td></tr>`}),`<table style="${r}"><tbody>${t}</tbody></table>`}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.roomUtils={resetRoomLayout(e){Memory.rooms[e].RBL=0,Memory.rooms[e].RDL=0,Log.success(e,"RBL/RDL are reseted.")},setRoomCenter(e,t,r){Memory.rooms[e].center={x:t,y:r},Log.success(e,"center set at",t,r)},getVisibleRooms(e){const t=Game.time-(e||5),r=[];for(const e in Memory.rooms){const o=Memory.rooms[e];o.lastViewed&&o.lastViewed>t&&r.push(e)}return r},getDistance:(e,t)=>Math.sqrt(Math.pow(t.x-e.x,2)+Math.pow(t.y-e.y,2)),routeRange:(e,t)=>e===t?0:Util.get(Memory,`routeRange.${e}.${t}`,()=>{const r=e instanceof Room?e:Game.rooms[e];if(!r)return RoomManager.roomDistance(e,t,!1);const o=r.findRoute(t,!1,!1);return o?o===ERR_NO_PATH?1/0:o.length:RoomManager.roomDistance(e,t,!1)}),pave(e){const t=_.values(Game.flags).filter(t=>t.pos.roomName===e&&t.compareTo(FLAG_COLOR.pavementArt)),r=void 0===Memory.pavementArt[e]?"":Memory.pavementArt[e];Memory.pavementArt[e]=r+t.map(e=>`x${e.pos.x}y${e.pos.y}`).join("")+"x";t.forEach(e=>e.pos.createConstructionSite(STRUCTURE_WALL));t.forEach(e=>e.remove())},unpave(e){if(!Memory.pavementArt||!Memory.pavementArt[e])return!1;const t=Game.rooms[e];if(!t)return!1;const r=t.structures.all.filter(t=>Memory.pavementArt[e].indexOf(`x${t.pos.x}y${t.pos.y}x`)>=0);return r&&r.forEach(e=>e.destroy()),delete Memory.pavementArt[e],!0},getRoomLayout(e,t){const r=[],o=Game.rooms[e.roomName];if(!o)return;const a=e.x,i=e.y;_(o.find(FIND_STRUCTURES)).reject(e=>e instanceof StructureController).filter(e=>e.pos.x>=a&&e.pos.y>=i).filter(e=>!t||t(e)).value().forEach(e=>_.set(r,[e.pos.x-a,e.pos.y-i],e.structureType));const n={null:"",'"extension"':"STRUCTURE_EXTENSION",'"road"':"STRUCTURE_ROAD",'"tower"':"STRUCTURE_TOWER",'"spawn"':"STRUCTURE_SPAWN",'"link"':"STRUCTURE_LINK",'"storage"':"STRUCTURE_STORAGE",'"terminal"':"STRUCTURE_TERMINAL",'"nuker"':"STRUCTURE_NUKER",'"powerSpawn"':"STRUCTURE_POWER_SPAWN",'"observer"':"STRUCTURE_OBSERVER",'"rampart"':"STRUCTURE_RAMPART",'"lab"':"STRUCTURE_LAB"},s=new RegExp(Object.keys(n).join("|"),"g");return JSON.stringify(r).replace(s,e=>n[e])},makeRoomUrl:e=>'<a href="#!/room/'+Game.shard.name+"/"+e+'">'+e+"</a>",makeFlagUrl:e=>'<a href="#!/room/'+Game.shard.name+"/"+Memory.flags[e].roomName+'">'+e+"</a>"}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.marketUtils={countPrices(e,t,r){let o=(e,t,r,o)=>Game.market.getAllOrders(a=>{let i,n;return!(a.type!==e||a.resourceType!==t||a.amount<r)&&(!((i=Game.market.calcTransactionCost(r,a.roomName,o))>Game.rooms[o].terminal.store[RESOURCE_ENERGY])&&(n=r*a.price,a.transactionAmount=Math.min(a.amount,r),a.ratio=(n-i*ENERGY_VALUE_CREDITS)/a.transactionAmount,!0))});switch(Array.prototype.sum=function(){return this.reduce((e,t)=>e+Number(t),0)},Array.prototype.average=function(){return this.sum()/(this.length||1)},e){case ORDER_BUY:const a=o(ORDER_BUY,t,MIN_MINERAL_SELL_AMOUNT,r),i=_.min(a,"ratio"),n=_.filter(a,e=>e.id!==i.id);let s,l=[];for(let e of n)l.push(e.ratio);return s=Util.roundUp(l.average(),4);case ORDER_SELL:const m=o(ORDER_SELL,t,TRADE_THRESHOLD,r),c=_.max(m,"ratio"),u=_.filter(m,e=>e.id!==c.id);let d,h=[];for(let e of u)h.push(e.ratio);return d=Util.roundUp(h.average(),4)}},sumCompoundType:(e,t="amount")=>_(e).flatten().groupBy("type").transform((e,r,o)=>e[o]=_.sum(r,t)).value(),roundUp:(e,t=0)=>(t=Math.pow(10,t),Math.ceil(e*t)/t),roundUpTo:(e,t)=>(e%t!=0&&(e=e+t-e%t),e),orderingRoom(){let e=_.filter(Game.rooms,{my:!0});return _.filter(e,e=>{let t=e.memory.resources;return!_.isUndefined(t)&&!_.isUndefined(t.orders)&&(_.isUndefined(t.boostTiming)&&(t.boostTiming={}),t.orders.length>0&&_.sum(t.orders,"amount")>0)})}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.Emoji={skull:String.fromCodePoint(128128),tick:String.fromCodePoint(9989),cross:String.fromCodePoint(10060),warn:String.fromCodePoint(128549),info:String.fromCodePoint(128309),debug:String.fromCodePoint(128027),home:String.fromCodePoint(127968),reload:String.fromCodePoint(8987),flag:String.fromCodePoint(128681),baby:String.fromCodePoint(128118),order:String.fromCodePoint(128230),terminal:String.fromCodePoint(128176),lab:String.fromCodePoint(128302),walk:String.fromCodePoint(128095),wait:String.fromCodePoint(128684),module:String.fromCodePoint(9898),attack_controller:String.fromCodePoint(128640),avoiding:String.fromCodePoint(128064),boosting:String.fromCodePoint(128293),building:String.fromCodePoint(127959),bulldozing:String.fromCodePoint(128668),charging:String.fromCodePoint(128268),claiming:String.fromCodePoint(9971),defending:String.fromCodePoint(9876),dismantling:String.fromCodePoint(9937),dropping:String.fromCodePoint(128169),feeding:String.fromCodePoint(127829),fortifying:String.fromCodePoint(128679),fueling:String.fromCodePoint(9981),guarding:String.fromCodePoint(128737),harvesting:String.fromCodePoint(9935),healing:String.fromCodePoint(128138),idle:String.fromCodePoint(127925),invading:String.fromCodePoint(128299),mining:String.fromCodePoint(9935),picking:String.fromCodePoint(129508),reallocating:String.fromCodePoint(128302),recycling:String.fromCodePoint(128260),repairing:String.fromCodePoint(128295),reserving:String.fromCodePoint(128681),robbing:String.fromCodePoint(128123),storing:String.fromCodePoint(9196),travelling:String.fromCodePoint(127939),uncharging:String.fromCodePoint(128267),upgrading:String.fromCodePoint(128591),withdrawing:String.fromCodePoint(9195),safegen:String.fromCodePoint(128274)}},function(e,t){e.exports=require("config")},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});class o{constructor(e,t){if(this.next=(()=>{const e=this._stepA,t=this._stepB,r={done:!1,value:{}};switch(this._dir){case TOP_RIGHT:r.value.x=Math.round(this.x-e),r.value.y=Math.round(this.y+t);break;case BOTTOM_RIGHT:r.value.x=Math.round(this.x-t),r.value.y=Math.round(this.y-e);break;case BOTTOM_LEFT:r.value.x=Math.round(this.x+e),r.value.y=Math.round(this.y-t);break;case TOP_LEFT:r.value.x=Math.round(this.x+e),r.value.y=Math.round(this.y+t);break;default:return{done:!0,value:!1}}return this._stepA=e-.5,this._stepB=t+.5,this._stepA<1&&(this._dir=this._dir+2,this._stepA=this._radius-.25,this._stepB=.25),r}),!_.isFinite(t))throw new Error("not finite: "+JSON.stringify([e,t]));this._radius=t,this.x=e.x,this.y=e.y,this._dir=TOP_RIGHT,this._stepA=t-.25,this._stepB=.25}}o.loop=((e,t)=>{const r=e,a=t;if(!_.isFinite(t))throw new Error("not finite: "+JSON.stringify([e,t]));return{[Symbol.iterator]:()=>new o(r,a)}}),o.inside=((e,t,r)=>Math.abs(t.x-e.x)+Math.abs(t.y-e.y)<r),t.default=o},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});class o{constructor(e,t,r){this.next=(()=>{if(o.dirTransform(this,this._dir),--this._step,this._step<=0)switch(this._step=2*this._ring,this._dir){case TOP:this._ring++,this._step++,this._dir=RIGHT;break;case RIGHT:this._dir=BOTTOM;break;case BOTTOM:this._dir=LEFT;break;case LEFT:this._step++,this._dir=TOP;break;default:throw new Error("illegal _dir="+this._dir)}return{done:this._ring>=this._ringLimit,value:{x:this.x,y:this.y}}}),this._dir=TOP,this.x=e.x,void 0===t?(this._ring=0,this._step=2,this.y=e.y+1):(this._ring=t-1,this._step=1,this.y=e.y),void 0===r?this._ringLimit=Math.min(2,this._ring+1):Number.isFinite(r)&&(this._ringLimit=r)}depth(){return this._ring}}o.dirTransform=((e,t)=>{switch(t){case TOP_RIGHT:e.x++;case TOP:e.y--;break;case BOTTOM_RIGHT:e.y++;case RIGHT:e.x++;break;case BOTTOM_LEFT:e.x--;case BOTTOM:e.y++;break;case TOP_LEFT:e.y--;case LEFT:e.x--}return e}),t.default=o},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});t.default=new class{constructor(){this.LAB_REACTIONS={},this.LAB_IDLE="idle",this.LAB_BOOST="boost",this.LAB_SEED="seed",this.LAB_MASTER="master",this.LAB_SLAVE_1="slave_1",this.LAB_SLAVE_2="slave_2",this.LAB_SLAVE_3="slave_3",this.REACTOR_TYPE_FLOWER="flower",this.REACTOR_MODE_IDLE="idle",this.REACTOR_MODE_BURST="burst",this.CREEP_PART_THREAT={move:{common:0,boosted:0},work:{common:1,boosted:3},carry:{common:0,boosted:0},attack:{common:2,boosted:5},ranged_attack:{common:2,boosted:5},heal:{common:4,boosted:10},claim:{common:1,boosted:3},tough:{common:1,boosted:3},tower:25},this.FLAG_COLOR={invade:{color:COLOR_RED,secondaryColor:COLOR_RED,exploit:{color:COLOR_RED,secondaryColor:COLOR_GREEN},robbing:{color:COLOR_RED,secondaryColor:COLOR_YELLOW},attackController:{color:COLOR_RED,secondaryColor:COLOR_CYAN}},labs:{color:COLOR_PURPLE,secondaryColor:COLOR_PURPLE,filter:{color:COLOR_PURPLE,secondaryColor:COLOR_PURPLE},labTech:{color:COLOR_PURPLE,secondaryColor:COLOR_WHITE,filter:{color:COLOR_PURPLE,secondaryColor:COLOR_WHITE}}},construct:{color:COLOR_CYAN,secondaryColor:COLOR_CYAN,spawn:{color:COLOR_CYAN,secondaryColor:COLOR_RED},tower:{color:COLOR_CYAN,secondaryColor:COLOR_PURPLE},link:{color:COLOR_CYAN,secondaryColor:COLOR_BLUE},lab:{color:COLOR_CYAN,secondaryColor:COLOR_GREEN},storage:{color:COLOR_CYAN,secondaryColor:COLOR_YELLOW},terminal:{color:COLOR_CYAN,secondaryColor:COLOR_ORANGE},observer:{color:COLOR_CYAN,secondaryColor:COLOR_BROWN},nuker:{color:COLOR_CYAN,secondaryColor:COLOR_GREY},powerSpawn:{color:COLOR_CYAN,secondaryColor:COLOR_WHITE}},claim:{color:COLOR_GREEN,secondaryColor:COLOR_GREEN,spawn:{color:COLOR_GREEN,secondaryColor:COLOR_WHITE},pioneer:{color:COLOR_GREEN,secondaryColor:COLOR_RED},reserve:{color:COLOR_GREEN,secondaryColor:COLOR_GREY},mining:{color:COLOR_GREEN,secondaryColor:COLOR_BROWN},delivery:{color:COLOR_GREEN,secondaryColor:COLOR_YELLOW}},defense:{color:COLOR_YELLOW,secondaryColor:COLOR_YELLOW},destroy:{color:COLOR_ORANGE,secondaryColor:COLOR_ORANGE,dismantle:{color:COLOR_ORANGE,secondaryColor:COLOR_YELLOW}},pavementArt:{color:COLOR_BROWN,secondaryColor:COLOR_BROWN},command:{color:COLOR_WHITE,drop:{color:COLOR_WHITE,secondaryColor:COLOR_YELLOW},_OCS:{color:COLOR_WHITE,secondaryColor:COLOR_PURPLE},roomLayout:{color:COLOR_WHITE,secondaryColor:COLOR_CYAN},invalidPosition:{color:COLOR_WHITE,secondaryColor:COLOR_RED},skipRoom:{color:COLOR_WHITE,secondaryColor:COLOR_GREEN},idle:{color:COLOR_WHITE,secondaryColor:COLOR_BROWN},safeGen:{color:COLOR_WHITE,secondaryColor:COLOR_BLUE}}},this.DECAY_AMOUNT={rampart:RAMPART_DECAY_AMOUNT,road:ROAD_DECAY_AMOUNT,container:CONTAINER_DECAY},this.DECAYABLES=[STRUCTURE_ROAD,STRUCTURE_CONTAINER,STRUCTURE_RAMPART],this.MEM_SEGMENTS={COSTMATRIX_CACHE:{start:99,end:95}};for(let e in REACTIONS)for(let t in REACTIONS[e])this.LAB_REACTIONS[REACTIONS[e][t]]=[e,t]}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(3);t.default=new class extends o.Component{constructor(){super(),this.fresh=(()=>{Memory.cpu.loop={},Memory.CPU_CHECK||(Memory.CPU_CHECK=CPU_CHECK)}),this.check=((e,...t)=>{if(!Memory.CPU_CHECK)return;const r=[e].concat(t).join("-");_.set(Memory.cpu.loop,r,Game.cpu.getUsed())}),this.end=((e,...t)=>{if(!Memory.CPU_CHECK)return;const r=[e].concat(t).join("-"),o=Memory.cpu.loop[r];o?_.set(Memory.cpu.loop,r,(Game.cpu.getUsed()-o).toFixed(3)):Log.error("not find cpu namespace:",r)}),this.handleData=(()=>{if(!Memory.CPU_CHECK)return;const e=Game.cpu.getUsed().toFixed(3);Memory.cpu.cpu=e,Memory.cpu.cpus?Memory.cpu.cpus.push(e):Memory.cpu.cpus=[e],_.forEach(Memory.cpu.loop,(e,t)=>{Memory.cpu.loops[t]?Memory.cpu.loops[t].push(e):Memory.cpu.loops[t]=[e]})}),this.start=(()=>{Memory.CPU_CHECK=!0,Log.info("CPU Check Start!"),Memory.cpu={loop:{},loops:{},cpu:0,cpus:[]}}),this.stop=(()=>{Memory.CPU_CHECK=!1,Memory.cpu={loop:{},loops:{},cpu:0,cpus:[]},Log.info("CPU Check Stop..")}),this.status=(()=>(Log.info("CPU Check Status:",Memory.CPU_CHECK),Memory.CPU_CHECK)),this.report=(()=>{if(0===Object.keys(Memory.cpu).length)return this.status()||this.start(),void Log.info("CPU wait data...");const e=Memory.cpu.cpus;let t=(_.sum(e)/e.length).toFixed(3),r={};_.forEach(Memory.cpu.loops,(e,t)=>{r[t]=(_.sum(e)/e.length).toFixed(3)}),Log.trace("CPU",r,`usage: ${t} | avg: ${e.length} ticks`)}),this.reportOnce=(()=>{if(0===Object.keys(Memory.cpu.loop).length)return this.status()||this.start(),void Log.info("CPU wait data...");Log.trace("CPU",Memory.cpu.loop,`total-usage: ${Game.cpu.getUsed().toFixed(3)}`),this.stop()}),Memory.cpu||(Memory.cpu={loop:{},loops:{}})}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});t.EventConstructor=class{constructor(){this.handlers=[],this.on=(e=>{null!==e&&this.handlers.push(e)}),this.off=(e=>{this.handlers=this.handlers.filter(t=>t!==e)}),this.trigger=(e=>{try{this.handlers.slice(0).forEach(t=>t(e))}catch(e){Log.error("Error in LiteEvent.trigger: "+(e.stack||e))}})}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o={[COLOR_RED]:"#F92672",[COLOR_PURPLE]:"#AE81FF",[COLOR_BLUE]:"#66D9EF",[COLOR_CYAN]:"#529B2F",[COLOR_GREEN]:"#A6E22E",[COLOR_YELLOW]:"#E6DB74",[COLOR_ORANGE]:"#FD971F",[COLOR_BROWN]:"#75715E",[COLOR_GREY]:"#999999",[COLOR_WHITE]:"#F8F8F0"},a=Object.assign({},o,{link:{color:"#428bca",fontSize:"9px"},black:{color:"black",fontWeight:"bold"},system:{color:o[COLOR_GREY],fontSize:"9px"},success:{color:o[COLOR_GREEN],fontSize:"9px"},error:{color:o[COLOR_RED],fontSize:"9px"},warn:{color:o[COLOR_ORANGE],fontSize:"9px"},info:{color:o[COLOR_BLUE],fontSize:"9px"},debug:{color:o[COLOR_BROWN],fontSize:"9px"},room:{color:o[COLOR_PURPLE],fontSize:"9px"}});t.default=((e,...t)=>{const r=a[e],o=t.join(" ");return _.isObject(r)?`<span style="${Util.css(r)}">${o}</span>`:`<span style="color: ${r}">${o}</span>`})},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(65),a=r(13);t.default=new class{constructor(){this.LogLevel=o.LogLevel[LOG_LEVEL],this.Emoji=LOG_EMOJI}success(...e){const t=this.Emoji?Util.emoji.tick:"[SUCCESS]";console.log(Dye("success",t)+" "+Dye(COLOR_GREEN,...e))}error(...e){if(this.LogLevel<2)return;const t=this.Emoji?Util.emoji.cross:"[ERROR]";console.log(Dye("error",t)+" "+Dye(COLOR_RED,...e))}errorCode(e,t){if(t){const r=a.ErrorType[t];e&&(r?e.say(r):e.say(t));let o=r+"\nroom: "+e.pos.roomName+"\ncreep: "+e.name+"\naction: "+e.data.actionName+"\ntarget: "+e.data.targetId;this.error(o),Game.notify(o,120)}else{let t="unknown error code\nroom: "+e.pos.roomName+"\ncreep: "+e.name+"\naction: "+e.data.actionName+"\ntarget: "+e.data.targetId;this.error(t,this.stack())}}warn(...e){if(this.LogLevel<3)return;const t=this.Emoji?Util.emoji.warn:"[WARN]";console.log(Dye("warn",t)+" "+Dye(COLOR_ORANGE,...e))}info(...e){if(this.LogLevel<4)return;const t=this.Emoji?Util.emoji.info:"[INFO]";console.log(Dye("info",t)+" "+Dye(COLOR_BLUE,...e))}debug(...e){if(this.LogLevel<5)return;const t=this.Emoji?Util.emoji.debug:"[DEBUG]";console.log(Dye("debug",t),...e)}module(e,...t){e=this.Emoji?`${Util.emoji.module} ${Dye("link",e)}`:`[${e}]`,console.log(Dye("system",e),...t)}room(e,...t){e=_.isString(e)?Util.makeRoomUrl(e):e.print;const r=this.Emoji?`${Util.emoji.home} ${e}`:`[${e}]`;console.log(Dye("room",r),...t)}flag(e,...t){e=_.isString(e)?Util.makeFlagUrl(e):e.print;const r=this.Emoji?`${Util.emoji.flag} ${e}`:`[${e}]`;console.log(Dye("room",r),...t)}stringify(e){console.log(JSON.stringify(e,null,2))}table(e){console.log(Util.jsonToTable(e))}stack(e=!1,t=" "){return DEBUG_STACKS||e?new Error(`\nSTACK; param:${DEBUG_STACKS}, force:${e}`).stack:t}trace(e,t,...r){let o,a=r;if(0===r.length&&e){let r=e;do{o=r,r=t[r]}while(t[r]&&r!==e);r&&r!==e&&(a="string"==typeof r?[r]:[o,"=",r])}console.log(Dye(COLOR_ORANGE,`[${e}]`),...a,"<br/>",Util.jsonToTable(t),this.stack())}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),function(e){e[e.alert=1]="alert",e[e.error=2]="error",e[e.warn=3]="warn",e[e.info=4]="info",e[e.debug=5]="debug"}(t.LogLevel||(t.LogLevel={}))},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(3);t.default=new class extends o.Component{constructor(){super(...arguments),this.storedStatisticsTime=Memory.statistics&&Memory.statistics.time?Memory.statistics.time:0,this.run=(()=>{let e;if(_.isUndefined(Memory.statistics)&&(Memory.statistics={reports:[]}),SEND_STATISTIC_REPORTS&&this.storedStatisticsTime>0){if(e="<div><h3><b>Status report </b></h3><h4>at "+Util.toDateTimeString(Util.toLocalDate())+",<br/>comparison to state before: "+this.toTimeSpanString(new Date,new Date(this.storedStatisticsTime))+" ("+(Game.time-Memory.statistics.tick)+" loops)</h4>",Game.cpu.bucket){const t=Game.cpu.bucket-Memory.statistics.bucket;e+="CPU Bucket: "+Game.cpu.bucket+" ("+(t>=0?"+":"")+t+")"}e+="</div>",Memory.statistics.reports.push(e)}let t=t=>{let r="<li>"+t.owner+": "+t.body.replace(/"/g,"");void 0===t.leave?r+=" since "+Util.toTimeString(Util.toLocalDate(new Date(t.time)))+"</li>":r+=" for "+(t.leave-t.enter)+" loops at "+Util.toTimeString(Util.toLocalDate(new Date(t.time)))+"</li>",e.length+r.length>REPORT_MAX_LENGTH?(Memory.statistics.reports.push(e+"</ul></li></ul>"),e='<ul><li style="list-style-type:none"><ul>'+r):e+=r};_.forEach(Game.rooms,r=>{if(r.controller){if(SEND_STATISTIC_REPORTS&&this.storedStatisticsTime>0)if(r.controller.my&&r.memory.statistics){e="<ul><li><b>Room "+r.name+"</b><br/><u>Controller</u><ul>";let o=r.controller.progress<r.memory.statistics.controllerProgress,a=(100*r.controller.progress/r.controller.progressTotal).toFixed(0),i=o?r.memory.statistics.controllerProgressTotal-r.memory.statistics.controllerProgress+r.controller.progress:r.controller.progress-r.memory.statistics.controllerProgress,n=(100*i/r.controller.progressTotal).toFixed(1),s=(i/(Game.time-Memory.statistics.tick)).toFixed(2);if(e+="<li>Level "+r.RCL+", "+a+"% of "+r.controller.progressTotal+"<br/>( +"+i+" | +"+n+"% | +"+s+"/loop )"+(o?" <b><i>Upgraded!</i></b></li></ul>":"</li></ul>"),r.storage&&r.memory.statistics.store){let t=r.memory.statistics.store,o=r.storage.store;e+="<u>Storage</u><ul>";for(let r in t){let a=o[r]?o[r]-t[r]:-1*t[r];e+="<li>"+r+": "+(o[r]||0)+" ("+(a>-1?"+":"")+a+")</li>"}for(let r in o)t[r]||(e+="<li>"+r+": "+o[r]+" (+"+o[r]+")</li>");e+="</ul>"}r.memory.statistics.invaders&&r.memory.statistics.invaders.length>0&&(e+="<u>Invaders</u><ul>",_.forEach(r.memory.statistics.invaders,t),e+="</ul>"),e+="</li></ul>",Memory.statistics.reports.push(e)}else!r.controller.my&&r.controller.reservation&&(e="<ul><li><b>Room "+r.name+"</b><br/><u>Controller</u><ul><li>Reservation: "+r.controller.reservation.ticksToEnd+" for "+r.controller.reservation.username+"</li></ul></li></ul>",Memory.statistics.reports.push(e));let o=e=>void 0===e.leave,a=r.memory.statistics?_.filter(r.memory.statistics.invader,o):[];r.memory.statistics={tick:Game.time,time:Date.now(),store:r.storage?r.storage.store:null,controllerProgress:r.controller.progress,controllerProgressTotal:r.controller.progressTotal,invaders:a}}}),Memory.statistics.tick=Game.time,Memory.statistics.time=Date.now(),Memory.statistics.bucket=Game.cpu.bucket}),this.toTimeSpanString=((e,t)=>{let r=e.getTime()-t.getTime();r<0&&(r*=-1);let o,a=new Date(r),i=Math.floor(r/36e5),n=a.getMinutes(),s=a.getSeconds();return o=i>0?i+"h "+n+"m "+s+"s":n>0?n+"m "+s+"s":s>0?s+"s":"0"})}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(3);t.default=new class extends o.Component{constructor(){super(...arguments),this.typeCount={},this.typeWeight={},this.actionCount={},this.actionWeight={},this.died=[],this.predictedRenewal=[],this.spawned=[],this.spawnsToProbe=[],this.stats={creep:{coreParts:{[MOVE]:!0,[HEAL]:!0},boost:{hits:{[RESOURCE_GHODIUM_OXIDE]:143,[RESOURCE_GHODIUM_ALKALIDE]:200,[RESOURCE_CATALYZED_GHODIUM_ALKALIDE]:334}}}},this.fresh=(()=>{this.typeCount={},this.typeWeight={},this.actionCount={},this.actionWeight={},this.died=[],this.predictedRenewal=[],this.spawned=[],this.spawnsToProbe=[],_.isUndefined(Memory.population)&&(Memory.population={})}),this.analyze=(()=>{let e=e=>{let t=Game.creeps[e.creepName];if(t){if(t.data=e,delete t.action,delete t.target,delete t.flag,t.spawning?e.spawningTime++:t.ticksToLive>0&&!t.data.spawned?(t.data.spawned=!0,this.spawned.push(e.creepName),Game.spawns[e.motherSpawn]&&this.spawnsToProbe.push(e.motherSpawn)):t.ticksToLive<=(e.predictedRenewal?e.predictedRenewal:e.spawningTime)&&!t.data.nearDeath&&(t.data.nearDeath=!0,CENSUS_ANNOUNCEMENTS&&Log.room(e.roomName,Util.emoji.skull,Dye("black",e.creepName,"was near death...")),this.predictedRenewal.push(t.name),!this.spawnsToProbe.includes(e.motherSpawn)&&"unknown"!=e.motherSpawn&&Game.spawns[e.motherSpawn]&&this.spawnsToProbe.push(e.motherSpawn)),e.ttl=t.ticksToLive,e.creepType&&(void 0===t.ticksToLive||CreepManager.isWorkingAge(e))&&this.countCreep(t.room,e),e.flagName){let r=Game.flags[e.flagName];r?(void 0===r.targetOf?r.targetOf=[e]:r.targetOf.push(e),t.flag=r):delete e.flagName}let r=e.actionName&&CreepManager.action[e.actionName]?CreepManager.action[e.actionName]:null,o=r&&e.targetId?Game.getObjectById(e.targetId)||Game.spawns[e.targetId]||Game.flags[e.targetId]:null;o&&o.id===t.id&&(o=FlagManager.specialFlag()),r&&o?this.registerAction(t,r,o,e):(delete e.actionName,delete e.targetId,t.action=null,t.target=null),void 0===e.hull&&_.assign(e,this.getCombatStats(t.body)),t.data=e}else e.ttl>1?Log.room(e.roomName,Util.emoji.skull,Dye(COLOR_RED,e.creepName,"has been killed...")):Log.room(e.roomName,Util.emoji.skull,Dye("black",e.creepName,"was dead...")),this.died.push(e.creepName)};_.forEach(Memory.population,t=>{e(t)});let t=e=>{let t=Game.creeps[e.creepName];if(t&&t.action&&t.target){let r=t.target.id||t.target.name,o=t.action.validateActionTarget(t,t.target);o?(r!=o.id||o.name)&&this.registerAction(t,t.action,o,e):(delete e.actionName,delete e.targetId,t.action=null,t.target=null)}};_.forEach(Memory.population,e=>{t(e)})}),this.run=(()=>{if(this.spawned.forEach(e=>CreepManager.spawningCompleted.trigger(Game.creeps[e])),CreepManager.died.on(e=>{const t=Memory.population[e];t&&t.determinatedSpot&&t.roomName&&RoomManager.costMatrixInvalid.trigger(t.roomName)}),this.died.forEach(e=>CreepManager.died.trigger(e)),this.predictedRenewal.forEach(e=>CreepManager.predictedRenewal.trigger(Game.creeps[e])),Game.time%SPAWN_INTERVAL!=0){let e=e=>Game.spawns[e].run();this.spawnsToProbe.forEach(e)}}),this.cleanup=(()=>{this.died.forEach(e=>this.unregisterCreep(e))}),this.getCreep=(e=>Memory.population[e]),this.setCreep=(e=>(Memory.population[e.creepName]=e,Memory.population[e.creepName])),this.registerCreep=((e,t,r,o,a,i,n=null)=>{let s=this.setCreep({creepName:e,creepType:t,weight:r,roomName:o.name,homeRoom:o.name,motherSpawn:a,actionName:null,targetId:null,spawningTime:0,flagName:null,body:_.countBy(i),destiny:n});this.countCreep(o,s)}),this.unregisterCreep=(e=>{delete Memory.population[e],delete Memory.creeps[e]}),this.registerAction=((e,t,r,o)=>{if(LOG_TRACE&&Log.trace("PopManager",{creepName:this.name,registerAction:t.name,target:r.name||r.id,PopManager:"registerAction"}),e===r)throw new Error("attempt to register self target");void 0===o&&(o=this.getCreep(e.name)),o.carryCapacityLeft=e.carryCapacity-e.sum;let a=e.room;void 0===a.population&&(a.population={typeCount:{},typeWeight:{},actionCount:{},actionWeight:{}}),e.action&&(void 0===a.population.actionCount[e.action.name]?a.population.actionCount[e.action.name]=0:a.population.actionCount[e.action.name]--,void 0===a.population.actionWeight[e.action.name]?a.population.actionWeight[e.action.name]=0:a.population.actionWeight[e.action.name]-=o.weight,void 0===this.actionCount[e.action.name]?this.actionCount[e.action.name]=0:this.actionCount[e.action.name]--,void 0===this.actionWeight[e.action.name]?this.actionWeight[e.action.name]=0:this.actionWeight[e.action.name]-=o.weight,delete e.data.determinatedSpot,delete e.data.determinatedTarget),o.actionName=t.name,void 0===a.population.actionCount[t.name]?a.population.actionCount[t.name]=1:a.population.actionCount[t.name]++,void 0===a.population.actionWeight[t.name]?a.population.actionWeight[t.name]=o.weight:a.population.actionWeight[t.name]+=o.weight,void 0===this.actionCount[t.name]?this.actionCount[t.name]=1:this.actionCount[t.name]++,void 0===this.actionWeight[t.name]?this.actionWeight[t.name]=o.weight:this.actionWeight[t.name]+=o.weight;let i,n=r.id||r.name;if(o.targetId){let t=o.targetId?Game.getObjectById(o.targetId)||Game.spawns[o.targetId]||Game.flags[o.targetId]:null;if(t&&(i=t.id||t.name,t.targetOf)){let r=t=>t.creepName===e.name,o=t.targetOf.findIndex(r);o>-1&&t.targetOf.splice(o,1)}}o.targetId=n,r&&!FlagManager.isSpecialFlag(r)&&(void 0===r.targetOf?r.targetOf=[o]:r.targetOf.push(o)),n!=i&&delete o.path,e.action=t,e.target=r,e.data=o}),this.registerCreepFlag=((e,t)=>{if(!(t&&e.data&&e.data.flagName&&e.data.flagName==t.name&&e.flag.name==t.name)){if(e.data&&e.data.flagName){let t=Game.flags[e.data.flagName];if(t&&t.targetOf){let r=t=>t.creepName===e.name,o=t.targetOf.findIndex(r);o>-1&&t.targetOf.splice(o,1)}}t?(void 0===t.targetOf?t.targetOf=[e.data]:t.targetOf.push(e.data),e.flag=t,e.data.flagName=t.name):(delete e.data.flagName,delete e.flag)}}),this.countCreep=((e,t)=>{t.roomName=e.name,void 0===e.population&&(e.population={typeCount:{},typeWeight:{},actionCount:{},actionWeight:{}}),void 0===e.population.typeCount[t.creepType]?e.population.typeCount[t.creepType]=1:e.population.typeCount[t.creepType]++,void 0===e.population.typeWeight[t.creepType]?e.population.typeWeight[t.creepType]=t.weight:e.population.typeWeight[t.creepType]+=t.weight,void 0===this.typeCount[t.creepType]?this.typeCount[t.creepType]=1:this.typeCount[t.creepType]++,void 0===this.typeWeight[t.creepType]?this.typeWeight[t.creepType]=t.weight:this.typeWeight[t.creepType]+=t.weight}),this.sortEntries=(()=>{let e={};_.map(_.sortBy(Memory.population,e=>e.creepName),t=>e[t.creepName]=t),Memory.population=e}),this.getCombatStats=(e=>{let t=0,r=99,o=100*e.length-99;for(;t<e.length&&!this.stats.creep.coreParts[e[t].type];t++)r+=this.stats.creep.boost.hits[e[t].boost]||100,o-=100;return{hull:r,coreHits:o}}),this.findCircular=(()=>{const e={creeps:Game.creeps,structures:Game.structures,memory:Memory},t={};for(let r in e){const o=e[r];for(let e in o){const a=o[e],i=r+"."+e;t[e]=i,this.checkCircular(e,t,a,i,1)}}}),this.checkCircular=((e,t,r,o,a)=>{if(a>10)Log.error("Checking for circulars, very deep path",{rootPath:o,depth:a});else for(let i in r){const n=o+"."+i,s=r[i];if(!_.isObject(s))continue;const l=s.id||s.name;if(l===e)throw new Error("circular structure:"+l+" at:"+n+" and at:"+t[l]);l&&!t[l]&&(t[l]=n,this.checkCircular(e,t,s,n,a+1))}})}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(3);t.default=new class extends o.Component{constructor(){super(...arguments),this.numSaved=0,this.toActivate={},this.extend=(()=>{this.activateSegment(MEM_SEGMENTS.COSTMATRIX_CACHE,!0),_.defaults(Memory,{cloaked:{},debugTrace:{error:!0,no:{}},pavementArt:{}})}),this.fresh=(()=>{Memory.CPU_CRITICAL=Memory.CPU_CRITICAL?Game.cpu.bucket<CRITICAL_BUCKET_LEVEL+CRITICAL_BUCKET_OVERFILL:Game.cpu.bucket<CRITICAL_BUCKET_LEVEL,this.processSegments()}),this.cleanup=(()=>{_.size(this.toActivate)>0&&RawMemory.setActiveSegments(Object.keys(this.toActivate)),this.toActivate={},this.numSaved=0}),this.activateSegment=((e,t=!1)=>{if(e.start&&e.end){for(let r=e.start;r>=e.end;r--)this.activateSegment(r,t);return}if(e<0||e>99)return Log.error("[MemoryManager]","cannot activate invalid segment ",e);const r=_.size(RawMemory.segments);if(this.numSaved>=10)return Log.error("[MemoryManager]","10 segments saved, cannot activate segment ",e);if(!t){if(r>=10)return Log.error("[MemoryManager]","10 segments loaded, cannot activate segment ",e);if(r+this.numSaved>=10)return Log.error("[MemoryManager] RawMemory","combined loaded and saved exceeds limit(10), cannot activate segment ",e)}this.toActivate[e]=!0}),this.deactivateSegment=(e=>{if(e<0||e>99)return Log.error("[MemoryManager]","cannot deactivate invalid segment ",e);0===_.size(this.toActivate)&&Object.keys(RawMemory.segments).forEach(e=>this.toActivate[e]=!0),delete this.toActivate[e]}),this.cacheValid=(e=>Util.cacheValid[e]===Memory.cacheValid[e]),this.processSegment=((e,t)=>{_.isUndefined(Memory.cacheValid[e])&&(Memory.cacheValid[e]=!1);const r=RawMemory.segments[e];if(!this.cacheValid(e))try{t(r?JSON.parse(r):{}),Util.cacheValid[e]=Memory.cacheValid[e]}catch(t){Log.error("[MemoryManager] Error loading segment",e," caused by ",t.stack||t.toString()),RawMemory.segments[e]="",delete Util.cacheValid[e],delete Memory.cacheValid[e]}}),this.processSegments=(()=>{_.isUndefined(Util.cacheValid)&&(Util.cacheValid={}),_.isUndefined(Memory.cacheValid)&&(Memory.cacheValid={});for(let e=MEM_SEGMENTS.COSTMATRIX_CACHE.start;e>=MEM_SEGMENTS.COSTMATRIX_CACHE.end;e--)this.processSegment(e,RoomManager.loadCostMatrixCache)}),this.saveSegment=((e,t)=>{const r=_.size(RawMemory.segments),o=Object.keys(t);let a,i=0;for(let n=e.start;n>=e.end;n--)if(o&&i<o.length||a&&a.length>1)if(!_.isUndefined(RawMemory.segments[n])||r+this.numSaved<10){let e,r=!1;for(;i<o.length;){const n=o[i];if(i++,e=`"${n}":${JSON.stringify(t[n])}`,r=(_.get(a,"length",0)+_.get(e,"length",0)+2)/1024>100)break;a=a?a+","+e:"{"+e}if(!a&&e&&e.length>0){const t=_.round((e.length+2)/1024,2);return Log.error("[MemoryManager]",`Cannot save data at key ${i}, exceeds 100kb limit ${t}kb`)}Log.module("MemoryManager","Segment: Saving "+_.round(a.length/1024,2)+"kb of data to segment "+n),RawMemory.segments[n]=a+"}",Memory.cacheValid[n]=Game.time,a=r&&e?"{"+e:"{",_.isUndefined(RawMemory.segments[n])&&this.numSaved++}else{if(r>10)return Log.error("[MemoryManager]","cannot save segment "+n+" too many active segments.");if(r+this.numSaved>10)return Log.error("[MemoryManager]","cannot save segment "+n+" loaded + saved exceeds limit(10).");Log.error("[MemoryManager] RawMemory","should not be here.")}else Memory.cacheValid[n]&&(Log.module("MemoryManager","Segment: clearing unused segment "+n),RawMemory.segments[n]="",delete Memory.cacheValid[n])})}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(3),a=r(8);t.default=new class extends o.Component{constructor(){super(...arguments),this.list=[],this.stale=[],this.fresh=(()=>{a.Install(FlagManager,{found:new o.EventConstructor,FlagRemoved:new o.EventConstructor}),_.forEach(Game.flags,e=>delete e.targetOf),this.list=[],this.stale=[],delete this._hasInvasionFlag}),this.register=(e=>{try{e.creeps={},e.cloaking>0&&e.cloaking--,this.list.push({name:e.name,color:e.color,secondaryColor:e.secondaryColor,roomName:e.pos.roomName,x:e.pos.x,y:e.pos.y,cloaking:e.cloaking})}catch(e){Log.error(e.stack||e.message)}}),this.analyze=(()=>(_.forEach(Game.flags,this.register),_.forEach(Memory.flags,(e,t)=>{try{Game.flags[t]||this.stale.push(t)}catch(e){Log.error(e.stack||e.message)}}),!!this.specialFlag(!0))),this.run=(()=>{this.list.forEach(e=>{try{if(!e.cloaking||0===e.cloaking){const t=Game.flags[e.name];FlagManager.found.trigger(t)}}catch(e){Log.error(e.stack||e.message)}}),this.stale.forEach(e=>FlagManager.FlagRemoved.trigger(e))}),this.cleanup=(()=>{this.stale.forEach(e=>delete Memory.flags[e])}),this.flagFilter=(e=>{if(!e)return;let t;return t=e.filter?_.clone(e.filter):{color:e.color,secondaryColor:e.secondaryColor}}),this.findName=((e,t,r=!0,o,a)=>{let i,n=this.list;if(!e||0===n.length)return null;if(t instanceof Room&&(t=t.getPositionAt(25,25)),_.isFunction(e))i=(o=>{if(e(o)&&0===o.cloaking){if(!r)return!0;if(t&&t.roomName&&o.roomName===t.roomName)return!0}return!1});else if(i=this.flagFilter(e),_.assign(i,{cloaking:0}),r&&t&&t.roomName){const e=Game.rooms[t.roomName];e?n=e.flags:_.assign(i,{roomName:t.roomName})}let s=_.filter(n,i);if(0===s.length)return null;if(1===s.length)return s[0].name;if(t&&t.roomName){let e=e=>{let r=0,i=Util.routeRange(t.roomName,e.roomName);return r=0===i?_.max([Math.abs(e.x-t.x),Math.abs(e.y-t.y)]):50*i,o&&(r=o(r,e,a)),e.valid=r<1/0,r},r=_.min(s,e);return r.valid?r.name:null}return s[0].name}),this.find=((e,t,r=!0,o,a)=>{t instanceof Room&&(t=t.getPositionAt(25,25));let i=this.findName(e,t,r,o,a);return null===i?null:Game.flags[i]}),this.removeFromDir=(e=>{let t=this.list.indexOf(t=>t.name===e);t>-1&&(this.list=this.list.splice(t,1))}),this.count=((e,t,r=!0)=>{let o=this.list;if(!e||0===this.list.length)return 0;t instanceof Room&&(t=t.getPositionAt(25,25));let a=this.flagFilter(e);if(r&&t&&t.roomName){const e=Game.flags[t.roomName];e?o=e.flags:_.assign(a,{roomName:t.roomName})}return _.countBy(o,a).true||0}),this.filter=((e,t,r=!0)=>{if(!e||0===this.list.length)return[];let o,a=this.list;if(t instanceof Room&&(t=t.getPositionAt(25,25)),Array.isArray(e))o=(o=>{if(r&&t&&t.roomName&&o.roomName!==t.roomName)return!1;for(let t=0;t<e.length;t++)if(this.compare(e[t],o))return!0;return!1});else if(o=this.flagFilter(e),r&&t&&t.roomName){const e=Game.rooms[t.roomName];e?a=e.flags:_.assign(o,{roomName:t.roomName})}return _.filter(a,o)}),this.rangeMod=((e,t,r)=>{let o,a=r&&r.rangeModPerCrowd?r.rangeModPerCrowd:20,i=r?r.rangeModByType:null,n=Game.flags[t.name];return o=n.targetOf?i?_.countBy(n.targetOf,"creepType")[i]||0:n.targetOf.length:0,e+o*a}),this.exploitMod=((e,t,r)=>{if(e>100)return 1/0;let o=Game.flags[t.name];if(o.room){if(o.room.my)return 1/0;let t=o.targetOf?_.sum(o.targetOf.map(e=>"privateer"!=e.creepType||e.creepName==r?0:e.carryCapacityLeft)):0;return o.room.sourceEnergyAvailable<=t?1/0:e*e/(o.room.sourceEnergyAvailable-t)}return e}),this.hasInvasionFlag=(()=>(_.isUndefined(this._hasInvasionFlag)&&(this._hasInvasionFlag=null!==this.findName(FLAG_COLOR.invade)||null!==this.findName(FLAG_COLOR.destroy)),this._hasInvasionFlag)),this.compare=((e,t)=>e.color===t.color&&e.secondaryColor===t.secondaryColor),this.flagType=(e=>{if(this.isSpecialFlag(e))return"_OCS";for(const t in FLAG_COLOR){const r=FLAG_COLOR[t];if(this.compare(e,r))return t;for(const o in r){const a=r[o];if(this.compare(e,a))return`${t}.${o}`}}return Log.error(`Unknown flag type for flag: ${e?e.name:"undefined flag"}.`),"undefined"}),this.specialFlag=(e=>{const t=Game.flags._OCS;if(e){if(!t)return _(Game.rooms).values().some(e=>(e.getPositionAt(49,49).newFlag({color:COLOR_WHITE,secondaryColor:COLOR_PURPLE},"_OCS"),!0));"W0N0"!==t.pos.roomName&&t.setPosition(new RoomPosition(49,49,"W0N0"))}return t}),this.isSpecialFlag=(e=>"_OCS"===e.name)}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(14);t.default=new class extends o.Component{constructor(){super(...arguments),this.cache={},this.runCache={},this.tasks=[],this.extend=(()=>{this.tasks=[TaskManager.attackController,TaskManager.claim,TaskManager.defense,TaskManager.delivery,TaskManager.guard,TaskManager.labTech,TaskManager.mining,TaskManager.pioneer,TaskManager.reputation,TaskManager.reserve,TaskManager.robbing,TaskManager.safeGen,TaskManager.scheduler]}),this.fresh=(()=>{this.tasks.forEach(e=>{e.fresh&&e.fresh()})}),this.register=(()=>{this.tasks.forEach(e=>{e.register&&e.register(),e.run&&!this.runCache[e.name]&&(this.runCache[e.name]={run:e.run}),e.handleFlagFound&&FlagManager.found.on(t=>e.handleFlagFound(t)),e.handleFlagRemoved&&FlagManager.FlagRemoved.on(t=>e.handleFlagRemoved(t)),e.handleSpawningStarted&&CreepManager.spawningStarted.on(t=>e.handleSpawningStarted(t)),e.handleSpawningCompleted&&CreepManager.spawningCompleted.on(t=>e.handleSpawningCompleted(t)),e.handleCreepDied&&(CreepManager.predictedRenewal.on(t=>e.handleCreepDied(t.name)),CreepManager.died.on(t=>e.handleCreepDied(t))),e.handleCreepError&&CreepManager.error.on(t=>e.handleCreepError(t)),e.handleNewInvader&&RoomManager.newInvader.on(t=>e.handleNewInvader(t)),e.handleKnownInvader&&RoomManager.knownInvader.on(t=>e.handleKnownInvader(t)),e.handleGoneInvader&&RoomManager.goneInvader.on(t=>e.handleGoneInvader(t)),e.handleRoomDied&&RoomManager.collapsed.on(t=>e.handleRoomDied(t))})}),this.run=(()=>{_.forEach(this.runCache,(e,t)=>{try{e.run()}catch(e){Log.error(`Error executing TaskManager "${t}"<br>${e.stack||e.toString()}`)}})}),this.cleanup=((e,t,r)=>{this.removeQueued(this.memory(t,r),e),this.clearMemory(t,r)}),this.memory=((e,t)=>{const r=Util.get(Memory,["tasks",e,t],{});return delete r.queuedValid,delete r.runningValid,delete r.spawningValid,r}),this.removeQueued=((e,t)=>{const r=e=>{if(!_.isUndefined(e))for(const t of e){const e=Game.rooms[t.room];for(const r of["spawnQueueLow","spawnQueueMedium","spawnQueueHigh"]){const o=e[r],a=_.findIndex(o,{name:t.name});if(a>=0){o.splice(a,1);break}}}};if(t)for(const o of t)r(e[o]);else r(e)}),this.clearMemory=((e,t)=>{Memory.tasks[e]&&Memory.tasks[e][t]&&delete Memory.tasks[e][t]}),this.cache=((e,t)=>(this.cache[e]||(this.cache[e]={}),this.cache[e][t]||(this.cache[e][t]={}),this.cache[e][t])),this.clearCache=((e,t)=>{this.cache[e]&&this.cache[e][t]&&delete this.cache[e][t]}),this.spawn=((e,t,r,o)=>{let a=r.explicit?Game.rooms[r.explicit]:RoomManager.findSpawnRoom(r);if(!a)return null;t||(t={}),!t.room&&r.targetRoom&&(t.room=r.targetRoom);let i={parts:CreepManager.compileBody(a,e),name:`${e.name||e.behaviour}-${t.targetName}`,behaviour:e.behaviour,destiny:t,queueRoom:a.name};return 0===i.parts.length?(Log.error("[TaskManager]",`${t.task} task tried to queue a zero parts body ${e.behaviour} creep. Aborted.`),null):((a["spawnQueue"+e.queue]||a.spawnQueueLow).push(i),o&&o(i),i)}),this.addToQueue=((e,t,r)=>{if(t.link&&(t={targetRoom:t}),!t.targetRoom)return;const o={};return o.targetName=r?r.name||r.id:t.targetRoom,this.spawn(e,o,t)}),this.forceSpawn=((e,t,r)=>{if(t.link&&(t={targetRoom:t}),!t.targetRoom)return;const o=t.explicit?Game.rooms[t.explicit]:RoomManager.findSpawnRoom(t);if(!o)return;const a={};a.targetName=r?r.name||r.id:t.targetRoom;const i=CreepManager.compileBody(o,e);if(!i.length)return;const n={parts:i,destiny:a,name:`${e.name||e.behaviour}-${a.targetName}`,behaviour:e.behaviour,queueRoom:o.name};return o.spawnQueueHigh.unshift(n),n}),this.validateQueued=((e,t,r,o={})=>{const a=o.subKey?"queued."+o.subKey:"queued",i=o.subKey?"nextQueuedCheck."+o.subKey:"nextQueuedCheck",n=Util.get(e,a,[]);let s=_.get(e,i,0);if(n.length&&(!o.checkValid||Game.time>s)){const t=o.queues||["Low"],r=[],l=e=>{if(!e)return;const o=Game.rooms[e.room];for(const a of t)if(o["spawnQueue"+a].some(t=>t.name===e.name)){r.push(e);break}};n.forEach(l),_.set(e,a,r),s=Game.time+50,Util.set(e,i,s,!1)}else 0===n.length&&(o.subKey&&e.nextQueuedCheck?delete e.nextQueuedCheck[o.subKey]:delete e.nextQueuedCheck);const l=_.get(t.memory,["nextCheck",r],1/0);t&&s-Game.time>0&&s<l&&(Log.flag(t,Dye(COLOR_PURPLE,"TaskManager Queued:",r,Dye(COLOR_GREY,`next-check: ${s-Game.time}s later`))),_.set(t.memory,["nextCheck",r],s))}),this.validateSpawning=((e,t,r,o={})=>{const a=o.subKey?"spawning."+o.subKey:"spawning",i=o.subKey?"nextSpawnCheck."+o.subKey:"nextSpawnCheck",n=Util.get(e,a,[]);let s=_.get(e,i,0);if(n.length&&(!o.checkValid||Game.time>s)){const t=[];let r;const l=e=>{if(!e)return;const o=Game.spawns[e.spawn];o&&(o.spawning&&o.spawning.name===e.name||o.newSpawn&&o.newSpawn.name===e.name)&&(r=!r||o.spawning.remainingTime<r?o.spawning.remainingTime:r,t.push(e))};n.forEach(l),_.set(e,a,t),r?(s=Game.time+r,Util.set(e,i,s,!1)):o.subKey&&e.nextSpawnCheck?delete e.nextSpawnCheck[o.subKey]:delete e.nextSpawnCheck}const l=_.get(t.memory,["nextCheck",r],1/0);t&&s-Game.time>0&&s<l&&(Log.flag(t,Dye(COLOR_YELLOW,"TaskManager Spawning:",r,Dye(COLOR_GREY,`next-check: ${s-Game.time}s later`))),_.set(t.memory,["nextCheck",r],s))}),this.validateRunning=((e,t,r,o={})=>{const a=o.subKey?"running."+o.subKey:"running",i=o.subKey?"nextRunningCheck."+o.subKey:"nextRunningCheck",n=Util.get(e,a,[]),s=o.roomName;let l=_.get(e,i,0);if(s&&n.length&&(!o.checkValid||Game.time>l)){const t=o.deadCreep||"",r=[];let m;const c=e=>{if(!e)return;const o=e.name||e,a=Game.creeps[o];if(!a||!a.data)return;let i;if(i=a.data.predictedRenewal?a.data.predictedRenewal:a.data.spawningTime?a.data.spawningTime+50*Util.routeRange(a.data.homeRoom,s):50*(Util.routeRange(a.data.homeRoom,s)+1),a.name!==t&&a.ticksToLive>i){const t=a.ticksToLive-i;m=!m||t<m?t:m,r.push(e)}};n.forEach(c),_.set(e,a,r),m?(l=Game.time+Math.min(TASK_CREEP_CHECK_INTERVAL,m),Util.set(e,i,l,!1)):o.subKey&&e.nextRunningCheck?delete e.nextRunningCheck[o.subKey]:delete e.nextRunningCheck}const m=_.get(t.memory,["nextCheck",r],1/0);t&&l-Game.time>0&&l<m&&(Log.flag(t,Dye(COLOR_GREEN,"TaskManager Running:",r,Dye(COLOR_GREY,`next-check: ${l-Game.time}s later`))),_.set(t.memory,["nextCheck",r],l))}),this.validateAll=((e,t,r,o={})=>{if(_.isUndefined(o.roomName))return Log.error("TaskManager.validateAll","roomName undefined"+t+o.subKey);this.validateQueued(e,t,r,o),this.validateSpawning(e,t,r,o),this.validateRunning(e,t,r,o)}),this.forceCreepCheck=((e,t)=>{_.set(e.memory,["nextCheck",t],Game.time)}),this.nextCreepCheck=((e,t)=>{const r=_.get(e.memory,["nextCheck",t]);return!(r&&Game.time<r||(_.set(e.memory,["nextCheck",t],Game.time+TASK_CREEP_CHECK_INTERVAL),0))})}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(4);t.default=new class extends o.TaskComponent{constructor(){super("guard"),this.handleFlagFound=(e=>{e.compareTo(FLAG_COLOR.defense)&&TaskManager.nextCreepCheck(e,this.name)&&(Util.set(e.memory,"task",this.name),this.checkForRequiredCreeps(e))}),this.checkForRequiredCreeps=(e=>{let t=this.memory(e);TaskManager.validateAll(t,e,this.name,{roomName:e.pos.roomName,checkValid:!0}),t.queued.length+t.spawning.length+t.running.length<1&&TaskManager.spawn(this.creep.guard,{task:"guard",targetName:e.name,flagName:e.name},{targetRoom:e.pos.roomName,minEnergyCapacity:200,rangeRclRatio:1.8,allowTargetRoom:!0},t=>{this.memory(Game.flags[t.destiny.targetName]).queued.push({room:t.queueRoom,name:t.name,targetName:e.name})})}),this.handleSpawningStarted=(e=>{if(!e.destiny||!e.destiny.task||"guard"!=e.destiny.task)return;let t=Game.flags[e.destiny.flagName];if(t){let r=this.memory(t);r.spawning.push(e),TaskManager.validateQueued(r,t,this.name)}}),this.handleSpawningCompleted=(e=>{if(!e.data||!e.data.destiny||!e.data.destiny.task||"guard"!=e.data.destiny.task)return;let t=Game.flags[e.data.destiny.flagName];if(t){e.data.predictedRenewal=e.data.spawningTime+50*Util.routeRange(e.data.homeRoom,t.pos.roomName);let r=this.memory(t);r.running.push(e.name),TaskManager.validateSpawning(r,t,this.name)}}),this.handleCreepDied=(e=>{let t=Memory.population[e];if(!t||!t.destiny||!t.destiny.task||"guard"!=t.destiny.task)return;let r=Game.flags[t.destiny.flagName];if(r){const t=this.memory(r);TaskManager.validateRunning(t,r,this.name,{roomName:r.pos.roomName,deadCreep:e})}}),this.memory=(e=>(e.memory.tasks||(e.memory.tasks={}),e.memory.tasks.guard||(e.memory.tasks.guard={queued:[],spawning:[],running:[]}),e.memory.tasks.guard)),this.minControllerLevel=3,this.creep={guard:{fixedBody:[HEAL,RANGED_ATTACK,MOVE],multiBody:{[HEAL]:1,[MOVE]:2,[RANGED_ATTACK]:3},name:"guard",behaviour:"ranger",queue:"Low"}}}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(4);t.default=new class extends o.TaskComponent{constructor(){super("defense"),this.handleNewInvader=(e=>{if(SPAWN_DEFENSE_ON_ATTACK&&!DEFENSE_BLACKLIST.includes(e.pos.roomName)){if(!e.room.my&&!e.room.reserved){let t=e=>FlagManager.compare(e,FLAG_COLOR.invade.exploit)||e.color==(FLAG_COLOR.claim.color||FLAG_COLOR.claim.mining);if(!FlagManager.find(t,e.pos,!0))return}e.room.defenseLevel.sum>e.room.hostileThreatLevel?Log.room(e.room,"TaskManager Defense: room can handle that"):e.room.hostiles.forEach(this.orderDefenses)}}),this.handleGoneInvader=(e=>{if(!Game.getObjectById(e)){let t=this.memory(e);if(t&&t.defender){let r=t=>{let r=Memory.rooms[t.spawnRoom];if(r&&r.spawnQueueHigh){let t=t=>t.destiny&&"defense"===t.destiny.task&&t.destiny.invaderId===e,o=r.spawnQueueHigh.findIndex(t);o>-1&&r.spawnQueueHigh.splice(o,1)}};t.defender.forEach(r)}TaskManager.clearMemory("defense",e)}}),this.handleCreepDied=(e=>{let t=Memory.population[e];if(!(t&&t.destiny&&t.destiny.task&&"defense"==t.destiny.task&&t.destiny.invaderId))return;let r=Game.getObjectById(t.destiny.invaderId);if(!r)return;let o=this.memory(t.destiny.invaderId);if(o.defender){let e=e=>e.order===t.destiny.order,r=o.defender.findIndex(e);r>-1&&o.defender.splice(r,1)}this.orderDefenses(r)}),this.memory=(e=>TaskManager.memory("defense",e)),this.orderDefenses=(e=>{let t=e.id,r=e.threat,o=this.memory(t);if(o.defender){let e=e=>r-=e.threat;o.defender.forEach(e)}else o.defender=[];for(;r>0;){let o=Util.guid();this.creep.defender.queue="High",this.creep.defender.minThreat=1.1*r;let a=TaskManager.spawn(this.creep.defender,{task:"defense",targetName:t,invaderId:t,spottedIn:e.pos.roomName,order:o},{targetRoom:e.pos.roomName,maxRange:4,minEnergyCapacity:800,allowTargetRoom:!0},e=>{this.memory(t).defender.push({spawnRoom:e.queueRoom,order:e.destiny.order}),Log.room(e.queueRoom,Dye(COLOR_ORANGE,`Defender queued for hostile creep ${e.destiny.order} in ${e.destiny.spottedIn}`))});if(!a)return void(LOG_TRACE&&Log.trace("TaskManager",{task:"defense",invaderId:t,targetRoom:e.pos.roomName},"Unable to spawn. Invader will not get handled!"));{let e=CreepManager.bodyThreat(a.parts);r-=e}}}),this.nextAction=(e=>{if(CreepManager.action.defending.isValidAction(e)&&CreepManager.action.defending.isAddableAction(e)&&CreepManager.action.defending.assign(e))return;let t=Game.getObjectById(e.data.destiny.invaderId);if(t&&e.pos.roomName===t.pos.roomName)return void CreepManager.action.travelling.assign(e,t);let r=Game.rooms[e.data.destiny.spottedIn];if(!r||r.hostiles.length>0)return CreepManager.action.travelling.assignRoom(e,e.data.destiny.spottedIn);let o=e.room.adjacentRooms.find(e=>Game.rooms[e]&&Game.rooms[e].hostiles.length>0);if(o)return CreepManager.action.travelling.assignRoom(e,o);let a=Game.spawns[e.data.motherSpawn];a&&CreepManager.action.recycling.assign(e,a)}),this.creep={defender:{fixedBody:[RANGED_ATTACK,MOVE],multiBody:{[HEAL]:1,[MOVE]:2,[RANGED_ATTACK]:2,[TOUGH]:1},name:"defender",behaviour:"ranger"}}}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(4);t.default=new class extends o.TaskComponent{constructor(){super("mining"),this.default={name:`default-${this.name}`},this.reserve={name:`reserve-${this.name}`,spawnParams:e=>{const t=this._carryPopulation(e.pos.roomName);return t<REMOTE_RESERVE_HAUL_CAPACITY?(LOG_TRACE&&Log.trace("TaskManager",{flagName:e.name,pos:e.pos,population:t,spawnParams:"population",[this.name]:"spawnParams",TaskManager:this.name}),{count:0,priority:"Low"}):TaskManager.reserve.state.default.spawnParams(e)}},this.miner={name:`miner-${this.name}`,setup:e=>this.setupCreep(e,this.creep.miner),shouldSpawn:(e,t)=>e<t},this.hauler={name:`hauler-${this.name}`,ept:e=>{const t=Game.rooms[e];return t?10*t.sources.length:20},homeRoomName:e=>{const t=this.memory(e);return t.storageRoom?t.storageRoom:RoomManager.bestSpawnRoomFor(e).name},spawnRoom:(e,t)=>RoomManager.findSpawnRoom({targetRoom:e,minEnergyCapacity:t||500}),maxWeight:(e,t,r,o,a)=>{t||(t=this.state.hauler.homeRoomName(e)),r||(r=this.memory(e));const i=o?[]:_.map(r.running.remoteHauler,e=>Game.creeps[e]),n=a?[]:_.union(r.queued.remoteHauler,r.spawning.remoteHauler),s=(Game.rooms[e],Util.routeRange(e,t)),l=this.state.hauler.ept(e),m=_.filter(i,e=>!this.needsReplacement(e)),c=_.sum(m,e=>e&&e.data&&e.data.body?e.data.body.carry:5),u=_.sum(n,e=>e&&e.body?e.body.carry:5),d=l*s*2+(r.carryParts||0)-c-u,h=this._haulerCarryToWeight(d);return LOG_TRACE&&Log.trace("TaskManager",{TaskManager:this.name,room:e,homeRoom:t,haulers:i.length+n.length,ept:l,travel:s,existingCarry:c,queuedCarry:u,neededCarry:d,maxWeight:h,[this.name]:"maxWeight"}),h}},this.handleFlagRemoved=(e=>{const t=Memory.flags[e];if(t&&t.task===this.name&&t.roomName){const e=FlagManager.filter(FLAG_COLOR.claim.mining,new RoomPosition(25,25,t.roomName),!0);if(e&&e.length>0)return}TaskManager.cleanup(["remoteMiner","remoteWorker","remoteHauler"],this.name,t.roomName)}),this.handleFlagFound=(e=>{e.compareTo(FLAG_COLOR.claim.mining)&&TaskManager.nextCreepCheck(e,this.name)&&(Util.set(e.memory,"roomName",e.pos.roomName),Util.set(e.memory,"task",this.name),this.checkForRequiredCreeps(e))}),this.handleSpawningStarted=(e=>{if(!e.destiny||!e.destiny.task||e.destiny.task!=this.name)return;const t=this.memory(e.destiny.room),r=Game.flags[e.destiny.targetName];if(r){const o=_.find(this.creep,{behaviour:e.destiny.type}).queue;TaskManager.validateQueued(t,r,this.name,{subKey:e.destiny.type,queues:[o]}),e.body&&(e.body=_.countBy(e.body)),t.spawning[e.destiny.type].push(e)}}),this.handleSpawningCompleted=(e=>{if(!e.data.destiny||!e.data.destiny.task||e.data.destiny.task!=this.name)return;e.data.destiny.homeRoom&&(e.data.homeRoom=e.data.destiny.homeRoom);const t=Game.flags[e.data.destiny.targetName];if(t){e.data.predictedRenewal=e.data.spawningTime+50*Util.routeRange(e.data.homeRoom,e.data.destiny.room);const r=this.memory(e.data.destiny.room);r.running[e.data.destiny.type].push(e.name),TaskManager.validateSpawning(r,t,this.name,{roomName:e.data.destiny.room,subKey:e.data.destiny.type})}}),this.handleCreepDied=(e=>{const t=Memory.population[e];if(!t||!t.destiny||!t.destiny.task||t.destiny.task!=this.name)return;const r=Game.flags[t.destiny.targetName];if(r){const o=this.memory(t.destiny.room);TaskManager.validateRunning(o,r,this.name,{subKey:t.creepType,roomName:t.destiny.room,deadCreep:e})}}),this.needsReplacement=(e=>!e||(e.ticksToLive||CREEP_LIFE_TIME)<(e.data.predictedRenewal||0)),this.checkForRequiredCreeps=(e=>{const t=e.pos.roomName,r=Game.rooms[t],o=this.memory(t);let a;a=r?r.sources.length:Memory.rooms[t]&&Memory.rooms[t].sources?Memory.rooms[t].sources.length:1;const i=r=>{const a=_.find(this.creep,{behaviour:r}).queue;return TaskManager.validateAll(o,e,this.name,{roomName:t,subKey:r,queues:[a],checkValid:!0,task:this.name}),o.queued[r].length+o.spawning[r].length+o.running[r].length},n=i("remoteHauler"),s=i("remoteMiner"),l=i("remoteWorker");if(LOG_TRACE&&Log.trace("TaskManager",{TaskManager:this.name,flagName:e.name,sourceCount:a,haulerCount:n,minerCount:s,workerCount:l,[this.name]:"FlagManager.found"},"checking flag@",e.pos),this.state.miner.shouldSpawn(s,a)){LOG_TRACE&&Log.trace("TaskManager",{TaskManager:this.name,room:t,minerCount:s,minerTTLs:_.map(_.map(o.running.remoteMiner,e=>Game.creeps[e]),"ticksToLive"),[this.name]:"minerCount"});const r=this.state.miner.setup(t);for(let o=s;o<a;o++)TaskManager.spawn(r,{task:this.name,targetName:e.name,type:r.behaviour},{targetRoom:t,minEnergyCapacity:r.minEnergyCapacity,rangeRclRatio:1},e=>{this.memory(e.destiny.room).queued[e.behaviour].push({room:e.queueRoom,name:e.name})})}const m=Math.ceil(o.running.remoteMiner.length*REMOTE_HAULER.MULTIPLIER);if(n<m&&(!o.capacityLastChecked||Game.time-o.capacityLastChecked>TASK_CREEP_CHECK_INTERVAL))for(let r=n;r<m;r++){let a=r>=1&&REMOTE_HAULER.MIN_WEIGHT;const i=this.state.hauler.spawnRoom(t,a);if(!i)break;const n=REMOTE_HAULER.REHOME?this.state.hauler.homeRoomName(t):i.name;let s=this.state.hauler.maxWeight(t,n,o);if(!s||!REMOTE_HAULER.ALLOW_OVER_CAPACITY&&s<a){o.capacityLastChecked=Game.time;break}_.isNumber(REMOTE_HAULER.ALLOW_OVER_CAPACITY)?(s=Math.max(s,REMOTE_HAULER.ALLOW_OVER_CAPACITY),a=a&&Math.min(REMOTE_HAULER.MIN_WEIGHT,s)):REMOTE_HAULER.ALLOW_OVER_CAPACITY&&(s=Math.max(s,REMOTE_HAULER.MIN_WEIGHT),a=a&&Math.min(REMOTE_HAULER.MIN_WEIGHT,s));const l=_.create(this.creep.hauler);l.maxWeight=s,a&&(l.minWeight=a),TaskManager.spawn(l,{task:this.name,targetName:e.name,type:this.creep.hauler.behaviour,homeRoom:n},{targetRoom:t,explicit:i.name},e=>{this.memory(e.destiny.room).queued[e.behaviour].push({room:e.queueRoom,name:e.name,body:_.countBy(e.parts)})})}if(r&&r.myConstructionSites.length>0&&l<REMOTE_WORKER_MULTIPLIER)for(let r=l;r<REMOTE_WORKER_MULTIPLIER;r++)TaskManager.spawn(this.creep.worker,{task:this.name,targetName:e.name,type:this.creep.worker.behaviour},{targetRoom:t,minEnergyCapacity:600},e=>{this.memory(e.destiny.room).queued[e.behaviour].push({room:e.queueRoom,name:e.name})})}),this.findSpawning=((e,t)=>{const r=[];return _.forEach(Game.spawns,o=>{if(o.spawning&&(_.includes(o.spawning.name,t)||o.newSpawn&&_.includes(o.newSpawn.name,t))){const t=PopManager.getCreep(o.spawning.name);if(t&&t.destiny.room===e){const e={spawn:o.name,name:o.spawning.name,destiny:t.destiny};r.push(e)}}}),r}),this.findRunning=((e,t)=>{const r=[];return _.forEach(Game.creeps,o=>{!o.spawning&&o.data.creepType===t&&o.data&&o.data.destiny&&o.data.destiny.room===e&&r.push(o.name)}),r}),this.memory=(e=>{const t=TaskManager.memory(this.name,e);return t.hasOwnProperty("queued")||(t.queued={remoteMiner:[],remoteHauler:[],remoteWorker:[]}),t.hasOwnProperty("spawning")||(t.spawning={remoteMiner:this.findSpawning(e,"remoteMiner"),remoteHauler:this.findSpawning(e,"remoteHauler"),remoteWorker:this.findSpawning(e,"remoteWorker")}),t.hasOwnProperty("running")||(t.running={remoteMiner:this.findRunning(e,"remoteMiner"),remoteHauler:this.findRunning(e,"remoteHauler"),remoteWorker:this.findRunning(e,"remoteWorker")}),t.hasOwnProperty("nextSpawnCheck")||(t.nextSpawnCheck={}),t.queued.miner&&(t.queued.remoteMiner=t.queued.miner,delete t.queued.miner),t.queued.hauler&&(t.queued.remoteHauler=t.queued.hauler,delete t.queued.hauler),t.queued.worker&&(t.queued.remoteWorker=t.queued.worker,delete t.queued.worker),t}),this.setupCreep=((e,t)=>{switch(t.behaviour){default:return t;case"remoteMiner":const r=this.memory(e);if(!r.harvestSize)return t;const o=e=>e===WORK,a=_.reject(t.fixedBody,o),i=_.sum(t.fixedBody,o)+r.harvestSize;return _.create(t,{fixedBody:_.times(i,_.constant(WORK)).concat(_.times(Math.ceil(.5*r.harvestSize),_.constant(MOVE))).concat(a),moveBalance:r.harvestSize%2*-.5})}}),this._carryPopulation=((e,t)=>1-this.state.hauler.maxWeight(e,t,void 0,!1,!0)/this.state.hauler.maxWeight(e,t,void 0,!0,!0)),this._haulerCarryToWeight=(e=>{if(!e||e<0)return 0;const t=_.max([0,e-5]);return 500+150*_.ceil(.5*t)}),this.getFlag=(e=>FlagManager.find(FLAG_COLOR.claim.mining,new RoomPosition(25,25,e))),this.carry=((e,t)=>{const r=this.memory(e);r.carryParts=(r.carryParts||0)+(t||0);const o=Math.round(100*this._carryPopulation(e));return t&&(TaskManager.forceCreepCheck(this.getFlag(e),this.name),delete r.capacityLastChecked),`TaskManager.${this.name}: hauler carry capacity for ${e} ${r.carryParts>=0?"increased":"decreased"} by ${Math.abs(r.carryParts)}. Currently at ${o}% of desired capacity`}),this.harvest=((e,t)=>{const r=this.memory(e);return r.harvestSize=(r.harvestSize||0)+(t||0),`TaskManager.${this.name}: harvesting work capacity for ${e} ${r.harvestSize>=0?"increased":"decreased"} by ${Math.abs(r.harvestSize)} per miner.`}),this.storage=((e,t)=>{Game.rooms[e];const r=this.memory(e);if(t){const o=r.storageRoom;return r.storageRoom=t,`TaskManager.${this.name}: room ${e}, now sending haulers to ${t}, (was ${o})`}if(r.storageRoom){if(!1===t){const t=r.storageRoom;return delete r.storageRoom,`TaskManager.${this.name}: room ${e}, cleared custom storage room (was ${t})`}return`TaskManager.${this.name}: room ${e}, sending haulers to ${r.storageRoom}`}return`TaskManager.${this.name}: room ${e}, no custom storage destination`}),this.state={default:this.default,reserve:this.reserve,miner:this.miner,hauler:this.hauler},this.minControllerLevel=2,this.creep={miner:{fixedBody:{[MOVE]:1,[WORK]:5},multiBody:[MOVE,MOVE,WORK,CARRY],maxMulti:1,minEnergyCapacity:550,behaviour:"remoteMiner",queue:"Medium"},hauler:{fixedBody:{[CARRY]:5,[MOVE]:3,[WORK]:1},multiBody:[CARRY,CARRY,MOVE],behaviour:"remoteHauler",queue:"Low"},worker:{fixedBody:{[CARRY]:3,[MOVE]:4,[WORK]:4},multiBody:{[CARRY]:1,[MOVE]:2,[WORK]:2},maxMulti:3,behaviour:"remoteWorker",queue:"Low"}}}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(4);t.default=new class extends o.TaskComponent{constructor(){super("claim"),this.handleFlagFound=(e=>{e.compareTo(FLAG_COLOR.claim)&&TaskManager.nextCreepCheck(e,this.name)&&(Util.set(e.memory,"task",this.name),this.checkForRequiredCreeps(e))}),this.checkForRequiredCreeps=(e=>{let t=this.memory(e);TaskManager.validateAll(t,e,this.name,{roomName:e.pos.roomName,checkValid:!0}),t.queued.length+t.spawning.length+t.running.length<1&&TaskManager.spawn(this.creep.claimer,{task:"claim",targetName:e.name,flagName:e.name},{targetRoom:e.pos.roomName,minEnergyCapacity:650},t=>{this.memory(Game.flags[t.destiny.targetName]).queued.push({room:t.queueRoom,name:t.name,targetName:e.name})})}),this.handleSpawningStarted=(e=>{if(!e.destiny||!e.destiny.task||"claim"!=e.destiny.task)return;let t=Game.flags[e.destiny.flagName];if(t){let r=this.memory(t);r.spawning.push(e),TaskManager.validateQueued(r,t,this.name)}}),this.handleSpawningCompleted=(e=>{if(!e.data||!e.data.destiny||!e.data.destiny.task||"claim"!=e.data.destiny.task)return;let t=Game.flags[e.data.destiny.flagName];if(t){e.data.predictedRenewal=e.data.spawningTime+50*Util.routeRange(e.data.homeRoom,t.pos.roomName);let r=this.memory(t);r.running.push(e.name),TaskManager.validateSpawning(r,t,this.name)}}),this.handleCreepDied=(e=>{let t=Memory.population[e];if(!t||!t.destiny||!t.destiny.task||"claim"!=t.destiny.task)return;let r=Game.flags[t.destiny.flagName];if(r){const t=this.memory(r);TaskManager.validateRunning(t,r,this.name,{roomName:r.pos.roomName,deadCreep:e})}}),this.memory=(e=>(e.memory.tasks||(e.memory.tasks={}),e.memory.tasks.claim||(e.memory.tasks.claim={queued:[],spawning:[],running:[]}),e.memory.tasks.claim)),this.nextAction=(e=>{let t=[CreepManager.action.claiming,CreepManager.action.recycling];for(let r=0;r<t.length;r++){let o=t[r];if(o.isValidAction(e)&&o.isAddableAction(e)&&o.assign(e))return}}),this.minControllerLevel=3,this.creep={claimer:{fixedBody:[CLAIM,MOVE],multiBody:[],name:"claimer",behaviour:"claimer",queue:"Low"}}}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(4);t.default=new class extends o.TaskComponent{constructor(){super("reserve"),this.VALID_RESERVATION=1e3,this.URGENT_RESERVATION=250,this.default={name:`default-${this.name}`,spawnParams:e=>{const t={count:0,queue:"Low"},r=!!e,o=r&&(RoomManager.isControllerRoom(e.pos.roomName)||e.room&&e.room.controller);if(!r||!o)return LOG_TRACE&&Log.trace("TaskManager",{hasFlag:r,hasController:o,checkForRequiredCreeps:"skipping room, missing flag or controller",[this.name]:"checkForRequiredCreeps",TaskManager:this.name}),t;if(e.room){e.memory.lastVisible=Game.time,e.memory.ticksToEnd=e.room.controller.reservation&&e.room.controller.reservation.ticksToEnd;const r=e.room.controller.reservation&&(e.room.controller.reservation.ticksToEnd>1e3||e.room.controller.reservation.username!==ME),o=!!e.room.controller.owner;if(o||r)return LOG_TRACE&&Log.trace("TaskManager",{validReservation:r,isOwned:o,checkForRequiredCreeps:"skipping room, reserved or owned",[this.name]:"checkForRequiredCreeps",TaskManager:this.name}),t;const a=!e.room.controller.reservation||e.room.controller.reservation.ticksToEnd<250;if(t.count=1,a&&(t.queue="Medium"),LOG_TRACE){const e=a?"urgent":" ";Log.trace("TaskManager",{validReservation:r,isOwned:o,urgent:a,checkForRequiredCreeps:`sending${e}reserver`,[this.name]:"checkForRequiredCreeps",TaskManager:this.name})}}else(_.isUndefined(e.memory.lastVisible)||Game.time-e.memory.lastVisible>(e.memory.ticksToEnd-250||250))&&(t.count=1,t.queue="Medium",LOG_TRACE&&Log.trace("TaskManager",{lastVisible:e.memory.lastVisible,tickToEnd:e.memory.ticksToEnd,checkForRequiredCreeps:"sending urgent reserver, no visibility",[this.name]:"checkForRequiredCreeps",TaskManager:this.name}));return t}},this.handleFlagFound=(e=>{if((e.compareTo(FLAG_COLOR.claim.reserve)||e.compareTo(FLAG_COLOR.invade.exploit)||e.compareTo(FLAG_COLOR.claim.mining))&&(RoomManager.isControllerRoom(e.pos.roomName)||e.room&&e.room.controller)){const t=this.memory(e);if(e.room){e.memory.lastVisible=Game.time,e.memory.ticksToEnd=e.room.controller.reservation&&e.room.controller.reservation.ticksToEnd;const r=_.get(e.memory,["nextCheck",this.name],1/0),o=Game.time+e.memory.ticksToEnd-this.VALID_RESERVATION;o<r&&!t.waitForCreeps&&(0===t.queued.length+t.spawning.length+t.running.length?_.set(e.memory,["nextCheck",this.name],o):t.waitForCreeps=!0)}TaskManager.nextCreepCheck(e,this.name)&&(delete t.waitForCreeps,Util.set(e.memory,"task",this.name),this.checkForRequiredCreeps(e))}}),this.handleFlagFound=(e=>{if((e.compareTo(FLAG_COLOR.claim.reserve)||e.compareTo(FLAG_COLOR.invade.exploit)||e.compareTo(FLAG_COLOR.claim.mining))&&(RoomManager.isControllerRoom(e.pos.roomName)||e.room&&e.room.controller)){const t=this.memory(e);if(e.room){e.memory.lastVisible=Game.time,e.memory.ticksToEnd=e.room.controller.reservation&&e.room.controller.reservation.ticksToEnd;const r=_.get(e.memory,["nextCheck",this.name],1/0),o=Game.time+e.memory.ticksToEnd-this.VALID_RESERVATION;o<r&&!t.waitForCreeps&&(0===t.queued.length+t.spawning.length+t.running.length?_.set(e.memory,["nextCheck",this.name],o):t.waitForCreeps=!0)}TaskManager.nextCreepCheck(e,this.name)&&(delete t.waitForCreeps,Util.set(e.memory,"task",this.name),this.checkForRequiredCreeps(e))}}),this.checkForRequiredCreeps=(e=>{let t;e.compareTo(FLAG_COLOR.claim.mining)?t=TaskManager.mining.state.reserve.spawnParams(e):e.compareTo(FLAG_COLOR.invade.exploit)?(t=this.state.default.spawnParams(e)).queue="Low":t=this.state.default.spawnParams(e);let r=this.memory(e);if(TaskManager.validateAll(r,e,this.name,{roomName:e.pos.roomName,queues:["Low","Medium"],checkValid:!0}),"Low"!==t.queue&&1==r.queued.length){let e=Game.rooms[r.queued[0].room],t=(t,o)=>{if(t.targetName==r.queued[0].targetName){let t=e.spawnQueueLow.splice(o,1);return e.spawnQueueMedium.push(t),!0}return!1};e.spawnQueueLow.find(t)}r.queued.length+r.spawning.length+r.running.length<t.count&&(this.creep.reserver.queue=t.queue,TaskManager.spawn(this.creep.reserver,{task:this.name,targetName:e.name},{targetRoom:e.pos.roomName,minEnergyCapacity:1300,maxRange:this.spawnRoomMaxRange},t=>{this.memory(Game.flags[t.destiny.targetName]).queued.push({room:t.queueRoom,name:t.name,targetName:e.name})}))}),this.handleSpawningStarted=(e=>{if(!e.destiny||!e.destiny.task||e.destiny.task!=this.name)return;let t=Game.flags[e.destiny.targetName];if(t){let r=this.memory(t);TaskManager.validateQueued(r,t,this.name,{queues:["Low","Medium"]}),r.spawning.push(e)}}),this.handleSpawningCompleted=(e=>{if(!e.data||!e.data.destiny||!e.data.destiny.task||e.data.destiny.task!=this.name)return;let t=Game.flags[e.data.destiny.targetName];if(t){e.data.predictedRenewal=e.data.spawningTime+50*Util.routeRange(e.data.homeRoom,t.pos.roomName);let r=this.memory(t);TaskManager.validateSpawning(r,t,this.name),r.running.push(e.name)}}),this.handleCreepDied=(e=>{let t=Memory.population[e];if(!t||!t.destiny||!t.destiny.task||t.destiny.task!=this.name)return;let r=Game.flags[t.destiny.targetName];if(r){const t=this.memory(r);TaskManager.validateRunning(t,r,this.name,{roomName:r.pos.roomName,deadCreep:e})}}),this.nextAction=(e=>{if(e.data.destiny&&e.data.destiny.room!==e.room.name)return CreepManager.action.travelling.assignRoom(e,e.data.destiny.room);let t=[CreepManager.action.reserving,CreepManager.action.recycling];for(let r=0;r<t.length;r++){let o=t[r];if(o.isValidAction(e)&&o.isAddableAction(e)&&o.assign(e))break}LOG_TRACE&&Log.trace("TaskManager",{creepName:e.name,nextAction:e.action.name,[this.name]:"nextAction",TaskManager:this.name})}),this.memory=(e=>{const t=Util.get(e.memory,["tasks","reserve"],{queued:[],spawning:[],running:[]});return delete t.valid,t}),this.state={default:this.default},this.spawnRoomMaxRange=6,this.creep={reserver:{fixedBody:{[CLAIM]:2,[MOVE]:2},multiBody:[CLAIM,MOVE],maxMulti:7,name:"reserver",behaviour:"claimer"}}}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(4);t.default=new class extends o.TaskComponent{constructor(){super("pioneer"),this.handleRoomDied=(e=>{if(e.population&&e.population.typeCount.collapseWorker)return;let t=!0;if(e.energyAvailable>199){e.spawnQueueHigh.splice(0,e.spawnQueueHigh.length);const r=this.creep.worker;t=!TaskManager.spawn(r,{task:"collapseWorker",targetName:e.name,type:r.behaviour},{explicit:e.name})}t&&(FlagManager.find(FLAG_COLOR.claim.pioneer,e)||e.newFlag(FLAG_COLOR.claim.pioneer))}),this.handleFlagFound=(e=>{e.compareTo(FLAG_COLOR.claim.pioneer)&&TaskManager.nextCreepCheck(e,this.name)&&(Util.set(e.memory,"task",this.name),this.checkForRequiredCreeps(e))}),this.checkForRequiredCreeps=(e=>{if(!e||e.room&&!e.room.my&&!e.room.reserved){if(!PIONEER_UNOWNED)return Log.error("Pioneer room not owned:",e.room,Log.stack());const t=e.room.owner||e.room.reservation;if(t&&!TaskManager.reputation.isAlly(t))return Log.error(`Pioneer target room ${e.room} owned by ${t}`)}let t=this.memory(e);if(TaskManager.validateAll(t,e,this.name,{roomName:e.pos.roomName,subKey:"pioneer",checkValid:!0}),t.queued.length+t.spawning.length+t.running.length<1){const t=this.creep.pioneer;TaskManager.spawn(t,{task:"pioneer",targetName:e.name,flagName:e.name,type:t.behaviour},{targetRoom:e.pos.roomName,minEnergyCapacity:400,rangeRclRatio:2},t=>{this.memory(Game.flags[t.destiny.targetName]).queued.push({room:t.queueRoom,name:t.name,targetName:e.name})})}}),this.handleSpawningStarted=(e=>{if(!e.destiny||!e.destiny.task||"pioneer"!=e.destiny.task)return;let t=Game.flags[e.destiny.flagName];if(t){let r=this.memory(t);r.spawning.push(e);const o=e.destiny.type,a=o?_.find(this.creep,{behaviour:o}).queue:["Low","High"];TaskManager.validateQueued(r,t,this.name,{queues:[a]})}}),this.handleSpawningCompleted=(e=>{if(!e.data||!e.data.destiny||!e.data.destiny.task||"pioneer"!=e.data.destiny.task)return;let t=Game.flags[e.data.destiny.flagName];if(t){e.data.predictedRenewal=e.data.spawningTime+50*Util.routeRange(e.data.homeRoom,t.pos.roomName);let r=this.memory(t);r.running.push(e.name),TaskManager.validateSpawning(r,t,this.name)}}),this.handleCreepDied=(e=>{let t=Memory.population[e];if(!t||!t.destiny||!t.destiny.task||"pioneer"!=t.destiny.task)return;let r=Game.flags[t.destiny.flagName];if(r){let t=this.memory(r);TaskManager.validateRunning(t,r,this.name,{roomName:r.pos.roomName,deadCreep:e})}}),this.memory=(e=>(e.memory.tasks||(e.memory.tasks={}),e.memory.tasks.pioneer||(e.memory.tasks.pioneer={queued:[],spawning:[],running:[]}),e.memory.tasks.pioneer)),this.creep={pioneer:{fixedBody:{[CARRY]:2,[MOVE]:2,[WORK]:2},multiBody:[WORK,MOVE,CARRY],name:"pioneer",behaviour:"pioneer",queue:"Low"},worker:{fixedBody:[MOVE,CARRY,WORK],behaviour:"collapseWorker",queue:"High"}}}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(4);t.default=new class extends o.TaskComponent{constructor(){super("attackController"),this.handleFlagFound=(e=>{e.compareTo(FLAG_COLOR.invade.attackController)&&TaskManager.nextCreepCheck(e,this.name)&&(Util.set(e.memory,"task",this.name),this.checkForRequiredCreeps(e))}),this.checkForRequiredCreeps=(e=>{const t=e.pos.roomName;Game.rooms[t];let r=this.memory(e);TaskManager.validateAll(r,e,this.name,{roomName:t,checkValid:!0}),r.queued.length+r.spawning.length+r.running.length<1&&TaskManager.spawn(this.creep.attackController,{task:"attackController",targetName:e.name},{targetRoom:e.pos.roomName,minEnergyCapacity:3250,maxRange:5},e=>{r.queued.push({room:e.queueRoom,name:e.name})})}),this.handleSpawningStarted=(e=>{if(!e.destiny||!e.destiny.task||"attackController"!=e.destiny.task)return;let t=Game.flags[e.destiny.targetName];if(t){let r=this.memory(t);r.spawning.push(e),TaskManager.validateQueued(r,t,this.name)}}),this.handleSpawningCompleted=(e=>{if(!e.data||!e.data.destiny||!e.data.destiny.task||"attackController"!=e.data.destiny.task)return;let t=Game.flags[e.data.destiny.targetName];if(t){e.data.predictedRenewal=e.data.spawningTime+50*Util.routeRange(e.data.homeRoom,t.pos.roomName);let r=this.memory(t);r.running.push(e.name),TaskManager.validateSpawning(r,t,this.name)}}),this.handleCreepDied=(e=>{let t=Memory.population[e];if(!t||!t.destiny||!t.destiny.task||"attackController"!=t.destiny.task)return;let r=Game.flags[t.destiny.targetName];if(r){const t=this.memory(r);TaskManager.validateRunning(t,r,this.name,{roomName:r.pos.roomName,deadCreep:e})}}),this.memory=(e=>(e.memory.tasks||(e.memory.tasks={}),e.memory.tasks.attackController||(e.memory.tasks.attackController={queued:[],spawning:[],running:[]}),e.memory.tasks.attackController)),this.nextAction=(e=>{let t=[CreepManager.action.attackController,CreepManager.action.recycling];for(let r=0;r<t.length;r++){let o=t[r];if(o.isValidAction(e)&&o.isAddableAction(e)&&o.assign(e))return}}),this.creep={attackController:{fixedBody:[],multiBody:{[CLAIM]:5,[MOVE]:5},minMulti:1,maxMulti:4,name:"Atk-Contr",behaviour:"claimer",queue:"Low"}}}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(4);t.default=new class extends o.TaskComponent{constructor(){super("robbing"),this.default={name:`default-${this.name}`},this.robber={name:`robber-${this.name}`,homeRoom:e=>{const t=this.memory(e);return t.storageRoom?Game.rooms[t.storageRoom]:RoomManager.bestSpawnRoomFor(e.pos.roomName)},spawnRoom:({roomName:e,minWeight:t})=>RoomManager.findSpawnRoom({targetRoom:e,minEnergyCapacity:t||250})},this.checkFlag=(e=>!(e.room&&e.room.my)&&e.compareTo(FLAG_COLOR.invade.robbing)&&TaskManager.nextCreepCheck(e,this.name)),this.handleFlagFound=(e=>{this.checkFlag(e)&&(Util.set(e.memory,"task",this.name),this.checkForRequiredCreeps(e))}),this.checkForRequiredCreeps=(e=>{let t=this.memory(e);TaskManager.validateAll(t,e,this.name,{roomName:e.pos.roomName,checkValid:!0});const r=t.queued.length+t.spawning.length+t.running.length,o=e.pos.roomName;if(r<(t.numRobbers||2)){const t=this.robber.spawnRoom({roomName:o});if(!t)return;const r=ROBBER_REHOME?this.robber.homeRoom(e):t;TaskManager.spawn(this.creep.robbing,{task:this.name,targetName:e.name,homeRoom:r.name},{targetRoom:o,explicit:t.name},e=>{this.memory(Game.flags[e.destiny.targetName]).queued.push({room:e.queueRoom,name:e.name})})}}),this.handleSpawningStarted=(e=>{if(!e.destiny||!e.destiny.task||"robbing"!=e.destiny.task)return;let t=Game.flags[e.destiny.targetName||e.destiny.flagName];if(t){let r=this.memory(t);r.spawning.push(e),TaskManager.validateQueued(r,t,this.name)}}),this.handleSpawningCompleted=(e=>{if(!e.data||!e.data.destiny||!e.data.destiny.task||"robbing"!=e.data.destiny.task)return;e.data.destiny.homeRoom&&(e.data.homeRoom=e.data.destiny.homeRoom);let t=Game.flags[e.data.destiny.targetName||e.data.destiny.flagName];if(t){e.data.predictedRenewal=e.data.spawningTime+50*Util.routeRange(e.data.homeRoom,t.pos.roomName);let r=this.memory(t);r.running.push(e.name),TaskManager.validateSpawning(r,t,this.name)}}),this.handleCreepDied=(e=>{let t=Memory.population[e];if(!t||!t.destiny||!t.destiny.task||"robbing"!=t.destiny.task)return;let r=Game.flags[t.destiny.targetName||t.destiny.flagName];if(r){const t=this.memory(r);TaskManager.validateRunning(t,r,this.name,{roomName:r.pos.roomName,deadCreep:e})}}),this.memory=(e=>(e.memory.tasks||(e.memory.tasks={}),e.memory.tasks.robbing||(e.memory.tasks.robbing={queued:[],spawning:[],running:[],numRobbers:2}),e.memory.tasks.robbing)),this.nextAction=(e=>{let t=e.sum;if(e.pos.roomName==e.data.homeRoom){if(t>0){LOG_TRACE&&Log.trace("TaskManager",{creepName:e.name,pos:e.pos,nextAction:"storing?",robbing:"nextAction",TaskManager:"robbing"});let r=[];if(e.carry.energy==t&&(r=e.room.structures.links.privateers),e.room.storage&&r.push(e.room.storage),e.room.structures.container&&(r=r.concat(e.room.structures.container.privateers)),r.length>0){let t=e.pos.findClosestByRange(r);if(t.structureType==STRUCTURE_STORAGE&&CreepManager.action.storing.assign(e,t))return;if(CreepManager.action.charging.assign(e,t))return}if(CreepManager.action.charging.assign(e))return;if(!e.room.ally&&CreepManager.action.storing.assign(e))return;if(CreepManager.action.dropping.assign(e))return;return void CreepManager.behaviour.worker.nextAction(e)}return TaskManager[e.data.destiny.task].exploitNextRoom(e)?void(LOG_TRACE&&Log.trace("TaskManager",{creepName:e.name,pos:e.pos,nextAction:"travelling",robbing:"nextAction",TaskManager:"robbing"})):(LOG_TRACE&&Log.trace("TaskManager",{creepName:e.name,pos:e.pos,nextAction:"working",robbing:"nextAction",TaskManager:"robbing"}),void CreepManager.behaviour.worker.nextAction(e))}if(!e.flag||e.flag.pos.roomName!==e.pos.roomName)return LOG_TRACE&&Log.trace("TaskManager",{creepName:e.name,pos:e.pos,nextAction:"travelling2",robbing:"nextAction",TaskManager:"robbing"}),void TaskManager[e.data.destiny.task].exploitNextRoom(e);if(LOG_TRACE&&Log.trace("TaskManager",{creepName:e.name,pos:e.pos,nextAction:"robbing",robbing:"nextAction",TaskManager:"robbing"}),e.sum<.4*e.carryCapacity){let t=[CreepManager.action.picking,CreepManager.action.robbing];for(let r=0;r<t.length;r++){let o=t[r];if(o.isValidAction(e)&&o.isAddableAction(e)&&o.assign(e))return}return e.flag&&(e.flag.cloaking=50),void TaskManager[e.data.destiny.task].exploitNextRoom(e)}this.goHome(e)}),this.exploitNextRoom=(e=>{if(e.sum<.4*e.carryCapacity){let t;if(e.data.destiny&&(t=Game.flags[e.data.destiny.flagName]),t||(t=this.getFlag(e.data.homeRoom)),t)return this.gotoTargetRoom(e,t)}return this.goHome(e)}),this.goHome=(e=>(PopManager.registerCreepFlag(e,null),CreepManager.action.travelling.assignRoom(e,e.data.homeRoom),!1)),this.getFlag=(e=>FlagManager.find(e=>e.color==FLAG_COLOR.invade.robbing.color&&e.secondaryColor==FLAG_COLOR.invade.robbing.secondaryColor,new RoomPosition(25,25,e),!1)),this.storage=((e,t)=>{const r=this.memory(this.getFlag(e));if(t){const o=r.storageRoom;return r.storageRoom=t,`TaskManager.${this.name}: room ${e}, now sending haulers to ${t}, (was ${o})`}if(r.storageRoom){if(!1===t){const t=r.storageRoom;return delete r.storageRoom,`TaskManager.${this.name}: room ${e}, cleared custom storage room (was ${t})`}return`TaskManager.${this.name}: room ${e}, sending haulers to ${r.storageRoom}`}return`TaskManager.${this.name}: room ${e}, no custom storage destination`}),this.gotoTargetRoom=((e,t)=>{if(CreepManager.action.travelling.assignRoom(e,t.pos.roomName))return PopManager.registerCreepFlag(e,t),!0}),this.creep={robbing:{fixedBody:[WORK,CARRY,MOVE,MOVE],multiBody:[CARRY,MOVE],name:"robber",behaviour:"privateer",queue:"Low"}},this.state={default:this.default,robber:this.robber}}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(4),a={"Source Keeper":!0,Invader:!0},i={MY_SCORE:1e3,WHITELIST_SCORE:200,ALLY:100,NEUTRAL:1,NPC_SCORE:-200};t.default=new class extends o.TaskComponent{constructor(){super("reputation"),this.myName=(()=>ME),this.isNPC=(e=>!0===a[e]),this.npcOwner=(e=>e.owner&&this.isNPC(e.owner.username)),this.isAlly=(e=>this.score(e)>=i.ALLY),this.notAlly=(e=>!this.isAlly(e)),this.allyOwner=(e=>e.owner&&this.isAlly(e.owner.username)),this.isHostile=(e=>this.score(e)<i.NEUTRAL),this.notHostile=(e=>!this.isHostile(e)),this.hostileOwner=(e=>e.owner&&this.isHostile(e.owner.username)),this.whitelist=(()=>this.cache("whitelist")),this.whitelist=(()=>this.cache("whitelist")),this.score=(e=>{const t=this.cache("score");if(void 0===e)return t;const r=e&&e.toLowerCase();return t[r]?t[r]:t[r]=0}),this.setScore=((e,t)=>{const r=e&&e.toLowerCase();this.score()[r]=t,this.playerMemory(r).score=t}),this.fresh=(()=>{this._loadWhitelist(),this._loadScore()}),this.cache=(e=>TaskManager.cache(this.name,e)),this.killScoreCache=(()=>(TaskManager.clearCache(this.name,"score"),this.score())),this.killWhitelistCache=(()=>(TaskManager.clearCache(this.name,"score"),TaskManager.clearCache(this.name,"whitelist"),this.whitelist())),this.memory=(e=>TaskManager.memory(this.name,e)),this.playerMemory=(e=>{const t=this.memory("players"),r=e&&e.toLowerCase();return t[r]?t[r]:t[r]={}}),this._loadScore=(()=>{const e=this.cache("etc"),t=this.memory("players"),r=this.whitelist();let o=this.score();if(_.keys(t).length+_.keys(r).length!==_.keys(o).length+e.whitelistRepUnion){o=this.killScoreCache();for(const e in a)o[e]=i.NPC_SCORE;_.keys(r).forEach(e=>{o[e]=i.WHITELIST_SCORE}),e.whitelistRepUnion=0,_.reduce(t,(t,o,a)=>("number"==typeof o.score&&(r[a]&&e.whitelistRepUnion++,t[a]=o.score),t),o),this.setScore(this.myName(),i.MY_SCORE)}}),this._loadWhitelist=(()=>{let e=this.whitelist();_.keys(e).length!==PLAYER_WHITELIST.length&&(e=this.killWhitelistCache(),_.forEach(PLAYER_WHITELIST,t=>{e[t.toLowerCase()]=!0}))})}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(4);t.default=new class extends o.TaskComponent{constructor(){super("delivery"),this.memory=(e=>{let t=TaskManager.memory(this.name,e);return t.hasOwnProperty("queued")||(t.queued=[]),t.hasOwnProperty("spawning")||(t.spawning=[]),t.hasOwnProperty("running")||(t.running=[]),t}),this.memoryKey=(e=>{const t=Game.flags[e.destiny.targetName];return t&&t.pos.roomName}),this.checkFlag=(e=>e.room&&e.room.my&&e.compareTo(FLAG_COLOR.invade.robbing)&&TaskManager.nextCreepCheck(e,this.name)),this.handleFlagFound=(e=>{this.checkFlag(e)&&this.checkForRequiredCreeps(e)}),this.maxCreeps=(e=>e.room&&e.room.storage?Math.floor(2*e.room.storage.charge):1),this.checkForRequiredCreeps=(e=>{const t=this.memory(e.pos.roomName);if(TaskManager.validateAll(t,e,this.name,{roomName:e.pos.roomName,checkValid:!0}),t.queued.length+t.spawning.length>0)return;const r=this.maxCreeps(e);if(t.running.length<r){const t=FlagManager.find(FLAG_COLOR.claim.delivery,e.pos);let r=t&&t.pos.roomName;if(!r){const t=RoomManager.findSpawnRoom({targetRoom:e.pos.roomName});if(!t)return;r=t.name}TaskManager.spawn(this.creep.recycler,{task:this.name,targetName:e.name,targetRoom:r},{explicit:e.pos.roomName,targetRoom:r,minEnergyCapacity:100},e=>{this.memory(Game.flags[e.destiny.targetName].pos.roomName).queued.push({room:e.queueRoom,name:e.name})})}}),this.handleSpawningStarted=(e=>{if(!e.destiny||!e.destiny.task||e.destiny.task!=this.name)return;let t=Game.flags[e.destiny.targetName];if(t){let r=this.memory(t.pos.roomName);r.spawning.push(e),TaskManager.validateQueued(r,t,this.name)}}),this.handleSpawningCompleted=(e=>{if(!e.data||!e.data.destiny||!e.data.destiny.task||e.data.destiny.task!=this.name)return;e.data.homeRoom=e.data.destiny.homeRoom||e.data.homeRoom,e.data.travelRoom=e.data.destiny.targetRoom||e.data.travelRoom;let t=Game.flags[e.data.destiny.targetName];if(t){let r=this.memory(t.pos.roomName);TaskManager.validateSpawning(r,t,this.name),e.data.predictedRenewal=e.data.spawningTime+50*Util.routeRange(e.data.homeRoom,t.pos.roomName),r.running.push(e.name)}}),this.handleCreepDied=(e=>{const t=Memory.population[e];if(!t||!t.destiny||!t.destiny.task||t.destiny.task!=this.name)return;const r=Game.flags[t.destiny.targetName];if(r){const t=this.memory(r.pos.roomName);TaskManager.validateRunning(t,r,this.name,{roomName:r.pos.roomName,deadCreep:e})}}),this.minControllerLevel=4,this.creep={recycler:{fixedBody:[CARRY,MOVE],multiBody:[CARRY,MOVE],name:"recycler",behaviour:"recycler",queue:"Low"}}}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(4);t.default=new class extends o.TaskComponent{constructor(){super("labTech"),this.register=(()=>{FlagManager.found.on(e=>this.handleFlagFound(e)),CreepManager.spawningStarted.on(e=>this.handleSpawningStarted(e)),CreepManager.spawningCompleted.on(e=>this.handleSpawningCompleted(e)),CreepManager.predictedRenewal.on(e=>this.handleCreepDied(e.name)),CreepManager.died.on(e=>this.handleCreepDied(e))}),this.handleFlagFound=(e=>{e.compareTo(FLAG_COLOR.labs.labTech)&&TaskManager.nextCreepCheck(e,this.name)&&(Util.set(e.memory,"task",this.name),this.checkForRequiredCreeps(e))}),this.checkForRequiredCreeps=(e=>{const t=this.memory(e);TaskManager.validateAll(t,e,this.name,{roomName:e.pos.roomName,checkValid:!0}),t.queued.length+t.spawning.length+t.running.length<1&&TaskManager.spawn(this.creep.labTech,{task:"labTech",targetName:e.name},{targetRoom:e.pos.roomName,minEnergyCapacity:1e3,maxRange:1,allowTargetRoom:!0},e=>{this.memory(Game.flags[e.destiny.targetName]).queued.push({room:e.queueRoom,name:e.name})})}),this.handleSpawningStarted=(e=>{if(!e.destiny||!e.destiny.task||"labTech"!=e.destiny.task)return;let t=Game.flags[e.destiny.targetName||e.destiny.flagName];if(t){const r=this.memory(t);r.spawning.push(e),TaskManager.validateQueued(r,t,this.name)}}),this.handleSpawningCompleted=(e=>{if(!e.data||!e.data.destiny||!e.data.destiny.task||"labTech"!=e.data.destiny.task)return;let t=Game.flags[e.data.destiny.targetName||e.data.destiny.flagName];if(t){e.data.predictedRenewal=e.data.spawningTime+50*Util.routeRange(e.data.homeRoom,t.pos.roomName);const r=this.memory(t);r.running.push(e.name),TaskManager.validateSpawning(r,t,this.name)}}),this.handleCreepDied=(e=>{const t=Memory.population[e];if(!t||!t.destiny||!t.destiny.task||"labTech"!=t.destiny.task)return;const r=Game.flags[t.destiny.targetName||t.destiny.flagName];if(r){const t=this.memory(r);TaskManager.validateRunning(t,r,this.name,{roomName:r.pos.roomName,deadCreep:e})}}),this.memory=(e=>(e.memory.tasks||(e.memory.tasks={}),e.memory.tasks.labTech||(e.memory.tasks.labTech={queued:[],spawning:[],running:[]}),e.memory.tasks.labTech)),this.creep={labTech:{fixedBody:[WORK,CARRY,MOVE],multiBody:[CARRY,CARRY,MOVE],name:"labTech",behaviour:"labTech",queue:"Low"}}}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(4);t.default=new class extends o.TaskComponent{constructor(){super("safeGen"),this.handleFlagFound=(e=>{if(e.compareTo(FLAG_COLOR.command.safeGen)&&TaskManager.nextCreepCheck(e,this.name)){const t=Game.rooms[e.pos.roomName];t&&(t.storage&&t.storage.store[RESOURCE_GHODIUM]>=1e3||t.terminal&&t.terminal.store[RESOURCE_GHODIUM]>=1e3)?(Util.set(e.memory,"task",this.name),this.checkForRequiredCreeps(e)):e.remove()}}),this.checkForRequiredCreeps=(e=>{const t=this.memory(e);TaskManager.validateAll(t,e,this.name,{roomName:e.pos.roomName,checkValid:!0}),t.queued.length+t.spawning.length+t.running.length<1&&TaskManager.spawn(this.creep.safeGen,{task:"safeGen",targetName:e.name},{targetRoom:e.pos.roomName,minEnergyCapacity:2e3,maxRange:1,allowTargetRoom:!0},e=>{this.memory(Game.flags[e.destiny.targetName]).queued.push({room:e.queueRoom,name:e.name})})}),this.handleSpawningStarted=(e=>{if(!e.destiny||!e.destiny.task||"safeGen"!=e.destiny.task)return;let t=Game.flags[e.destiny.targetName||e.destiny.flagName];if(t){const r=this.memory(t);r.spawning.push(e),TaskManager.validateQueued(r,t,this.name)}}),this.handleSpawningCompleted=(e=>{if(!e.data||!e.data.destiny||!e.data.destiny.task||"safeGen"!=e.data.destiny.task)return;let t=Game.flags[e.data.destiny.targetName||e.data.destiny.flagName];if(t){e.data.predictedRenewal=e.data.spawningTime+50*Util.routeRange(e.data.homeRoom,t.pos.roomName);const r=this.memory(t);r.running.push(e.name),TaskManager.validateSpawning(r,t,this.name)}}),this.handleCreepDied=(e=>{const t=Memory.population[e];if(!t||!t.destiny||!t.destiny.task||"safeGen"!=t.destiny.task)return;const r=Game.flags[t.destiny.targetName||t.destiny.flagName];if(r){const t=this.memory(r);TaskManager.validateRunning(t,r,this.name,{roomName:r.pos.roomName,deadCreep:e})}}),this.memory=(e=>(e.memory.tasks||(e.memory.tasks={}),e.memory.tasks.safeGen||(e.memory.tasks.safeGen={queued:[],spawning:[],running:[]}),e.memory.tasks.safeGen)),this.minControllerLevel=6,this.creep={safeGen:{multiBody:[CARRY,MOVE],maxMulti:20,maxWeight:2e3,name:"safeGen",behaviour:"safeGen",queue:"Low"}}}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(4);t.default=new class extends o.TaskComponent{constructor(){super("scheduler"),this.processes={example:{conditions:()=>!1,run:()=>{console.log("Hello!")}}},this.run=(()=>{_.forEach(this.processes,(e,t)=>{e.conditions()&&e.run()})}),this.registerProcess=((e,t,r)=>{this.processes[e]?(this.processes[e].conditions=t,this.processes[e].run=r):this.processes[e]={conditions:t,run:r}}),this.unregisterProcess=(e=>{this.processes[e]&&delete this.processes[e]}),this.forceRunProcess=(e=>{let t=this.processes[e];t&&t.conditions()&&t.run()})}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(3),a=r(8),i=r(12);t.default=new class extends o.Component{constructor(){super(...arguments),this.extend=(()=>{i.Strategy.decorateAgent(Creep.prototype,{default:e=>e.action&&e.action.name,selector:e=>CreepManager.action[e]},{default:e=>e.data.creepType,selector:e=>CreepManager.behaviour[e]&&CreepManager.behaviour[e]},{default:e=>e.data.destiny&&e.data.destiny.task,selector:e=>TaskManager[e]&&TaskManager[e]})}),this.fresh=(()=>{a.Install(CreepManager,{spawningStarted:new o.EventConstructor,spawningCompleted:new o.EventConstructor,predictedRenewal:new o.EventConstructor,died:new o.EventConstructor,error:new o.EventConstructor})}),this.register=(()=>{for(const e in CreepManager.action)CreepManager.action[e].register&&CreepManager.action[e].register(this);for(const e in CreepManager.behaviour)CreepManager.behaviour[e].register&&CreepManager.behaviour[e].register(this);for(const e in CreepManager.setup)CreepManager.setup[e].register&&CreepManager.setup[e].register(this)}),this.run=(()=>{Memory.CPU_CRITICAL&&Log.module("Creep",`${Game.time}: CPU Bucket level is critical (${Game.cpu.bucket}). Skipping non critical creep roles.`),_.forEach(Game.creeps,e=>{CPU_CHECK_CONFIG.CREEP&&CPU.check("Creep",e.name);try{e.run()}catch(t){Log.error(`[Creep] ${e.name} ${t.stack||t.toString()}`,Log.stack())}CPU_CHECK_CONFIG.CREEP&&CPU.end("Creep",e.name)})}),this.isWorkingAge=(e=>{const t=Game.creeps[e.creepName];return!t||(e.predictedRenewal||e.spawningTime||CREEP_LIFE_TIME)<=(t.ticksToLive||CREEP_LIFE_TIME)}),this.bodyCosts=(e=>{let t=0;return e&&e.forEach(function(e){t+=BODYPART_COST[e]}),t}),this.multi=((e,t={})=>{const r=t.minMulti||0,o=this.bodyCosts(t.fixedBody),a=this.bodyCosts(t.multiBody);if(0===a)return 0;let i=1/0;if(t.minThreat){const e=this.bodyThreat(t.fixedBody),r=this.bodyThreat(t.multiBody);i=0;let o=e;for(;o<t.minThreat;)i+=1,o+=r}let n=0;if(t.minWeight){let e=o;for(;e<t.minWeight;)n+=1,e+=a}const s=Math.floor((50-t.fixedBody.length)/t.multiBody.length),l=t.currentEnergy?e.energyAvailable:e.energyCapacityAvailable,m=Math.floor((l-o)/a),c=t.maxWeight?Math.floor((t.maxWeight-o)/a):1/0,u=t.maxMulti||1/0,d=_.min([m,i,c,u]),h=_.max([r,n,d]);return _.min([s,h])}),this.partsComparator=((e,t)=>{let r=[TOUGH,CLAIM,WORK,CARRY,ATTACK,RANGED_ATTACK,HEAL,MOVE];return r.indexOf(e)-r.indexOf(t)}),this.formatParts=(e=>{if(e&&!Array.isArray(e)&&"object"==typeof e){const t=[];for(const r of BODYPARTS_ALL)r in e&&t.push(..._.times(e[r],e=>r));e=t}return e}),this.formatBody=((e,t)=>({fixedBody:e=this.formatParts(e),multiBody:t=this.formatParts(t)})),this.compileBody=((e,t,r=!0)=>{const{fixedBody:o,multiBody:a}=this.formatBody(t.fixedBody||[],t.multiBody||[]);_.assign(t,{fixedBody:o,multiBody:a}),void 0!==t.sort&&(r=t.sort);let i=[];const n=this.multi(e,t);for(let e=0;e<n;e++)i=i.concat(t.multiBody);if(i=i.concat(t.fixedBody),r){const e="function"==typeof r?r:this.partsComparator;i.sort(e)}if(i.includes(HEAL)){let e=i.indexOf(HEAL);i.splice(e,1),i.push(HEAL)}return i}),this.bodyThreat=(e=>{let t=0;return e&&e.forEach(e=>{t+=CREEP_PART_THREAT[e.type?e.type:e][e.boost?"boosted":"common"]}),t})}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(0);t.default=new class extends o.CreepAction{constructor(){super("attackController"),this.isValidAction=(e=>!0),this.isValidTarget=((e,t)=>e&&(!e.reservation||!TaskManager.reputation.allyOwner(e.reservation))&&t.flag),this.isAddableAction=(()=>!0),this.isAddableTarget=(e=>e&&(e instanceof Flag||"controller"===e.structureType&&(e.reservation||e.owner))),this.newTarget=(e=>{let t;return e.data.destiny&&(t=Game.flags[e.data.destiny.targetName]),t||(t=FlagManager.find(e=>FlagManager.compare(e,FLAG_COLOR.invade.attackController),e.pos,!1,FlagManager.reserveMod,e.name)),t?(PopManager.registerCreepFlag(e,t),e.flag.room&&e.flag.pos.roomName==e.pos.roomName?e.flag.room.controller:e.flag):null}),this.step=(e=>{if(CHATTY&&e.say(this.name,SAY_PUBLIC),e.target.color)return e.flag.pos.roomName==e.pos.roomName&&(e.data.targetId=null),void e.travelTo(e.target);let t=e.pos.getRangeTo(e.target);if(t<=this.targetRange){let r=this.work(e);r!=OK&&e.handleError({errorCode:r,action:this.name,target:e.target,range:t,creep:e})}else e.travelTo(e.target)}),this.work=(e=>{let t;return e.controllerSign(),t=e.target.owner&&!e.target.my||e.target.reservation&&!TaskManager.reputation.allyOwner(e.target.reservation)?e.attackController(e.target):e.claimController(e.target)}),this.setDefault({moveOptions:e=>e})}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(0);t.default=new class extends o.CreepAction{constructor(){super("avoiding"),this.targetRange=0,this.reachedRange=0,this.lairDangerTime=24,this.lairDangerRange=14,this.isActiveLair=(e=>!_.isUndefined(e.ticksToSpawn)&&e.ticksToSpawn<=this.lairDangerTime),this.isValidAction=(e=>e.data.destiny&&e.data.destiny.room===e.room.name&&(RoomManager.isSKRoom(e.room.name)||e.room.situation.invasion)),this.isAddableAction=(e=>!0),this.isValidTarget=((e,t)=>TaskManager.reputation.npcOwner(e)?_.isUndefined(e.ticksToSpawn)||this.isActiveLair(e):!(!TaskManager.reputation.hostileOwner(e)||!e.hasActiveBodyparts)&&e.hasActiveBodyparts([ATTACK,RANGED_ATTACK])),this.newTarget=(e=>{if(RoomManager.isSKRoom(e.pos.roomName)){const t=_.first(e.room.find(FIND_STRUCTURES,{filter:t=>this.isActiveLair(t)&&e.pos.getRangeTo(t.pos)<=this.lairDangerRange}));if(t)return t}if(e.room.situation.invasion){const t=_.chain(e.room.hostiles).filter(e=>this.isValidTarget(e)).map(t=>{let r=0;const o=e.pos.getRangeTo(t);return{target:t,score:r="Invader"===e.owner.username||"Source Keeper"===e.owner.username?o-51:o<10?o-11:0}}).filter("score").sortBy("score").first().get("target").value();if(t)return t}}),this.work=(e=>{if(!e.data.safeSpot||!e.data.safeSpot.roomName){const t=e.data.destiny&&Game.flags[e.data.destiny.targetName];if(t)e.data.safeSpot=t.pos;else{const t=_.chain(e.room.findRoute(e.data.homeRoom)).first().get("exit").value();t&&(e.data.safeSpot=e.pos.findClosestByRange(t),e.data.safeSpot.roomName=e.pos.roomName)}}e.data.safeSpot&&(e.pos.getRangeTo(e.target)<10?e.travelTo(e.data.safeSpot):e.idleMove())}),this.run=(e=>{if(this.isValidAction(e)&&(e.action===this&&this.isValidTarget(e.target,e)||this.isAddableAction(e)&&this.assign(e)))return!!e.leaveBorder()||(this.work(e),!0)})}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(0);t.default=new class extends o.CreepAction{constructor(){super("boosting"),this.maxPerAction=1,this.isValidMineralType=(e=>{for(const t in BOOSTS)for(const r in BOOSTS[t])if(e===r)return!0;return!1}),this.isValidMineralType=(e=>{for(const t in BOOSTS)for(const r in BOOSTS[t])if(e===r)return!0;return!1}),this.getBoostPartType=(e=>{for(const t in BOOSTS)for(const r in BOOSTS[t])if(e===r)return t}),this.canBoostType=((e,t)=>!_(e.body).filter({type:t}).every(e=>e.boost)),this.isValidAction=(e=>!_.every(e.body,e=>e.boost)),this.isValidTarget=((e,t)=>e instanceof StructureLab&&e.active&&e.energy>=LAB_BOOST_ENERGY&&e.mineralAmount>=LAB_BOOST_MINERAL),this.newTarget=(e=>_(e.room.structures.labs.all).filter(this.isValidTarget).filter(t=>this.isAddableTarget(t,e)).min(t=>e.pos.getRangeTo(t))),this.work=(e=>e.target.boostCreep(e)),this.onAssignment=(e=>{SAY_ASSIGNMENT&&e.say(Util.emoji.boosting,SAY_PUBLIC)}),this.setDefault({isValidMineralType:e=>{for(const t in BOOSTS)for(const r in BOOSTS[t])if(e===r)return!0;return!1}}),this._isAddableTarget=this.isAddableTarget,this.isAddableTarget=((e,t)=>{const r=this.getBoostPartType(e.mineralType);return this._isAddableTarget(e,t)&&t.getStrategyHandler([this.name],"isValidMineralType",e.mineralType)&&t.hasActiveBodyparts(r)&&this.canBoostType(t,r)})}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(0);t.default=new class extends o.CreepAction{constructor(){super("building"),this.maxPerTarget=3,this.maxPerAction=3,this.targetRange=3,this.reachedRange=(e=>e.getStrategyHandler([this.name],"reachedRange",e)),this.isValidAction=(e=>e.carry.energy>0),this.isAddableAction=(e=>!e.room.population||!e.room.population.actionCount[this.name]||e.room.population.actionCount[this.name]<this.maxPerAction),this.isValidTarget=(e=>null!=e&&(e.my||TaskManager.reputation.allyOwner(e))&&e.progress&&e.progress<e.progressTotal),this.isAddableTarget=(e=>e&&(e.my||TaskManager.reputation.allyOwner(e))&&(!e.targetOf||e.targetOf.length<this.maxPerTarget)),this.newTarget=(e=>e.room.getBestConstructionSiteFor(e.pos,t=>this.isAddableTarget(t,e))),this.work=(e=>(e.getStrategyHandler([this.name],"getEnergy",e),e.build(e.target))),this.setDefault({reachedRange:1,getEnergy:()=>!1})}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(0);t.default=new class extends o.CreepAction{constructor(){super("bulldozing"),this.maxPerAction=2,this.maxPerTarget=1,this.isValidTarget=(e=>!(!e.room.my&&e.room.controller&&e.room.controller.safeMode)&&e instanceof ConstructionSite&&TaskManager.reputation.notAlly(e.owner.username)),this.newTarget=(e=>{const t=_(e.room.constructionSites).filter(this.isValidTarget).max(t=>{let r;return r=t.structureType===STRUCTURE_SPAWN?2e4:1e4,r+=t.progress/t.progressTotal*1e4,r-=e.pos.getRangeTo(t)});if(t instanceof ConstructionSite)return t}),this.work=(e=>e.move(e.pos.getDirectionTo(e.target)))}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(0);t.default=new class extends o.CreepAction{constructor(){super("charging"),this.renewTarget=!1,this.maxPerTarget=1,this.isValidAction=(e=>e.carry.energy>0),this.isAddableAction=(e=>!0),this.isValidTarget=(e=>!!e&&(e.structureType==STRUCTURE_LINK?e.energy<.85*e.energyCapacity:e.structureType==STRUCTURE_CONTAINER&&e.sum<(!0===e.source&&1==e.controller?e.storeCapacity*MANAGED_CONTAINER_TRIGGER:e.storeCapacity))),this.newTarget=(e=>{if(e.room.structures.links.storage.length>0){let t=e.room.structures.links.storage.find(e=>e.energy<.85*e.energyCapacity);if(t&&e.room.structures.links.controller.find(e=>e.energy<=.15*e.energyCapacity)&&this.isValidTarget(t,e)&&this.isAddableTarget(t,e))return t}if(e.room.structures.container.out.length>0){let t=null,r=0,o=o=>{if(this.isValidTarget(o,e)&&this.isAddableTarget(o,e)){let e=o.storeCapacity-o.sum;e>r&&(r=e,t=o)}};return _.forEach(e.room.structures.container.out,o),t}return null}),this.work=(e=>{let t;if(!0===e.target.source&&1==e.target.controller){let r=e.target.storeCapacity*MANAGED_CONTAINER_TRIGGER-e.target.sum;if(r<1)t=ERR_FULL;else{let o=_.min([e.carry.energy,r]);t=e.transfer(e.target,RESOURCE_ENERGY,o),e.target._sum+=o}}else t=e.transfer(e.target,RESOURCE_ENERGY);return delete e.data.actionName,delete e.data.targetId,e.action=null,e.target=null,t}),this._isAddableTarget=this.isAddableTarget,this.isAddableTarget=((e,t)=>this._isAddableTarget(e,t)&&(e instanceof OwnedStructure&&e.my||!t.room.controller||(!t.room.controller.owner||t.room.controller.my)&&(!t.room.controller.reservation||t.room.controller.reservation.username==t.owner.username))&&(e.structureType==STRUCTURE_CONTAINER&&e.storeCapacity-e.sum>Math.min(t.carry.energy,500)||e.structureType==STRUCTURE_LINK)&&(e.structureType!=STRUCTURE_CONTAINER||!e.controller||t.carry.energy==t.sum))}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(0);t.default=new class extends o.CreepAction{constructor(){super("claiming"),this.isValidAction=(e=>!0),this.isValidTarget=(e=>!e.room||!e.owner),this.isAddableAction=(()=>!0),this.isAddableTarget=(()=>!0),this.newTarget=(e=>{let t;if(e.data.destiny&&(t=Game.flags[e.data.destiny.targetName||e.data.destiny.flagName]),t||(t=FlagManager.find(FLAG_COLOR.claim,e.pos,!1,FlagManager.claimMod,e.name)),!t)return null;if(PopManager.registerCreepFlag(e,t),!e.flag.room||e.flag.pos.roomName!=e.pos.roomName)return e.flag;if(e.flag.room.controller.my){e.flag.setColor(FLAG_COLOR.claim.spawn.color,FLAG_COLOR.claim.spawn.secondaryColor);let t=e=>Game.flags[e.name].remove();return _.forEach(FlagManager.filter(FLAG_COLOR.invade.exploit,e.flag.pos,!0),t),null}return e.flag.room.controller}),this.step=(e=>{if(CHATTY&&e.say(this.name,SAY_PUBLIC),e.target.color)return e.flag.pos.roomName==e.pos.roomName&&(e.data.targetId=null),void e.travelTo(e.target.pos);let t=e.pos.getRangeTo(e.target);if(t<=this.targetRange){let r=this.work(e);r!=OK&&e.handleError({errorCode:r,action:this.name,target:e.target,range:t,creep:e})}e.travelTo(e.target.pos)}),this.work=(e=>(e.controllerSign(),e.claimController(e.target)))}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(0);t.default=new class extends o.CreepAction{constructor(){super("defending"),this.isValidAction=(e=>e.room.hostiles.length>0),this.isAddableAction=(()=>!0),this.isAddableTarget=(()=>!0),this.isValidTarget=(e=>e&&null!=e.hits&&e.hits>0&&0==e.my),this.newTarget=(e=>{let t=e.pos.findClosestByRange(e.room.hostiles,{filter:e.getStrategyHandler([this.name],"priorityTargetFilter",e)});return t||(t=e.pos.findClosestByRange(e.room.hostiles,{filter:e.getStrategyHandler([this.name],"targetFilter",e)})),t}),this.step=(e=>{if(CHATTY&&e.say(this.name,SAY_PUBLIC),e.target.pos.roomName!==e.room.name)return CreepManager.action.travelling.assignRoom(e,e.target.pos.roomName);this.run[e.data.creepType](e)}),this.run={ranger(e){let t=e.pos.getRangeTo(e.target);if(!e.flee&&(t>3&&e.travelTo(e.target,{respectRamparts:COMBAT_CREEPS_RESPECT_RAMPARTS}),t<3)){let r=e.target.pos.getDirectionTo(e);r&&(COMBAT_CREEPS_RESPECT_RAMPARTS&&!_.filter(e.pos.lookFor(LOOK_STRUCTURES),{my:!0,structureType:STRUCTURE_RAMPART})&&e.move(r),1===t&&(e.attacking=e.attack(e.target)==OK))}let r=e.pos.findInRange(e.room.hostiles,3);if(r.length>2)return CHATTY&&e.say("MassAttack"),void(e.attackingRanged=e.rangedMassAttack()==OK);t<4?e.attackingRanged=e.rangedAttack(e.target)==OK:r.length>0&&(e.attackingRanged=e.rangedAttack(r[0])==OK)},melee(e){e.flee||e.travelTo(e.target,{respectRamparts:COMBAT_CREEPS_RESPECT_RAMPARTS});let t=e.attack(e.target);if(t==ERR_NOT_IN_RANGE){let t=e.pos.findInRange(e.room.hostiles,1);t.length>0&&(e.attacking=e.attack(t[0])==OK)}else e.attacking=t==OK}},this.setDefault({priorityTargetFilter:e=>e=>e.hasBodyparts(HEAL),targetFilter:e=>e=>!0})}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(0);t.default=new class extends o.CreepAction{constructor(){super("dismantling"),this.maxPerAction=3,this.maxPerTarget=3,this.renewTarget=!1,this.isValidAction=(e=>0===e.carryCapacity||e.sum<e.carryCapacity),this.isValidTarget=(e=>null!=e),this.newTarget=(e=>{let t,r=FlagManager.find(FLAG_COLOR.destroy.dismantle,e.pos,!0);if(r)if(void 0!==r.room){let o=r.room.lookForAt(LOOK_STRUCTURES,r.pos.x,r.pos.y);if(o&&o.length>0)return o[0];{let o=r.name;RoomManager.costMatrixInvalid.trigger(r.room),FlagManager.removeFromDir(r.name),r.remove();let a=(e,t,r)=>t.name==r?1/0:e;if(o==(r=FlagManager.find(FLAG_COLOR.destroy.dismantle,e.pos,!0,a,o)).name&&Log.error("Removed flag found again in dismantling.newTarget!"),r)if(void 0!==r.room){let e=r.room.lookForAt(LOOK_STRUCTURES,r.pos.x,r.pos.y);if(e&&e.length>0)return e[0];RoomManager.costMatrixInvalid.trigger(r.room),FlagManager.removeFromDir(r.name),r.remove()}else t=r}}else t=r;return t}),this.work=(e=>e.dismantle(e.target))}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(0);t.default=new class extends o.CreepAction{constructor(){super("dropping"),this.targetRange=1,this.reachedRange=0,this.isValidAction=(e=>e.sum>0),this.isValidTarget=((e,t)=>!!e&&(!(e instanceof Flag)||e.compareTo(FLAG_COLOR.claim.spawn)||e.compareTo(FLAG_COLOR.command.drop))),this.newTarget=(e=>{let t=e.pos.findClosestByRange(e.room.structures.piles);return t||(t=e.pos.findClosestByRange(e.room.structures.spawns)),t||(t=e.pos.findClosestByRange(e.room.find(FIND_FLAGS,FlagManager.flagFilter(FLAG_COLOR.claim.spawn)))),t||(t=e.pos.findClosestByRange(_.filter(e.room.constructionSites,{structureType:STRUCTURE_SPAWN}))),t||(t=e.room.controller),t}),this.work=(e=>{let t=OK;if(!(e.target instanceof StructureSpawn||e.target instanceof ConstructionSite||e.target instanceof StructureController||(e=>e&&FlagManager.compare(e,FLAG_COLOR.claim.spawn))(e.target))&&e.pos.getRangeTo(e.target)>0&&e.data.lastPos&&e.data.path&&!_.eq(e.pos,e.data.lastPos)){let r=e=>e.type==LOOK_TERRAIN&&"wall"==e.terrain||e.type==LOOK_CREEPS||e.type==LOOK_STRUCTURES&&OBSTACLE_OBJECT_TYPES.includes(e.structure.structureType),o=e.room.lookAt(e.target);if(!_.some(o,r))return t}for(let r in e.carry)t=e.drop(r);return t})}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(0);t.default=new class extends o.CreepAction{constructor(){super("feeding"),this.maxPerTarget=1,this.isValidAction=(e=>e.carry.energy>0&&e.room.energyAvailable<e.room.energyCapacityAvailable),this.isValidTarget=(e=>e&&!_.isUndefined(e.energy)&&e.energy<e.energyCapacity),this.isAddableTarget=(e=>e.my&&(!e.targetOf||_.filter(e.targetOf,{actionName:"feeding"}).length<this.maxPerTarget)),this.newTarget=(e=>e.room.energyAvailable===e.room.energyCapacityAvailable?null:e.pos.findClosestByRange(e.room.structures.feedable,{filter:t=>this.isValidTarget(t)&&this.isAddableTarget(t,e)})),this.work=(e=>{let t=e.transfer(e.target,RESOURCE_ENERGY);return t==OK&&e.carry.energy>e.target.energyCapacity-e.target.energy&&(e.target=null,this.assign(e)),t})}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(0);t.default=new class extends o.CreepAction{constructor(){super("fortifying"),this.maxPerTarget=2,this.maxPerAction=3,this.targetRange=3,this.isValidAction=(e=>e.carry.energy>0&&(!e.room.storage||!e.room.storage.active||e.room.storage.charge>.6)),this.isValidTarget=(e=>e&&e.active&&e.hits&&e.hits<e.hitsMax),this.newTarget=(e=>_.find(e.room.structures.fortifyable,t=>this.isAddableTarget(t,e))),this.work=(e=>e.repair(e.target))}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(0);t.default=new class extends o.CreepAction{constructor(){super("fueling"),this.maxPerTarget=1,this.maxPerAction=1,this.isValidAction=(e=>e.carry.energy>0&&e.room.towerFreeCapacity>0),this.isValidTarget=(e=>e&&(e.energy||0==e.energy)&&e.active&&e.energy<e.energyCapacity),this.isAddableTarget=(e=>e.my&&(!e.targetOf||e.targetOf.length<this.maxPerTarget)),this.newTarget=(e=>e.room.structures.fuelable.length>0?e.pos.findClosestByRange(e.room.structures.fuelable):null),this.work=(e=>{let t=e.transfer(e.target,RESOURCE_ENERGY);return e.target.energyCapacity-e.target.energy<20&&(e.data.targetId=null),t})}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(0);t.default=new class extends o.CreepAction{constructor(){super("guarding"),this.reachedRange=0,this.isAddableAction=(()=>!0),this.isAddableTarget=(()=>!0),this.newTarget=(e=>{let t;return e.data.destiny&&(t=Game.flags[e.data.destiny.flagName]),t||(t=FlagManager.find(FLAG_COLOR.defense,e.pos,!1,FlagManager.rangeMod,{rangeModPerCrowd:400})),e.action===this&&e.flag?e.flag:(t&&PopManager.registerCreepFlag(e,t),t)}),this.work=(e=>e.room.hostiles.length>0?ERR_INVALID_ARGS:e.data.flagName?OK:ERR_INVALID_ARGS)}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(0);t.default=new class extends o.CreepAction{constructor(){super("harvesting"),this.renewTarget=!1,this.isValidAction=(e=>e.sum<e.carryCapacity&&e.room.sourceEnergyAvailable>0),this.isValidTarget=((e,t)=>null!==e&&null!==e.energy&&e.energy>0&&(void 0===e.targetOf||e.targetOf.length<=e.accessibleFields&&!_.some(e.targetOf,e=>("miner"===e.creepType||"remoteMiner"===e.creepType)&&e.body.work>=5&&(e.ticksToLive||CREEP_LIFE_TIME)>=(e.data&&e.data.predictedRenewal||0)))),this.isAddableTarget=((e,t)=>(!t.room.controller||(!t.room.controller.owner||t.room.controller.my)&&(!t.room.controller.reservation||t.room.controller.reservation.username==t.owner.username))&&(void 0===e.targetOf||e.targetOf.length<e.accessibleFields)),this.newTarget=(e=>{const t=_.sortBy(e.room.sources,t=>e.pos.getRangeTo(t));for(const r of t)if(this.isValidTarget(r,e)&&this.isAddableTarget(r,e))return r;return null}),this.work=(e=>e.harvest(e.target))}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(0);t.default=new class extends o.CreepAction{constructor(){super("healing"),this.targetRange=3,this.isAddableAction=(()=>!0),this.isAddableTarget=((e,t)=>{const r=t.getStrategyHandler([this.name],"targetFilter",t);return r&&r(e)}),this.isValidTarget=((e,t)=>{if(null!=e&&null!=e.hits&&e.hits<e.hitsMax&&e.pos.roomName===t.data.healRoom){const r=t.getStrategyHandler([this.name],"targetFilter",t);return r&&r(e)}return!1}),this.newTarget=(e=>{if(e.room.hurtCreeps.length>0)for(const t of e.room.hurtCreeps)if(t.name!==e.name)return e.data.healRoom=t.pos.roomName,t;return delete e.data.healRoom,null}),this.work=(e=>{if(e.target.hits<e.target.hitsMax)return e.pos.isNearTo(e.target)?e.heal(e.target):e.pos.inRangeTo(e.target,3)?e.rangedHeal(e.target):OK}),this.setDefault({targetFilter:e=>e=>e.my,moveOptions:e=>e})}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(0);t.default=new class extends o.CreepAction{constructor(){super("idle"),this.targetRange=3,this.isValidAction=(e=>!0),this.isAddableAction=(e=>!0),this.isAddableTarget=(e=>!0),this.newTarget=(e=>FlagManager.specialFlag()),this.step=(e=>{CHATTY&&e.say(this.name,SAY_PUBLIC),e.getStrategyHandler([this.name],"idleMove",e)&&e.idleMove(),delete e.data.actionName,delete e.data.targetId}),this.setDefault({idleMove:e=>!0})}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(0);t.default=new class extends o.CreepAction{constructor(){super("invading"),this.isValidAction=(e=>FlagManager.hasInvasionFlag()),this.isAddableAction=(()=>!0),this.isAddableTarget=(()=>!0),this.getFlaggedStructure=((e,t)=>{let r=[];return FlagManager.filter(e,t,!0).forEach(e=>{let o=Game.flags[e.name];if(o&&o.pos.roomName==t.roomName&&void 0!==o.room){let e=o.room.lookForAt(LOOK_STRUCTURES,o.pos.x,o.pos.y);if(e&&e.length>0){const t=e=>{e.destroyFlag=o,r.push(e)};e.forEach(t)}else o.remove()}}),r&&r.length>0?t.findClosestByRange(r):null}),this.newTarget=(e=>{let t=this.getFlaggedStructure(FLAG_COLOR.destroy,e.pos);if(t)return t.destroyFlag&&PopManager.registerCreepFlag(e,t.destroyFlag),t;let r=FlagManager.find(FLAG_COLOR.invade,e.pos,!1);if(r&&(!r.room||r.pos.roomName!=e.pos.roomName))return PopManager.registerCreepFlag(e,r),r;if(!r)return e.action=null,delete e.data.actionName,void delete e.data.targetId;if(!r.room.controller||!r.room.controller.my){let t=e.pos.findClosestByRange(e.room.hostiles,{filter:e=>_.some(e.body,{type:HEAL})});if(t)return t;if(t=e.pos.findClosestByRange(e.room.hostiles,{filter:e=>_.some(e.body,e=>e.type==ATTACK||e.type==RANGED_ATTACK)}))return t;if(t=e.pos.findClosestByPath(FIND_HOSTILE_STRUCTURES,{filter:e=>e.structureType==STRUCTURE_TOWER}))return t;if(t=e.pos.findClosestByRange(e.room.hostiles))return t;if(t=e.pos.findClosestByPath(FIND_HOSTILE_STRUCTURES,{filter:e=>e.structureType==STRUCTURE_SPAWN}))return t;if(t=e.pos.findClosestByPath(FIND_HOSTILE_STRUCTURES,{filter:e=>e.structureType!=STRUCTURE_CONTROLLER}))return t;if(t=e.pos.findClosestByPath(FIND_HOSTILE_CONSTRUCTION_SITES))return t}return r.remove(),null}),this.step=(e=>{CHATTY&&e.say(this.name),e.target instanceof Flag&&e.target.pos.roomName==e.pos.roomName&&this.assign(e),this.run[e.data.creepType](e)}),this.run={melee:e=>{if(!e.flee){if(e.target instanceof Flag)return void e.travelTo(e.target);if(e.target instanceof ConstructionSite)return void e.travelTo(e.target,{range:0});e.travelTo(e.target)}e.target.my||(e.attacking=e.attack(e.target)==OK)},ranger:e=>{let t=e.pos.getRangeTo(e.target);if(!e.flee){if(e.target instanceof Flag)return void e.travelTo(e.target);if(e.target instanceof ConstructionSite)return void e.travelTo(e.target,{range:0});t>3&&e.travelTo(e.target),t<3&&e.move(e.target.pos.getDirectionTo(e))}let r=e.pos.findInRange(e.room.hostiles,3);if(r.length>2)return CHATTY&&e.say("MassAttack"),void(e.attackingRanged=e.rangedMassAttack()==OK);t<4?e.attackingRanged=e.rangedAttack(e.target)==OK:r.length>0&&(e.attackingRanged=e.rangedAttack(r[0])==OK)}},this.setDefault({moveOptions:e=>(_.isUndefined(e.allowHostile)&&(e.allowHostile=!0),e)})}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(0);t.default=new class extends o.CreepAction{constructor(){super("mining"),this.renewTarget=!0,this.isValidTarget=((e,t)=>e&&(e instanceof Source||e instanceof Mineral&&!e.ticksToRegeneration)),this.isAddableAction=(e=>{const t=e.room;return t.my||t.myReservation||!t.owner&&!t.reservation}),this.isAddableTarget=((e,t)=>!e.targetOf||!_.some(e.targetOf,e=>{const r=e.predictedRenewal?e.predictedRenewal:e.spawningTime;return e.creepType===t.data.creepType&&e.ttl>r})),this.newTarget=(e=>{const t=e.getStrategyHandler([this.name],"newTarget",e);return t&&this.determineSpot(e,t),t}),this.determineSpot=((e,t)=>{const r=[];_.forEach(Memory.population,t=>{if(t.name===e.name)return;const o=t.predictedRenewal?t.predictedRenewal:t.spawningTime;t.roomName===e.pos.roomName&&["miner","upgrader"].includes(t.creepType)&&t.determinatedSpot&&t.ttl>o&&r.push(t.determinatedSpot)});const o=t.container&&t.container.structureType===STRUCTURE_CONTAINER&&t.container.pos.isNearTo(t)&&!_.some(r,{x:t.container.pos.x,y:t.container.pos.y})?t.container.pos:null;let a,i=[];if(o||(a={spots:[{pos:t.pos,range:1}],checkWalkable:!0,where:e=>!_.some(r,{x:e.x,y:e.y}),roomName:e.pos.roomName},t.container&&a.spots.push({pos:t.container.pos,range:1}),!e.remote&&t.link&&a.spots.push({pos:t.link.pos,range:1}),i=RoomManager.fieldsInRange(a)),o||i.length>0){let r=o;if(r||(r=e.pos.findClosestByPath(i,{filter:t=>!_.some(e.room.lookForAt(LOOK_STRUCTURES,t),{structureType:STRUCTURE_ROAD})})),r||(r=e.pos.findClosestByPath(i)||i[0]),r){if(e.data.determinatedSpot={x:r.x,y:r.y},!e.remote){const t=Game.spawns[e.data.motherSpawn];if(t){const o=r.findPathTo(t,{ignoreCreeps:!0});o&&(e.data.predictedRenewal=e.data.spawningTime+o.length)}}MINERS_AUTO_BUILD&&!t.container&&!_.filter(t.pos.findInRange(FIND_CONSTRUCTION_SITES,2),e=>e.structureType===STRUCTURE_CONTAINER).length&&t.room&&t.room.createConstructionSite(r,STRUCTURE_CONTAINER)}}e.data.determinatedSpot||Log.error("Unable to determine working location for miner in room "+e.pos.roomName)}),this.work=(e=>{if(0===e.target.energy||e.target.cooldown>0)this.maintain(e);else{if(!(e.target instanceof Mineral&&e.target.ticksToRegeneration>0)){this.resetChecks(e);const t=e.carryCapacity-(e.data.body&&e.data.body.work?2*e.data.body.work:e.carryCapacity/2);if(e.sum>t)if(e.target.link&&e.target.link.energy<e.target.link.energyCapacity)e.transfer(e.target.link,RESOURCE_ENERGY);else if(e.target.container&&e.target.container.sum<e.target.container.storeCapacity){const t=t=>{e.carry[t]>0&&e.transfer(e.target.container,t)};_.forEach(Object.keys(e.carry),t)}else{CHATTY&&e.say("dropmining",SAY_PUBLIC),OOPS&&e.say(String.fromCharCode(8681),SAY_PUBLIC);const t=t=>{e.carry[t]>0&&e.drop(t)};_.forEach(Object.keys(e.carry),t)}return e.harvest(e.target)}this.resetChecks(e),this.unassign(e)}}),this.resetChecks=(e=>{delete e.data.repairChecked,delete e.data.repairTarget,delete e.data.buildChecked,delete e.data.buildTarget,delete e.data.energyChecked}),this.step=(e=>{if(_.isUndefined(e.data.determinatedSpot))this.determineSpot(e,e.target);else{const t=e.data.destiny?e.data.destiny.room:e.data.homeRoom,r=new RoomPosition(e.data.determinatedSpot.x,e.data.determinatedSpot.y,t),o=e.pos.getRangeTo(r);o>1?e.travelTo(r,{range:1}):1===o?r.lookFor(LOOK_CREEPS).length>0||e.move(e.pos.getDirectionTo(r)):this.work(e)}}),this.getEnergy=(e=>{const t=e.pos.findInRange(FIND_DROPPED_RESOURCES,1,{filter:e=>e.resourceType===RESOURCE_ENERGY})[0];if(t)return LOG_TRACE&&Log.trace("Action",{actionName:this.name,method:"getEnergy",creepName:e.name,pos:e.pos,pickup:t.id}),e.pickup(t),!0;const r=e.pos.findInRange(FIND_STRUCTURES,1,{filter:e=>e.structureType===STRUCTURE_CONTAINER})[0];if(r&&r.sum>0)return LOG_TRACE&&Log.trace("Action",{actionName:this.name,method:"getEnergy",creepName:e.name,pos:e.pos,withdrawCon:r.id}),e.withdraw(r,RESOURCE_ENERGY),!0;const o=e.pos.findInRange(FIND_STRUCTURES,1,{filter:e=>e.my&&e.structureType===STRUCTURE_LINK})[0];return o&&o.energy>0?(LOG_TRACE&&Log.trace("Action",{actionName:this.name,method:"getEnergy",creepName:e.name,pos:e.pos,withdrawLink:o.id}),e.withdraw(o,RESOURCE_ENERGY),!0):(LOG_TRACE&&Log.trace("Action",{actionName:this.name,method:"getEnergy",creepName:e.name,pos:e.pos,result:"no energy"}),e.data.energyChecked=Game.time,!1)}),this.maintain=(e=>{const t=e.data.body&&e.data.body.work?5*e.data.body.work:e.carryCapacity/2;if(LOG_TRACE&&Log.trace("Action",{actionName:this.name,method:"maintain",creepName:e.name,pos:e.pos,energy:e.carryenergy,minCarry:t}),e.carry.energy<=t&&(!e.data.energyChecked||Game.time-e.data.energyChecked>MINER_WORK_THRESHOLD)&&this.getEnergy(e),e.carry.energy>0){if(!e.data.repairChecked||Game.time-e.data.repairChecked>MINER_WORK_THRESHOLD){let t=Game.getObjectById(e.data.repairTarget);if(t&&t.hits!==t.hitsMax||(t=e.pos.findInRange(FIND_STRUCTURES,3,{filter:e=>(e.structureType===STRUCTURE_CONTAINER||e.structureType===STRUCTURE_ROAD)&&e.hits<e.hitsMax})[0]),t)return e.data.repairTarget=t.id,LOG_TRACE&&Log.trace("Action",{actionName:this.name,method:"maintain",creepName:e.name,pos:e.pos,repairTarget:t.id,progress:t.hits/t.hitsMax}),e.repair(t);delete e.data.repairTarget,e.data.repairChecked=Game.time}if(!e.data.buildChecked||Game.time-e.data.buildChecked>MINER_WORK_THRESHOLD){let t=Game.getObjectById(e.data.buildTarget);if(t&&t.progress!==t.progressTotal||(t=e.pos.findInRange(e.room.myConstructionSites,3,{filter:e=>(e.structureType===STRUCTURE_CONTAINER||e.structureType===STRUCTURE_ROAD)&&e.progress<e.progressTotal})[0]),t)return e.data.buildTarget=t.id,LOG_TRACE&&Log.trace("Action",{actionName:this.name,method:"maintain",creepName:e.name,pos:e.pos,buildTarget:t.id,progress:t.progress/t.progressTotal}),e.build(t);delete e.data.buildTarget,e.data.buildChecked=Game.time}}return!1}),this.setDefault({newTarget:e=>_(e.room.sources).sortBy(t=>e.pos.getRangeTo(t)).find(t=>this.isValidTarget(t,e)&&this.isAddableTarget(t,e))||null})}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(0);t.default=new class extends o.CreepAction{constructor(){super("picking"),this.maxPerAction=4,this.maxPerTarget=2,this.isValidAction=(e=>e.sum<e.carryCapacity),this.isValidTarget=(e=>null!=e&&null!=e.amount&&e.amount>0),this.isAddableAction=(e=>e.data.creepType.indexOf("remote")>0||this.maxPerAction===1/0||!e.room.population||!e.room.population.actionCount[this.name]||e.room.population.actionCount[this.name]<this.maxPerAction),this.isAddableTarget=((e,t)=>{let r;r=t.data.creepType.indexOf("remote")>0?1/0:this.maxPerTarget;let o=e.targetOf?_.filter(e.targetOf,{actionName:"picking"}):[];return!e.targetOf||!o.length||o.length<r&&e.amount>_.sum(o.map(e=>e.carryCapacityLeft))}),this.newTarget=(e=>{const t=this.getStrategy("energyOnly",e)?_.filter(e.room.droppedResources,{resourceType:RESOURCE_ENERGY}):e.room.droppedResources;let r;return r=e.room.my&&e.room.situation.invasion?t=>this.isAddableTarget(t,e)&&t.pos.findInRange(e.room.sources,1).length>0:t=>this.isAddableTarget(t,e),e.pos.findClosestByPath(t,{filter:r})}),this.work=(e=>{let t=e.pickup(e.target);if(t==OK){if(e.sum<.8*e.carryCapacity){let r=e.pos.findInRange(e.room.droppedResources,1,{filter:t=>t.resourceType!=RESOURCE_ENERGY&&this.isAddableTarget(t,e)});if((!r||r.length<1)&&(r=e.pos.findInRange(e.room.droppedResources,1,{filter:t=>this.isAddableTarget(t,e)})),r&&r.length>0)return this.assign(e,r[0]),t}if(e.sum<e.carryCapacity){let r=e.pos.findInRange(e.room.structures.container.in,2,{filter:t=>CreepManager.action.uncharging.isValidTarget(t,e)});if(r&&r.length>0)return CreepManager.action.uncharging.assign(e,r[0]),t}delete e.data.actionName,delete e.data.targetId}return t}),this.setDefault({energyOnly:!0})}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(0);t.default=new class extends o.CreepAction{constructor(){super("reallocating"),this.getLabOrder=(e=>{if(!e)return null;let t=null,r=e.room;if(!r.memory||!r.memory.resources)return null;let o=r.memory.resources.lab.find(t=>t.id==e.id);if(o){let e=o.orders;for(let r=0;r<e.length;r++)if(e[r].type!=RESOURCE_ENERGY&&(e[r].orderRemaining>0||e[r].storeAmount>0)){t=e[r];break}}return t}),this.findNeeding=((e,t,r,o)=>{r||(r=1);const a=e.structures.labs.all;if(a.length>0)for(let e=0;e<a.length;e++){const i=Game.getObjectById(a[e].id);let n=0;if(i&&(n=i.getNeeds(t)),n>=r&&(0===i.mineralAmount||i.mineralType==t||t==RESOURCE_ENERGY)&&i.id!=o)return{structure:i,amount:n}}const i=e.structures.powerSpawns.all;if(i.length>0)for(let e=0;e<i.length;e++){const a=Game.getObjectById(i[e].id);let n=0;if(a&&(n=a.getNeeds(t)),n>=r&&(t==RESOURCE_POWER||t==RESOURCE_ENERGY)&&a.id!=o)return{structure:a,amount:n}}const n=e.structures.nukers.all;if(n.length>0)for(let e=0;e<n.length;e++){const a=Game.getObjectById(n[e].id);let i=0;if(a&&(i=a.getNeeds(t)),i>=r&&(t==RESOURCE_GHODIUM||t==RESOURCE_ENERGY)&&a.id!=o)return{structure:a,amount:i}}const s=e.structures.container.all;if(s.length>0)for(let e=0;e<s.length;e++){const a=Game.getObjectById(s[e].id);let i=0;if(a&&(i=a.getNeeds(t)),i>=r&&a.id!=o)return{structure:a,amount:i}}const l=e.terminal;if(l&&l.active){let e=l.getNeeds(t);if(e>=r&&l.id!=o)return{structure:l,amount:e}}let m=e.storage;if(m&&m.active){let e=m.getNeeds(t);if(e>=r&&m.id!=o)return{structure:m,amount:e}}return m&&m.active&&(t==RESOURCE_ENERGY||t==RESOURCE_POWER)&&m.storeCapacity-m.sum>r?{structure:m,amount:0}:l&&l.active&&t!=RESOURCE_ENERGY&&t!=RESOURCE_POWER&&l.storeCapacity-l.sum>r?{structure:l,amount:0}:null}),this.newTargetLab=(e=>{let t=e.room,r=t.memory;if(r&&r.labs&&r.labs.length>0)for(let o=0;o<r.labs.length;o++){let a=r.labs[o],i=Game.getObjectById(a.id);if(!i)continue;let n=0;if(i.mineralAmount>0){if((n=i.getNeeds(i.mineralType))<0){let r;if(LOG_TRACE&&Log.trace("Action",{actionName:"reallocating",roomName:t.name,creepName:e.name,structureId:i.id,resourceType:i.mineralType,needs:n}),r=this.findNeeding(t,i.mineralType))return LOG_TRACE&&Log.trace("Action",{actionName:"reallocating",roomName:t.name,creepName:e.name,targetStructureId:r.structure.id,resourceType:i.mineralType,targetNeeds:r.amount}),i}if(n>0){if(LOG_TRACE&&Log.trace("Action",{actionName:"reallocating",roomName:t.name,creepName:e.name,structureId:i.id,resourceType:i.mineralType,needs:n}),t.storage&&t.storage.active&&t.storage.store[i.mineralType])return LOG_TRACE&&Log.trace("Action",{actionName:"reallocating",roomName:t.name,creepName:e.name,targetStructureId:t.storage.id,resourceType:i.mineralType,targetNeeds:t.storage.store[i.mineralType]}),e.data.reallocating=i.mineralType,t.storage;if(t.terminal&&t.terminal.active&&t.terminal.getNeeds(i.mineralType)<0)return LOG_TRACE&&Log.trace("Action",{actionName:"reallocating",roomName:t.name,creepName:e.name,targetStructureId:t.terminal.id,resourceType:i.mineralType,targetNeeds:t.terminal.store[i.mineralType]}),e.data.reallocating=i.mineralType,t.terminal;let r=t.findContainerWith(i.mineralType);if(r)return LOG_TRACE&&Log.trace("Action",{actionName:"reallocating",roomName:t.name,creepName:e.name,targetStructureId:r.structure.id,resourceType:i.mineralType,targetNeeds:r.amount}),e.data.reallocating=i.mineralType,r.structure;!ROOM_TRADING||MAKE_COMPOUNDS||ALLOCATE_COMPOUNDS||i.mineralType==RESOURCE_ENERGY||i.mineralType==t.mineralType||_.some(t.memory.resources.orders,{type:i.mineralType})||t.placeRoomOrder(i.id,i.mineralType,n)}}else{let r=this.getLabOrder(i),o=null;if(r){o=r.type;let a=r.orderRemaining+r.storeAmount;if(LOG_TRACE&&Log.trace("Action",{actionName:"reallocating",roomName:t.name,creepName:e.name,structureId:i.id,resourceType:o,needs:a}),t.storage&&t.storage.active&&t.storage.store[o])return LOG_TRACE&&Log.trace("Action",{actionName:"reallocating",roomName:t.name,creepName:e.name,targetStructureId:t.storage.id,resourceType:o,targetNeeds:t.storage.store[o]}),e.data.reallocating=o,t.storage;if(t.terminal&&t.terminal.active&&t.terminal.getNeeds(o)<0)return LOG_TRACE&&Log.trace("Action",{actionName:"reallocating",roomName:t.name,creepName:e.name,targetStructureId:t.terminal.id,resourceType:o,targetNeeds:t.terminal.store[o]}),e.data.reallocating=o,t.terminal;let n=t.findContainerWith(o);if(n)return LOG_TRACE&&Log.trace("Action",{actionName:"reallocating",roomName:t.name,creepName:e.name,targetStructureId:n.structure.id,resourceType:o,targetNeeds:n.amount}),e.data.reallocating=o,n.structure;!ROOM_TRADING||MAKE_COMPOUNDS||ALLOCATE_COMPOUNDS||o==RESOURCE_ENERGY||o==t.mineralType||_.some(t.memory.resources.orders,{type:i.mineralType})||t.placeRoomOrder(i.id,o,r.orderRemaining)}}if((n=i.getNeeds(RESOURCE_ENERGY))<0){LOG_TRACE&&Log.trace("Action",{actionName:"reallocating",roomName:t.name,creepName:e.name,structureId:i.id,resourceType:RESOURCE_ENERGY,needs:n});let r=this.findNeeding(t,RESOURCE_ENERGY);if(r)return LOG_TRACE&&Log.trace("Action",{actionName:"reallocating",roomName:t.name,creepName:e.name,targetStructureId:r.structure.id,resourceType:RESOURCE_ENERGY,targetNeeds:r.amount}),i}if(n>0){if(LOG_TRACE&&Log.trace("Action",{actionName:"reallocating",roomName:t.name,creepName:e.name,structureId:i.id,resourceType:RESOURCE_ENERGY,needs:n}),t.storage&&t.storage.active&&t.storage.charge>.5)return LOG_TRACE&&Log.trace("Action",{actionName:"reallocating",roomName:t.name,creepName:e.name,targetStructureId:t.storage.id,resourceType:RESOURCE_ENERGY,targetNeeds:t.storage.store[RESOURCE_ENERGY]}),e.data.reallocating=RESOURCE_ENERGY,t.storage;if(t.terminal&&t.terminal.active&&t.terminal.getNeeds(RESOURCE_ENERGY)<0)return LOG_TRACE&&Log.trace("Action",{actionName:"reallocating",roomName:t.name,creepName:e.name,targetStructureId:t.terminal.id,resourceType:RESOURCE_ENERGY,targetNeeds:t.terminal.store[RESOURCE_ENERGY]}),e.data.reallocating=RESOURCE_ENERGY,t.terminal;let r=t.findContainerWith(RESOURCE_ENERGY);if(r)return LOG_TRACE&&Log.trace("Action",{actionName:"reallocating",roomName:t.name,creepName:e.name,targetStructureId:r.structure.id,resourceType:RESOURCE_ENERGY,targetNeeds:r.amount}),e.data.reallocating=RESOURCE_ENERGY,r.structure}}return null}),this.newTargetPowerSpawn=(e=>{const t=e.room,r=t.structures.powerSpawns.all;if(r.length>0)for(let o=0;o<r.length;o++){const a=Game.getObjectById(r[o].id);if(!a)continue;let i=0;if((i=a.getNeeds(RESOURCE_ENERGY))>0){if(LOG_TRACE&&Log.trace("Action",{actionName:"reallocating",roomName:t.name,creepName:e.name,structureId:a.id,resourceType:RESOURCE_ENERGY,needs:i}),t.storage&&t.storage.active&&t.storage.charge>.5)return LOG_TRACE&&Log.trace("Action",{actionName:"reallocating",roomName:t.name,creepName:e.name,targetStructureId:t.storage.id,resourceType:RESOURCE_ENERGY,targetNeeds:t.storage.store[RESOURCE_ENERGY]}),e.data.reallocating=RESOURCE_ENERGY,t.storage;if(t.terminal&&t.terminal.active&&t.terminal.getNeeds(RESOURCE_ENERGY)<0)return LOG_TRACE&&Log.trace("Action",{actionName:"reallocating",roomName:t.name,creepName:e.name,targetStructureId:t.terminal.id,resourceType:RESOURCE_ENERGY,targetNeeds:t.terminal.store[RESOURCE_ENERGY]}),e.data.reallocating=RESOURCE_ENERGY,t.terminal;let r=t.findContainerWith(RESOURCE_ENERGY);if(r)return LOG_TRACE&&Log.trace("Action",{actionName:"reallocating",roomName:t.name,creepName:e.name,targetStructureId:r.structure.id,resourceType:RESOURCE_ENERGY,targetNeeds:r.amount}),e.data.reallocating=RESOURCE_ENERGY,r.structure}if((i=a.getNeeds(RESOURCE_POWER))>0){if(LOG_TRACE&&Log.trace("Action",{actionName:"reallocating",roomName:t.name,creepName:e.name,structureId:a.id,resourceType:RESOURCE_POWER,needs:i}),t.storage&&t.storage.active&&t.storage.store[RESOURCE_POWER])return LOG_TRACE&&Log.trace("Action",{actionName:"reallocating",roomName:t.name,creepName:e.name,targetStructureId:t.storage.id,resourceType:RESOURCE_POWER,targetNeeds:t.storage.store[RESOURCE_POWER]}),e.data.reallocating=RESOURCE_POWER,t.storage;if(t.terminal&&t.terminal.active&&t.terminal.getNeeds(RESOURCE_POWER)<0)return LOG_TRACE&&Log.trace("Action",{actionName:"reallocating",roomName:t.name,creepName:e.name,targetStructureId:t.terminal.id,resourceType:RESOURCE_POWER,targetNeeds:t.terminal.store[RESOURCE_POWER]}),e.data.reallocating=RESOURCE_POWER,t.terminal;let r=t.findContainerWith(RESOURCE_POWER);if(r)return LOG_TRACE&&Log.trace("Action",{actionName:"reallocating",roomName:t.name,creepName:e.name,targetStructureId:r.structure.id,resourceType:RESOURCE_POWER,targetNeeds:r.amount}),e.data.reallocating=RESOURCE_POWER,r.structure}}return null}),this.newTargetNuker=(e=>{const t=e.room,r=t.structures.nukers.all;if(r.length>0)for(var o=0;o<r.length;o++){const i=Game.getObjectById(r[o].id);if(i){var a=0;if((a=i.getNeeds(RESOURCE_ENERGY))>0){if(LOG_TRACE&&Log.trace("Action",{actionName:"reallocating",roomName:t.name,creepName:e.name,structureId:i.id,resourceType:RESOURCE_ENERGY,needs:a}),t.storage&&t.storage.active&&t.storage.charge>.5)return LOG_TRACE&&Log.trace("Action",{actionName:"reallocating",roomName:t.name,creepName:e.name,targetStructureId:t.storage.id,resourceType:RESOURCE_ENERGY,targetNeeds:t.storage.store[RESOURCE_ENERGY]}),e.data.reallocating=RESOURCE_ENERGY,t.storage;if(t.terminal&&t.terminal.active&&t.terminal.getNeeds(RESOURCE_ENERGY)<0)return LOG_TRACE&&Log.trace("Action",{actionName:"reallocating",roomName:t.name,creepName:e.name,targetStructureId:t.terminal.id,resourceType:RESOURCE_ENERGY,targetNeeds:t.terminal.store[RESOURCE_ENERGY]}),e.data.reallocating=RESOURCE_ENERGY,t.terminal;let r=t.findContainerWith(RESOURCE_ENERGY);if(r)return LOG_TRACE&&Log.trace("Action",{actionName:"reallocating",roomName:t.name,creepName:e.name,targetStructureId:r.structure.id,resourceType:RESOURCE_ENERGY,targetNeeds:r.amount}),e.data.reallocating=RESOURCE_ENERGY,r.structure}if((a=i.getNeeds(RESOURCE_GHODIUM))>0){if(LOG_TRACE&&Log.trace("Action",{actionName:"reallocating",roomName:t.name,creepName:e.name,structureId:i.id,resourceType:RESOURCE_GHODIUM,needs:a}),t.storage&&t.storage.active&&t.storage.store[RESOURCE_GHODIUM])return LOG_TRACE&&Log.trace("Action",{actionName:"reallocating",roomName:t.name,creepName:e.name,targetStructureId:t.storage.id,resourceType:RESOURCE_GHODIUM,targetNeeds:t.storage.store[RESOURCE_GHODIUM]}),e.data.reallocating=RESOURCE_GHODIUM,t.storage;if(t.terminal&&t.terminal.active&&t.terminal.getNeeds(RESOURCE_GHODIUM)<0)return LOG_TRACE&&Log.trace("Action",{actionName:"reallocating",roomName:t.name,creepName:e.name,targetStructureId:t.terminal.id,resourceType:RESOURCE_GHODIUM,targetNeeds:t.terminal.store[RESOURCE_GHODIUM]}),e.data.reallocating=RESOURCE_GHODIUM,t.terminal;let r=t.findContainerWith(RESOURCE_GHODIUM);if(r)return LOG_TRACE&&Log.trace("Action",{actionName:"reallocating",roomName:t.name,creepName:e.name,targetStructureId:r.structure.id,resourceType:RESOURCE_GHODIUM,targetNeeds:r.amount}),e.data.reallocating=RESOURCE_GHODIUM,r.structure}}}return null}),this.newTargetContainer=(e=>{const t=e.room,r=t.structures.container.all;if(r.length>0)for(let o=0;o<r.length;o++){const a=Game.getObjectById(r[o].id);if(a){for(let r in a.store){let o=a.getNeeds(r);if(r&&o<0){LOG_TRACE&&Log.trace("Action",{actionName:"reallocating",roomName:t.name,creepName:e.name,structureId:a.id,resourceType:r,needs:o});let i=this.findNeeding(t,r);if(i)return LOG_TRACE&&Log.trace("Action",{actionName:"reallocating",roomName:t.name,creepName:e.name,targetStructureId:i.structure.id,resourceType:r,targetNeeds:i.amount}),e.data.reallocating=r,a}}if(t.memory.resources){let r=t.memory.resources.container.find(e=>e.id==a.id);if(r){let o=r.orders;for(let r=0;r<o.length;r++){let i=o[r].type,n=a.getNeeds(i);if(n>0){if(LOG_TRACE&&Log.trace("Action",{actionName:"reallocating",roomName:t.name,creepName:e.name,structureId:a.id,resourceType:resource,needs:n}),t.storage&&t.storage.active&&t.storage.store[i]&&!(i==RESOURCE_ENERGY&&t.storage.charge<.5))return LOG_TRACE&&Log.trace("Action",{actionName:"reallocating",roomName:t.name,creepName:e.name,targetStructureId:t.storage.id,resourceType:resource,targetNeeds:t.storage.store[resource]}),e.data.reallocating=resource,t.storage;if(t.terminal&&t.terminal.active&&t.terminal.getNeeds(i)<0)return LOG_TRACE&&Log.trace("Action",{actionName:"reallocating",roomName:t.name,creepName:e.name,targetStructureId:t.terminal.id,resourceType:resource,targetNeeds:t.terminal.store[resource]}),e.data.reallocating=resource,t.terminal}}}}}}return null}),this.newTargetTerminal=(e=>{let t=e.room,r=e.room.terminal;if(r&&r.active){for(let o in r.store){let a=-r.getNeeds(o);if(a>0){LOG_TRACE&&Log.trace("Action",{actionName:"reallocating",roomName:t.name,creepName:e.name,structureId:r.id,resourceType:o,needs:-a});let i=this.findNeeding(t,o,1,r.id);if(i&&i.structure.id!=r.id)return LOG_TRACE&&Log.trace("Action",{actionName:"reallocating",roomName:t.name,creepName:e.name,targetStructureId:i.structure.id,resourceType:o,targetNeeds:i.amount}),e.data.reallocating=o,r}}if(t.memory.resources&&t.memory.resources.terminal[0]){let o=t.memory.resources.terminal[0].orders.slice();o.push(RESOURCE_ENERGY);let a=null,i=0;for(let n=0;n<o.length;n++)if(a=o[n].type,(i=r.getNeeds(a))>0&&(LOG_TRACE&&Log.trace("Action",{actionName:"reallocating",roomName:t.name,creepName:e.name,structureId:r.id,resourceType:a,needs:i}),t.storage&&t.storage.active&&t.storage.store[a]&&!(a==RESOURCE_ENERGY&&t.storage.charge<.5)))return LOG_TRACE&&Log.trace("Action",{actionName:"reallocating",roomName:t.name,creepName:e.name,targetStructureId:t.storage.id,resourceType:a,targetNeeds:t.storage.store[a]}),e.data.reallocating=a,t.storage}}return null}),this.newTargetStorage=(e=>{let t=e.room,r=e.room.storage;if(r&&r.active)for(let o in r.store){let a=-r.getNeeds(o);if(o&&a>0){LOG_TRACE&&Log.trace("Action",{actionName:"reallocating",roomName:t.name,creepName:e.name,structureId:r.id,resourceType:o,needs:-a});let i=this.findNeeding(t,o,1,r.id);if(i)return LOG_TRACE&&Log.trace("Action",{actionName:"reallocating",roomName:t.name,creepName:e.name,targetStructureId:i.structure.id,resourceType:o,targetNeeds:i.amount}),e.data.reallocating=o,r}}return null}),this.isValidAction=(e=>!0),this.isValidTarget=(e=>!0),this.isAddableAction=(e=>{let t=e.room.population;return 0==e.sum&&(!t||!t.actionCount[this.name]||t.actionCount[this.name]<this.maxPerAction)}),this.isAddableTarget=(e=>!0),this.newTarget=(e=>{let t=e.room;LOG_TRACE&&Log.trace("Action",{actionName:"reallocating",roomName:t.name,creepName:e.name,subAction:"newTarget"});let r=null;if(0==e.sum)return t.memory&&(null===(r=this.newTargetLab(e))&&(r=this.newTargetPowerSpawn(e)),null===r&&(r=this.newTargetNuker(e)),null===r&&(r=this.newTargetContainer(e)),null===r&&(r=this.newTargetTerminal(e)),null===r&&(r=this.newTargetStorage(e))),r;{let r=Object.keys(e.carry)[0],o=this.findNeeding(t,r);return LOG_TRACE&&Log.trace("Action",{actionName:"reallocating",roomName:t.name,creepName:e.name,subAction:"assignDropOff",targetStructureId:o.structure.id,resourceType:r,targetNeeds:o.amount}),o?o.structure:null}}),this.cancelAction=(e=>{delete e.data.actionName,delete e.data.targetId,e.action=null,e.target=null,delete e.data.path}),this.unloadStructure=((e,t,r,o)=>{let a=Math.min(o,e.carryCapacity-e.sum),i=e.withdraw(t,r,a);return LOG_TRACE&&Log.trace("Action",{actionName:"reallocating",roomName:e.room.name,creepName:e.name,subAction:"unloadStructure",structureId:t.id,resourceType:r,amount:a,result:i}),i}),this.loadStructure=((e,t,r,o)=>{let a=null,i=e.room,n=Math.min(o,e.carry[r]||0);if(n>0&&(a=e.transfer(t,r,n)),a==OK){let e=null;if(i.memory.resources&&(e=i.memory.resources[t.structureType].find(e=>e.id==t.id)),e&&e.orders){let t=e.orders.find(e=>e.type==r);t&&t.orderRemaining>0&&(t.orderRemaining-=n)}}return LOG_TRACE&&Log.trace("Action",{actionName:"reallocating",roomName:e.room.name,creepName:e.name,subAction:"loadStructure",structureId:t.id,resourceType:r,amount:n,result:a}),a}),this.assignDropOff=((e,t)=>{let r=this.findNeeding(e.room,t,1,e.target.id);r&&(LOG_TRACE&&Log.trace("Action",{actionName:"reallocating",roomName:e.room.name,creepName:e.name,subAction:"assignDropOff",targetStructureId:r.structure.id,resourceType:t,amount:r.amount}),this.assign(e,r.structure))}),this.unloadLab=(e=>{let t=e.target,r=null,o=null,a=0;return(a=-t.getNeeds(RESOURCE_ENERGY))>0&&(o=RESOURCE_ENERGY),o||(a=-t.getNeeds(t.mineralType))>0&&(o=t.mineralType),o&&(r=this.unloadStructure(e,t,o,a)),LOG_TRACE&&Log.trace("Action",{actionName:"reallocating-unloadLab",roomName:room.name,creepName:e.name,structureId:t.id,resourceType:o,needs:a,workResult:r}),r==OK?this.assignDropOff(e,o):this.cancelAction(e),r}),this.unloadContainer=(e=>{let t=e.target,r=null,o=null,a=0,i=Object.keys(t.store);e.data.reallocating&&(i.unshift(e.data.reallocating),delete e.data.reallocating);for(let e=0;e<i.length;e++){let r=i[e];if(r&&t.store[r]>0&&(t.structureType==STRUCTURE_LAB||t.getNeeds(r)<0)){let e=this.findNeeding(room,r,1,t.id);if(e&&(a=e.amount),a>0){o=r;break}if(storage&&storage.active&&e&&e.structure.structureType==STRUCTURE_STORAGE&&r==RESOURCE_ENERGY){a=storage.storeCapacity-storage.sum,o=r;break}}}return o&&(r=this.unloadStructure(e,t,o,a)),LOG_TRACE&&Log.trace("Action",{actionName:"reallocating-unloadContainer",roomName:room.name,creepName:e.name,structureId:t.id,resourceType:o,needs:a,workResult:r}),r==OK?this.assignDropOff(e,o):this.cancelAction(e),r}),this.unloadTerminal=(e=>{let t=e.target,r=e.room,o=r.storage,a=null,i=null,n=0,s=Object.keys(t.store);e.data.reallocating&&(s.unshift(e.data.reallocating),delete e.data.reallocating);for(let e=0;e<s.length;e++){let a=s[e];if(a&&t.store[a]>0&&(t.structureType==STRUCTURE_LAB||t.getNeeds(a)<0)){let e=this.findNeeding(r,a,1,t.id);if(e&&(n=e.amount),n>0){i=a;break}if(o&&o.active&&e&&e.structure.structureType==STRUCTURE_STORAGE&&a==RESOURCE_ENERGY){n=o.storeCapacity-o.sum,i=a;break}}}return i&&(n=Math.min(n,t.store[i]||0,e.carryCapacity-e.sum),a=this.unloadStructure(e,t,i,n)),LOG_TRACE&&Log.trace("Action",{actionName:"reallocating-unloadTerminal",roomName:r.name,creepName:e.name,structureId:t.id,resourceType:i,needs:n,workResult:a}),a==OK?this.assignDropOff(e,i):this.cancelAction(e),a}),this.unloadStorage=(e=>{let t=e.target,r=e.room,o=r.terminal,a=null,i=null,n=0,s=Object.keys(t.store);e.data.reallocating&&(s.unshift(e.data.reallocating),delete e.data.reallocating);for(let a=0;a<s.length;a++){let l=s[a];if(l&&t.store[l]>0){if(l==RESOURCE_ENERGY&&t.charge<.5)continue;let a=this.findNeeding(r,l,1,t.id);if(LOG_TRACE&&Log.trace("Action",{actionName:"reallocating",subAction:"findNeeding",roomName:r.name,creepName:e.name,structureId:a&&a.structure.id,resourceType:l,amount:a&&a.amount}),a&&a.structure.id==t.id&&(a=null),a&&(n=a.amount),n>0){i=l;break}if(o&&o.active&&a&&a.structure.structureType==STRUCTURE_TERMINAL&&l!=RESOURCE_ENERGY&&l!=RESOURCE_POWER){n=o.storeCapacity-o.sum,i=l;break}}}return i&&(n=Math.min(n,t.store[i]||0,e.carryCapacity-e.sum),a=this.unloadStructure(e,t,i,n)),LOG_TRACE&&Log.trace("Action",{actionName:"reallocating-unloadStorage",roomName:r.name,creepName:e.name,structureId:t.id,resourceType:i,needs:n,workResult:a}),a==OK?this.assignDropOff(e,i):this.cancelAction(e),a}),this.loadLab=(e=>{let t=e.target,r=e.room,o=null,a=null,i=0;if((i=t.getNeeds(RESOURCE_ENERGY))>0&&(e.carry.energy||0)>0)a=RESOURCE_ENERGY;else{let r=this.getLabOrder(t);r&&(a=r.type),(i=t.getNeeds(a))>0&&(e.carry[a]||0)>0||(a=null)}return a&&(o=this.loadStructure(e,t,a,i)),LOG_TRACE&&Log.trace("Action",{actionName:"reallocating-loadLab",roomName:r.name,creepName:e.name,structureId:t.id,resourceType:a,needs:i,workResult:o}),(e.carry[a]||0)>1?this.assignDropOff(e,a):this.cancelAction(e),o}),this.loadPowerSpawn=(e=>{let t=e.target,r=e.room,o=null,a=null,i=0;return r.memory.resources&&void 0===r.memory.resources.powerSpawn&&(r.memory.resources.powerSpawn=[]),(i=t.getNeeds(RESOURCE_ENERGY))>0&&(e.carry.energy||0)>0?a=RESOURCE_ENERGY:(i=t.getNeeds(RESOURCE_POWER))>0&&(e.carry[RESOURCE_POWER]||0)>0&&(a=RESOURCE_POWER),a&&(o=this.loadStructure(e,t,a,i)),LOG_TRACE&&Log.trace("Action",{actionName:"reallocating-loadPowerSpawn",roomName:r.name,creepName:e.name,structureId:t.id,resourceType:a,needs:i,workResult:o}),(e.carry[a]||0)>i?this.assignDropOff(e,a):this.cancelAction(e),o}),this.loadNuker=(e=>{let t=e.target,r=e.room;var o=null,a=null,i=0;return r.memory.resources&&void 0===r.memory.resources.nuker&&(r.memory.resources.nuker=[]),(i=t.getNeeds(RESOURCE_ENERGY))>0&&(e.carry.energy||0)>0?a=RESOURCE_ENERGY:(i=t.getNeeds(RESOURCE_GHODIUM))>0&&(e.carry[RESOURCE_GHODIUM]||0)>0&&(a=RESOURCE_GHODIUM),a&&(o=this.loadStructure(e,t,a,i)),LOG_TRACE&&Log.trace("Action",{actionName:"reallocating-loadNuker",roomName:r.name,creepName:e.name,structureId:t.id,resourceType:a,needs:i,workResult:o}),(e.carry[a]||0)>i?this.assignDropOff(e,a):this.cancelAction(e),o}),this.loadContainer=(e=>{let t=e.target,r=e.room,o=null,a=null,i=0;for(let r in e.carry)if((!r||0!=e.carry[r])&&(i=t.getNeeds(r))>0){a=r;break}return a&&(o=this.loadStructure(e,t,a,i)),LOG_TRACE&&Log.trace("Action",{actionName:"reallocating-loadContainer",roomName:r.name,creepName:e.name,structureId:t.id,resourceType:a,needs:i,workResult:o}),(e.carry[a]||0)>i?this.assignDropOff(e,a):this.cancelAction(e),o}),this.loadTerminal=(e=>{let t=e.target,r=e.room,o=null,a=null,i=0;for(let r in e.carry)if(!r||0!=e.carry[r]){if((i=t.getNeeds(r))>0){a=r;break}if(r!=RESOURCE_ENERGY&&r!=RESOURCE_POWER){a=r,i=t.storeCapacity-t.sum;break}}return a&&(o=this.loadStructure(e,t,a,i)),LOG_TRACE&&Log.trace("Action",{actionName:"reallocating-loadTerminal",roomName:r.name,creepName:e.name,structureId:t.id,resourceType:a,needs:i,workResult:o}),(e.carry[a]||0)>i?this.assignDropOff(e,a):this.cancelAction(e),o}),this.loadStorage=(e=>{let t=e.target,r=e.room,o=null,a=null,i=0;for(let r in e.carry)if((!r||0!=e.carry[r])&&(i=t.getNeeds(r))>0){a=r;break}return a&&(o=this.loadStructure(e,t,a,i)),LOG_TRACE&&Log.trace("Action",{actionName:"reallocating-loadStorage",roomName:r.name,creepName:e.name,structureId:t.id,resourceType:a,needs:i,workResult:o}),(e.carry[a]||0)>i?this.assignDropOff(e,a):this.cancelAction(e),o}),this.work=(e=>{let t=null,r=e.room,o=e.target;if(r.storage,r.terminal,0==e.sum)switch(o.structureType){case STRUCTURE_LAB:t=this.unloadLab(e);break;case STRUCTURE_POWER_SPAWN:this.cancelAction(e);break;case STRUCTURE_CONTAINER:t=this.unloadContainer(e);break;case STRUCTURE_TERMINAL:t=this.unloadTerminal(e);break;case STRUCTURE_STORAGE:t=this.unloadStorage(e);break;default:this.cancelAction(e)}else switch(o.structureType){case STRUCTURE_LAB:t=this.loadLab(e);break;case STRUCTURE_POWER_SPAWN:t=this.loadPowerSpawn(e);break;case STRUCTURE_NUKER:t=this.loadNuker(e);break;case STRUCTURE_CONTAINER:t=this.loadContainer(e);break;case STRUCTURE_TERMINAL:t=this.loadTerminal(e);break;case STRUCTURE_STORAGE:t=this.loadStorage(e);break;default:this.cancelAction(e)}return t})}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(0);t.default=new class extends o.CreepAction{constructor(){super("recycling"),this.isValidAction=(()=>!0),this.isAddableAction=(()=>!0),this.isAddableTarget=(()=>!0),this.newTarget=(e=>{let t=null;return e.room.my&&e.room.structures.spawns.length>0&&(t=e.pos.findClosestByRange(e.room.structures.spawns)),null==t&&(t=Game.spawns[e.data.motherSpawn]),null==t&&(t=e.pos.findClosestSpawn()),t}),this.work=(e=>{e.target.recycleCreep(e)})}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(0);t.default=new class extends o.CreepAction{constructor(){super("repairing"),this.targetRange=3,this.maxPerTarget=1,this.reachedRange=(e=>e.getStrategyHandler([this.name],"reachedRange",e)),this.isValidAction=(e=>e.carry.energy>0),this.isValidTarget=(e=>null!=e&&e.hits&&e.hits<e.hitsMax),this.isAddableTarget=((e,t)=>(e instanceof OwnedStructure&&e.my||!t.room.controller||(!t.room.controller.owner||t.room.controller.my)&&(!t.room.controller.reservation||t.room.controller.reservation.username==t.owner.username))&&(!e.targetOf||e.targetOf.length<this.maxPerTarget)),this.newTarget=(e=>_.find(e.room.structures.urgentRepairable,t=>this.isAddableTarget(t,e))),this.work=(e=>(e.getStrategyHandler([this.name],"getEnergy",e),e.repair(e.target))),this.setDefault({eachedRange:1,getEnergy:e=>!1})}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(0);t.default=new class extends o.CreepAction{constructor(){super("reserving"),this.isValidAction=(e=>!0),this.isValidTarget=(e=>e&&(!e.reservation||e.reservation.ticksToEnd<4999)),this.isAddableAction=(()=>!0),this.isAddableTarget=((e,t)=>e&&(e instanceof Flag||"controller"===e.structureType&&!e.owner)),this.newTarget=(e=>{let t;return e.data.destiny&&(t=Game.flags[e.data.destiny.targetName||e.data.destiny.flagName]),t||(t=FlagManager.find(e=>FlagManager.compare(e,FLAG_COLOR.claim.reserve)||FlagManager.compare(e,FLAG_COLOR.invade.exploit),e.pos,!1,FlagManager.reserveMod,e.name)),t?(PopManager.registerCreepFlag(e,t),e.flag.room&&e.flag.pos.roomName==e.pos.roomName?e.flag.room.controller:e.flag):null}),this.step=(e=>{if(CHATTY&&e.say(this.name,SAY_PUBLIC),e.target.color)return e.flag.pos.roomName==e.pos.roomName&&(e.data.targetId=null),e.travelTo(e.target.pos);let t=e.pos.getRangeTo(e.target);if(t<=this.targetRange){let r=this.work(e);return r!=OK&&e.handleError({errorCode:r,action:this.name,target:e.target,range:t,creep:e}),r}return e.travelTo(e.target.pos)}),this.work=(e=>{let t;return e.controllerSign(),t=e.target.owner&&!e.target.my?e.attackController(e.target):e.reserveController(e.target)})}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(0);t.default=new class extends o.CreepAction{constructor(){super("robbing"),this.maxPerTarget=2,this.maxPerAction=10,this.scoreMultiplier=1/Math.log(1.2),this.minimumTTL=500,this.isValidAction=(e=>e.sum<.95*e.carryCapacity&&!e.room.my),this.isValidTarget=(e=>!_.some(e.pos.lookFor(LOOK_STRUCTURES),{structureType:STRUCTURE_RAMPART,isPublic:!1,my:!1})&&e.structureType!==STRUCTURE_NUKER&&e.structureType!==STRUCTURE_POWER_SPAWN&&(e.store||e.energy||e.mineralAmount)),this.newTarget=(e=>{const t=e.room.structures.all;if(t.length){const r=_.chain(t).filter(e=>this.isValidTarget(e)).map(this.targetScore(e)).filter("score").sortBy("score").reverse().value();return _.get(r,[0,"target"],null)}return!1}),this.work=(e=>{const t=e.getStrategyHandler([this.name],"resourceValue",e),r=_.chain(Util.resources()).filter(t).sortBy(t).values().value();return this.targetCall(e,r,t=>(r,o,a)=>{const i=o?e.withdraw(t,r,o):0;return i?{amount:a,score:i}:{amount:o,score:i}})(e.target)}),this.targetScore=(e=>{const t=e.getStrategyHandler([this.name],"resourceValue",e),r=_.chain(Util.resources()).filter(t).sortBy(t).values().value();return this.targetCall(e,r,r=>e.getStrategyHandler([this.name],"resourceScore",e,r,t))}),this.targetCall=((e,t,r)=>o=>{const a=r(o);let i=0;return{target:o,score:i=o.store?this.storeCall(e,o,o.store,Util.valueOrZero,a,t):o.structureType===STRUCTURE_LAB?this.storeCall(e,o,{[RESOURCE_ENERGY]:o.energy,[o.mineralType]:o.mineralAmount},Util.valueOrZero,a):this.storeCall(e,o,{[RESOURCE_ENERGY]:o.energy},Util.valueOrZero,a)}}),this.storeCall=((e,t,r,o,a,i)=>{let n=e.carryCapacity-e.sum,s=0;i||(i=_.keys(r));for(let e=i.length-1;e>=0&&0!==n;e--){const t=i[e],l=Math.min(o(r[t]),n),{amount:m,score:c}=a(t,l<1?0:l,n);n-=m,s+=c}return s}),this.setDefault({moveOptions:e=>e,resourceValue:e=>{let t=e.ticksToLive<this.minimumTTL;if(!t&&e.data.homeRoom){const r=Game.rooms[e.data.homeRoom];t=r&&!r.storage}return t?e=>e===RESOURCE_ENERGY?1:0:e=>e===RESOURCE_ENERGY?.2:e===RESOURCE_POWER?500:e.length},resourceScore:(e,t,r)=>{const o=e.pos.getRangeTo(t),a=this.scoreMultiplier;return(e,t,i)=>0===t?{amount:0,score:0}:{amount:t,score:r(e)*t*(50-Math.log1p(o)*a)}}})}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(0);t.default=new class extends o.CreepAction{constructor(){super("safeGen"),this.maxPerAction=1,this.isValidAction=(e=>e.carryCapacity-_.sum(e.carry)>=1e3||e.carry[RESOURCE_GHODIUM]&&e.carry[RESOURCE_GHODIUM]>=1e3),this.newTarget=(e=>{let t=null;return!e.carry[RESOURCE_GHODIUM]||e.carry[RESOURCE_GHODIUM]<1e3?e.room.storage&&e.room.storage.store[RESOURCE_GHODIUM]&&e.room.storage.store[RESOURCE_GHODIUM]>=1e3?t=e.room.storage:e.room.terminal&&e.room.terminal.store[RESOURCE_GHODIUM]&&e.room.terminal.store[RESOURCE_GHODIUM]>=1e3&&(t=e.room.terminal):t=e.room.controller,t}),this.unloadStructure=(e=>{let t=0;return t=e.carry[RESOURCE_GHODIUM]?1e3-e.carry[RESOURCE_GHODIUM]:1e3,e.withdraw(e.target,RESOURCE_GHODIUM,t)}),this.generateSafeMode=(e=>e.generateSafeMode(e.target)),this.work=(e=>{let t=null;switch(e.target.structureType){case STRUCTURE_STORAGE:case STRUCTURE_TERMINAL:t=this.unloadStructure(e);break;case STRUCTURE_CONTROLLER:t=this.generateSafeMode(e);break;default:"safeGen"==e.data.creepType&&Game.flags[e.data.destiny.targetName]&&Game.flags[e.data.destiny.targetName].remove(),this.cancelAction(e)}return t}),this.cancelAction=(e=>{delete e.data.actionName,delete e.data.targetId,e.action=null,e.target=null,delete e.data.path})}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(0);t.default=new class extends o.CreepAction{constructor(){super("storing"),this.isValidAction=(e=>e.room.storage&&e.room.storage.isActive()&&e.sum>0),this.isValidTarget=(e=>e&&e.store&&e.active&&e.sum<e.storeCapacity),this.isAddableTarget=((e,t)=>e.my&&(!e.targetOf||e.targetOf.length<this.maxPerTarget)&&e.sum+t.carry[RESOURCE_ENERGY]<e.storeCapacity),this.isValidMineralToTerminal=(e=>e.storage.store[e.mineralType]&&e.storage.store[e.mineralType]>1.05*MAX_STORAGE_MINERAL&&e.terminal.sum-e.terminal.store.energy+Math.max(e.terminal.store.energy,TERMINAL_ENERGY)<e.terminal.storeCapacity),this.newTarget=(e=>{let t=e.room.mineralType;return e.room.terminal&&e.room.terminal.active&&((e=>e.carry[t]&&e.carry[t]>0&&this.isValidMineralToTerminal(e.room))(e)||(e=>e.carry.energy>0&&e.room.storage.charge>.5&&e.room.terminal.store.energy<.95*TERMINAL_ENERGY&&e.room.terminal.sum<e.room.terminal.storeCapacity)(e))&&this.isAddableTarget(e.room.terminal,e)?e.room.terminal:this.isValidTarget(e.room.storage)&&this.isAddableTarget(e.room.storage,e)?e.room.storage:null}),this.work=(e=>{let t;for(let r in e.carry)if(e.carry[r]>0&&(t=e.transfer(e.target,r))!=OK)break;return delete e.data.actionName,delete e.data.targetId,t})}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(0);t.default=new class extends o.CreepAction{constructor(){super("travelling"),this.isValidTarget=(e=>null!==e),this.isAddableAction=(()=>!0),this.isAddableTarget=(()=>!0),this.newTarget=(e=>e.getStrategyHandler([this.name],"newTarget",e)),this.step=(e=>{CHATTY&&e.say(this.name,SAY_PUBLIC);let t=_.get(e,["data","travelRange"],this.targetRange),r=e.target;if(FlagManager.isSpecialFlag(e.target))if(e.data.travelRoom){const o=Game.rooms[e.data.travelRoom];o&&o.name===e.pos.roomName?(e.leaveBorder(),r=null):(t=_.get(e,["data","travelRange"],TRAVELLING_BORDER_RANGE||22),r=new RoomPosition(25,25,e.data.travelRoom))}else Log.error(e.name+"CreepManager.action.travelling called with specialFlag target and travelRoom undefined."),r=null;if(r){if(e.pos.getRangeTo(r)<=t)return this.unregister(e);if(0===t&&e.pos.isNearTo(r)&&r.pos.lookFor(LOOK_CREEPS).length>0)return Log.module(e.name,"travelling.step: destination blocked, stopping."),this.unregister(e);e.travelTo(r,{range:t,ignoreCreeps:e.data.ignoreCreeps||!0})}else this.unregister(e)}),this.assignRoom=((e,t)=>{if(t)return _.isUndefined(e.data.travelRange)&&(e.data.travelRange=TRAVELLING_BORDER_RANGE||22),e.data.travelRoom=t,LOG_TRACE&&Log.trace("Action",{creepName:e.name,assign:this.name,roomName:t,Action:"assign"}),this.assign(e,FlagManager.specialFlag());Log.error(e.name+"CreepManager.action.travelling.assignRoom called with no room.")}),this.unregister=(e=>{delete e.action,delete e.target,delete e.data.actionName,delete e.data.ignoreCreeps,delete e.data.targetId,delete e.data.travelRoom,delete e.data.travelRange}),this.setDefault({newTarget:e=>e.data.travelPos||e.data.travelRoom?FlagManager.specialFlag():null})}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(0);t.default=new class extends o.CreepAction{constructor(){super("uncharging"),this.renewTarget=!1,this.maxPerTarget=1,this.isAddableAction=(e=>!0),this.isValidAction=(e=>e.getStrategyHandler([this.name],"isValidAction",e)),this.isValidTarget=((e,t)=>{if(!e)return!1;if("link"==e.structureType)return e.energy>0;if("container"==e.structureType){let r=0;return r=!0===e.source&&1==e.controller?e.storeCapacity*MANAGED_CONTAINER_TRIGGER:t.data.creepType.indexOf("remote")>=0?250:500,e.sum>r}return!1}),this.newTarget=(e=>{if(e.room.structures.links.storage.length>0){let t=e.room.structures.links.storage.find(e=>e.energy>0);if(t&&(!e.room.structures.links.controller.find(e=>e.energy<.15*e.energyCapacity)||t.energy<=.85*t.energyCapacity))return t}if(e.room.structures.container.in.length>0){let t;t=e.data.creepType.indexOf("remote")>=0?250:500;let r=null,o=0,a=a=>{if(this.isValidTarget(a,e)){let i=a.sum;if(a.targetOf&&(i-=_.sum(a.targetOf.map(e=>"uncharging"==e.actionName?e.carryCapacityLeft:0))),i<Math.min(e.carryCapacity-e.sum,t))return;i>o&&(o=i,r=a)}};return _.forEach(e.room.structures.container.in,a),r}}),this.work=(e=>{let t=OK;if(!0===e.target.source&&1==e.target.controller){let r=e.target.sum-e.target.storeCapacity*(1-MANAGED_CONTAINER_TRIGGER);if(r<1)t=ERR_NOT_ENOUGH_RESOURCES;else{let o=e.carryCapacity-e.sum,a=_.min([e.target.store.energy,r,o]);e.target._sum-=a,t=e.withdraw(e.target,RESOURCE_ENERGY,a)}}else if(null!=e.target.store){let r=r=>{e.target.store[r]>0&&(t=e.withdraw(e.target,r))};_.forEach(Object.keys(e.target.store),r)}else t=e.withdraw(e.target,RESOURCE_ENERGY);return delete e.data.actionName,delete e.data.targetId,e.action=null,e.target=null,t}),this.setDefault({isValidAction:e=>e.sum<e.carryCapacity||!1})}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(0);t.default=new class extends o.CreepAction{constructor(){super("upgrading"),this.targetRange=3,this.reachedRange=3,this.isAddableAction=(e=>!e.room.storage||e.room.storage.charge>1||!e.room.storage.my&&e.room.storage.store.energy>0),this.isAddableTarget=((e,t)=>!!(8!==e.level||t.data&&"upgrader"===t.data.creepType)),this.isValidAction=(e=>e.carry.energy>0),this.isValidTarget=(e=>e&&"controller"===e.structureType&&e.my),this.newTarget=(e=>{const t=e.room.controller&&e.room.controller.my?e.room.controller:null;return this.isValidTarget(t)&&this.isAddableTarget(t,e)&&t}),this.work=((e,t)=>(t&&t<2&&e.controllerSign(),e.upgradeController(e.target)))}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(0);t.default=new class extends o.CreepAction{constructor(){super("withdrawing"),this.isValidAction=(e=>e.getStrategyHandler([this.name],"isValidAction",e)),this.isValidTarget=(e=>!(e instanceof StructureTerminal&&e.charge<=0)&&e&&!!e.store&&e.store[RESOURCE_ENERGY]),this.newTarget=(e=>{const t=e.room.terminal,r=e.room.storage,o=[];return t&&this.isValidTarget(t)?o.push(t):r&&this.isValidTarget(r)&&o.push(r),!!o.length&&_.max(o,"charge")}),this.work=(e=>e.withdraw(e.target,RESOURCE_ENERGY)),this.assignDebounce=((e,t,r)=>{const o=r||this.newTarget(e);if(o){if(!(o instanceof StructureStorage&&"storing"===e.data.lastAction&&e.data.lastTarget===e.room.storage.id))return this.assign(e,o);{const r={carry:{},owner:e.owner,pos:e.pos,room:e.room,sum:e.carryCapacity},a=e.room.storage.store[RESOURCE_ENERGY],i=a>e.carryCapacity?e.carryCapacity:a;r.carry[RESOURCE_ENERGY]=i;let n=null;const s=_.find(t,e=>!("storing"===e.name||!e.isValidAction(r)||!e.isAddableAction(r)||!(n=e.newTarget(r))));if(s&&this.assign(e,o))return e.data.nextAction=s.name,e.data.nextTarget=n.id,!0}}return!1}),this.setDefault({isValidAction:e=>!!((e.room.storage&&e.room.storage.store[RESOURCE_ENERGY]||e.room.terminal&&e.room.terminal.store[RESOURCE_ENERGY])&&"privateer"!==e.data.creepType&&e.sum<e.carryCapacity&&(!e.room.lowDefenseEnergy||e.room.relativeEnergyAvailable<.8))})}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(1);t.default=new class extends o.CreepBehaviour{constructor(){super("claimer"),this.actions=(e=>[CreepManager.action.claiming,CreepManager.action.reserving,CreepManager.action.bulldozing]),this._run=this.run,this.run=(e=>{if(this._run(e),e.hits<e.hitsMax&&(!e.action||"travelling"!==e.action.name)&&e.data){if(!e.data.nearestHome||!Game.rooms[e.data.nearestHome]){const t=RoomManager.bestSpawnRoomFor(e.pos.roomName);t&&(e.data.nearestHome=t.name)}e.data.nearestHome&&CreepManager.action.travelling.assignRoom(e,e.data.nearestHome)}LOG_TRACE&&Log.trace("Behaviour",{creepName:e.name,run:e.action&&e.action.name||"none",[this.name]:"run",Behaviour:this.name})})}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(1);t.default=new class extends o.CreepBehaviour{constructor(){super("collapseWorker"),this.inflowActions=(e=>{let t=[CreepManager.action.picking,CreepManager.action.withdrawing,CreepManager.action.uncharging,CreepManager.action.harvesting,CreepManager.action.dismantling,CreepManager.action.reallocating];return e.sum>e.carry.energy&&t.unshift(CreepManager.action.storing),t}),this.outflowActions=(e=>{const t=e.room.situation.invasion&&e.room.controller&&e.room.RCL>2;if(t)return[CreepManager.action.feeding,CreepManager.action.fueling,CreepManager.action.repairing];{let r=[CreepManager.action.feeding,CreepManager.action.fueling,CreepManager.action.charging,CreepManager.action.repairing,CreepManager.action.building,CreepManager.action.fortifying,CreepManager.action.upgrading];return t||(r.push(CreepManager.action.storing),r.push(CreepManager.action.dropping)),e.room.controller&&e.room.controller.ticksToDowngrade<500&&r.unshift(CreepManager.action.upgrading),r}}),this.needEnergy=(e=>CreepManager.behaviour.worker.needEnergy(e)),this.nextAction=(e=>e.pos.roomName!==e.data.homeRoom?(LOG_TRACE&&Log.trace("Behaviour",{actionName:"travelling",behaviourName:this.name,creepName:e.name,assigned:!0,Behaviour:"nextAction",Action:"assign"}),CreepManager.action.travelling.assignRoom(e,e.data.homeRoom),!0):!e.room.collapsed&&(Util.set(e,["data","recycleTick"],Game.time+50),Game.time>=e.data.recycleTick)?(LOG_TRACE&&Log.trace("Behaviour",{actionName:"recycling",behaviourName:this.name,creepName:e.name,assigned:!0,Behaviour:"nextAction",Action:"assign"}),this.assignAction(e,"recycling")):CreepManager.behaviour.worker.nextAction(e)),this.mergeState({default:{canWithdrawEnergy:(e,t)=>e=>e>0}})}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(1);t.default=new class extends o.CreepBehaviour{constructor(){super("hauler"),this.inflowActions=(e=>[CreepManager.action.uncharging,CreepManager.action.picking,CreepManager.action.withdrawing,CreepManager.action.reallocating]),this.outflowActions=(e=>{let t=[CreepManager.action.feeding,CreepManager.action.charging,CreepManager.action.fueling,CreepManager.action.storing];return(e.sum>e.carry.energy||!e.room.situation.invasion&&SPAWN_DEFENSE_ON_ATTACK&&e.room.lowDefenseEnergy&&e.room.relativeEnergyAvailable>.8)&&t.unshift(CreepManager.action.storing),e.room.structures.urgentRepairable.length>0&&t.unshift(CreepManager.action.fueling),t}),this.nextAction=(e=>e.pos.roomName!=e.data.homeRoom&&Game.rooms[e.data.homeRoom]&&Game.rooms[e.data.homeRoom].controller?CreepManager.action.travelling.assignRoom(e,e.data.homeRoom):this.nextEnergyAction(e)),this.setState({picking:{name:`picking-${this.name}`,energyOnly:!1}})}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(1);t.default=new class extends o.CreepBehaviour{constructor(){super("healer"),this.actions=(e=>[CreepManager.action.healing,CreepManager.action.guarding]),this._invalidAction=this.invalidAction,this.invalidAction=(e=>this._invalidAction(e)||"guarding"===e.action.name)}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(1);t.default=new class extends o.CreepBehaviour{constructor(){super("labTech"),this.inflowActions=(e=>[CreepManager.action.reallocating,CreepManager.action.withdrawing,CreepManager.action.uncharging,CreepManager.action.picking]),this.outflowActions=(e=>{let t=[CreepManager.action.storing,CreepManager.action.charging,CreepManager.action.fueling,CreepManager.action.feeding];return(e.sum>e.carry.energy||!e.room.situation.invasion&&SPAWN_DEFENSE_ON_ATTACK&&e.room.lowDefenseEnergy&&e.room.relativeEnergyAvailable>.8)&&t.unshift(CreepManager.action.storing),e.room.structures.urgentRepairable.length>0&&t.unshift(CreepManager.action.fueling),t}),this.nextAction=(e=>CreepManager.behaviour.hauler.nextAction(e))}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(1);t.default=new class extends o.CreepBehaviour{constructor(){super("melee"),this.heal=(e=>{!e.attacking&&void 0!==e.data.body.heal&&e.hits<e.hitsMax&&e.heal(e)}),this.actions=(e=>[CreepManager.action.defending,CreepManager.action.invading,CreepManager.action.guarding]),this._invalidAction=this.invalidAction,this._run=this.run,this.setState({healing:{moveOptions:e=>(e.respectRamparts=!0,e)}}),this.invalidAction=(e=>this._invalidAction(e)||"guarding"===e.action.name&&(!e.flag||e.flag.pos.roomName===e.pos.roomName||e.leaveBorder())),this.run=(e=>{e.flee=e.flee||!e.hasActiveBodyparts([ATTACK,RANGED_ATTACK]),e.attacking=!1,e.attackingRanged=!1,this._run(e),this.heal(e)})}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(1);t.default=new class extends o.CreepBehaviour{constructor(){super("miner"),this.actions=(e=>[CreepManager.action.mining,CreepManager.action.recycling])}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(1);t.default=new class extends o.CreepBehaviour{constructor(){super("mineralMiner"),this.actions=(e=>CreepManager.behaviour.miner.actions(e)),this.getEnergy=(e=>CreepManager.behaviour.miner.getEnergy(e)),this.maintain=(e=>CreepManager.behaviour.miner.maintain(e)),this.setState({mining:{newTarget:e=>_.find(e.room.minerals,t=>!_.find(Memory.population,r=>r.creepName!==e.name&&r.determinatedTarget===t.id))}})}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(1);t.default=new class extends o.CreepBehaviour{constructor(){super("remoteMiner"),this.actions=(e=>CreepManager.behaviour.miner.actions(e)),this.getEnergy=(e=>CreepManager.behaviour.miner.getEnergy(e)),this.maintain=(e=>CreepManager.behaviour.miner.maintain(e)),this._run=this.run,this.run=(e=>{if(!CreepManager.action.avoiding.run(e)){const t=e.data.destiny&&Game.flags[e.data.destiny.targetName];t?e.room.name!==e.data.destiny.room&&CreepManager.action.travelling.assignRoom(e,t.pos.roomName):e.action&&"recycling"===e.action.name||this.assignAction(e,"recycling"),this._run(e)}})}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(1);t.default=new class extends o.CreepBehaviour{constructor(){super("remoteHauler"),this.nextAction=(e=>{if(!e.data.destiny||!Game.flags[e.data.destiny.targetName])return CreepManager.action.recycling.assign(e);if(e.pos.roomName==e.data.homeRoom){if(e.sum>0){let t=[];if(e.carry.energy==e.sum&&(t=e.room.structures.links.privateers),e.room.storage&&t.push(e.room.storage),e.room.structures.container&&(t=t.concat(e.room.structures.container.privateers)),t.length>0){let r=e.pos.findClosestByRange(t);if(r.structureType==STRUCTURE_STORAGE&&this.assignAction(e,"storing",r))return;if(this.assignAction(e,"charging",r))return;if(this.assignAction(e,"storing"))return}if(this.assignAction(e,"charging"))return;if(this.assignAction(e,"feeding"))return;if(this.assignAction(e,"dropping"))return;{const t=t=>{e.carry[t]>0&&e.drop(t)};return _.forEach(Object.keys(e.carry),t),this.assignAction(e,"idle")}}if(this.gotoTargetRoom(e))return}else{if(e.data.destiny.room==e.pos.roomName){if(e.sum/e.carryCapacity>REMOTE_HAULER.MIN_LOAD)return void this.goHome(e);if(this.assignAction(e,"uncharging"))return;if(this.assignAction(e,"picking"))return;if(0===e.sum){let t=e.pos.findClosestByRange(e.room.sources);if(e.room&&t&&e.pos.getRangeTo(t)>3)return e.data.travelRange=3,this.assignAction(e,"travelling",t)}return this.assignAction(e,"idle")}{let t=!1;if(t=e.sum/e.carryCapacity>REMOTE_HAULER.MIN_LOAD?this.goHome(e):this.gotoTargetRoom(e))return}}let t=Game.spawns[e.data.motherSpawn];t&&this.assignAction(e,CreepManager.action.recycling,t)}),this.gotoTargetRoom=(e=>{const t=e.data.destiny?Game.flags[e.data.destiny.targetName]:null;if(t)return CreepManager.action.travelling.assignRoom(e,t.pos.roomName)}),this.goHome=(e=>CreepManager.action.travelling.assignRoom(e,e.data.homeRoom)),this.setState({picking:{name:`picking-${this.name}`,energyOnly:!1}})}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(1);t.default=new class extends o.CreepBehaviour{constructor(){super("remoteWorker"),this.inflowActions=(e=>[CreepManager.action.picking,CreepManager.action.uncharging,CreepManager.action.withdrawing,CreepManager.action.harvesting]),this.outflowActions=(e=>[CreepManager.action.repairing,CreepManager.action.building,CreepManager.action.recycling]),this.needEnergy=(e=>e.sum<.8*e.carryCapacity),this.nextAction=(e=>e.data.destiny&&Game.flags[e.data.destiny.targetName]||e.action&&"recycling"===e.action.name?e.data.destiny.room===e.pos.roomName?this.nextEnergyAction(e):this.gotoTargetRoom(e):this.assignAction(e,"recycling")),this.gotoTargetRoom=(e=>{const t=e.data.destiny?Game.flags[e.data.destiny.targetName]:null;if(t)return CreepManager.action.travelling.assignRoom(e,t.pos.roomName)}),this._run=this.run,this.run=(e=>{CreepManager.action.avoiding.run(e)||this._run(e)})}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(1);t.default=new class extends o.CreepBehaviour{constructor(){super("pioneer"),this.inflowActions=(e=>CreepManager.behaviour.worker.inflowActions(e)),this.outflowActions=(e=>{let t;return t=e.room.controller&&e.room.RCL<2?[CreepManager.action.feeding,CreepManager.action.upgrading,CreepManager.action.building,CreepManager.action.repairing,CreepManager.action.fueling,CreepManager.action.fortifying,CreepManager.action.charging,CreepManager.action.storing,CreepManager.action.picking]:[CreepManager.action.feeding,CreepManager.action.building,CreepManager.action.repairing,CreepManager.action.fueling,CreepManager.action.fortifying,CreepManager.action.charging,CreepManager.action.upgrading,CreepManager.action.storing,CreepManager.action.picking],e.room.controller&&e.room.controller.ticksToDowngrade<2e3&&t.unshift(CreepManager.action.upgrading),e.sum>e.carry.energy&&t.unshift(CreepManager.action.storing),t}),this.nextAction=(e=>{let t;if(e.data.destiny&&(t=Game.flags[e.data.destiny.flagName]),t){if((!t.room||t.pos.roomName!=e.pos.roomName)&&CreepManager.action.travelling.assignRoom(e,t.pos.roomName))return PopManager.registerCreepFlag(e,t),!0;if(t.room&&t.room.my){let r=FlagManager.find(FLAG_COLOR.claim.spawn,e.pos,!0);if(r)if(r.room.structures.spawns&&r.room.structures.spawns.length>0){r.remove();let e=e=>Game.flags[e.name].remove();_.forEach(FlagManager.filter(FLAG_COLOR.invade.exploit,r.pos,!0),e)}else t.room.myConstructionSites.some(e=>e.structureType===STRUCTURE_SPAWN)||t.room.createConstructionSite(r,STRUCTURE_SPAWN)}}return this.nextEnergyAction(e)})}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(1);t.default=new class extends o.CreepBehaviour{constructor(){super("privateer"),this.nextAction=(e=>{let t=e.sum;if(e.pos.roomName==e.data.homeRoom){if(t>0){let r=[];if(e.carry.energy==t&&(r=e.room.structures.links.privateers),e.room.storage&&r.push(e.room.storage),e.room.structures.container&&(r=r.concat(e.room.structures.container.privateers)),r.length>0){let t=e.pos.findClosestByRange(r);if(t.structureType===STRUCTURE_STORAGE&&this.assignAction(e,"storing",t))return;if(this.assignAction(e,"charging",t))return}if(this.assignAction(e,"charging"))return;if(!e.room.ally&&this.assignAction(e,"storing"))return;return void CreepManager.behaviour.worker.nextAction(e)}this.exploitNextRoom(e)||CreepManager.behaviour.worker.nextAction(e)}else if(e.flag&&e.flag.pos.roomName==e.pos.roomName){if(e.room.situation.invasion&&!e.flag.compareTo(FLAG_COLOR.invade.robbing))return e.flag.cloaking=50,void this.exploitNextRoom(e);if(e.sum<.4*e.carryCapacity)if(0===e.room.sourceEnergyAvailable)e.flag.cloaking=_.max([e.room.ticksToNextRegeneration-20,0]),this.exploitNextRoom(e);else{let t=[CreepManager.action.dismantling,CreepManager.action.picking,CreepManager.action.robbing,CreepManager.action.harvesting];for(let r=0;r<t.length;r++){let o=t[r];if(o.isValidAction(e)&&o.isAddableAction(e)&&o.assign(e))return}e.flag.cloaking=50,this.exploitNextRoom(e)}else{const t=[CreepManager.action.building];for(let r=0;r<t.length;r++){let o=t[r];if(o.isValidAction(e)&&o.isAddableAction(e)&&o.assign(e))return}PopManager.registerCreepFlag(e,null),CreepManager.action.travelling.assignRoom(e,e.data.homeRoom)}}else this.exploitNextRoom(e)}),this.exploitNextRoom=(e=>{if(e.sum<.4*e.carryCapacity){const t=e=>FlagManager.compare(e,FLAG_COLOR.invade.exploit)||FlagManager.compare(e,FLAG_COLOR.invade.robbing),r=FlagManager.find(t,new RoomPosition(25,25,e.data.homeRoom),!1,FlagManager.exploitMod,e.name);if(r&&CreepManager.action.travelling.assignRoom(e,r.pos.roomName))return PopManager.registerCreepFlag(e,r),!0}return PopManager.registerCreepFlag(e,null),e.room.name!==e.data.homeRoom&&CreepManager.action.travelling.assignRoom(e,e.data.homeRoom),!1}),this._invalidAction=this.invalidAction,this._run=this.run,this.setState({withdrawing:{name:`withdrawing-${this.name}`,isValidAction:e=>!1}}),this.invalidAction=(e=>this._invalidAction(e)||!e.flag),this.run=(e=>{if(this._run(e),e.hits<e.hitsMax&&(!e.action||"travelling"!==e.action.name)&&e.data){if(!e.data.nearestHome||!Game.rooms[e.data.nearestHome]){const t=RoomManager.bestSpawnRoomFor(e.pos.roomName);t&&(e.data.nearestHome=t.name)}e.data.nearestHome&&CreepManager.action.travelling.assignRoom(e,e.data.nearestHome)}LOG_TRACE&&Log.trace("Behaviour",{creepName:e.name,run:e.action&&e.action.name||"none",[this.name]:"run",Behaviour:this.name})})}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(1);t.default=new class extends o.CreepBehaviour{constructor(){super("recycler"),this.actions=(e=>[CreepManager.action.picking,CreepManager.action.withdrawing,CreepManager.action.uncharging,CreepManager.action.travelling,CreepManager.action.storing,CreepManager.action.feeding,CreepManager.action.dropping,CreepManager.action.recycling,CreepManager.action.idle]),this._invalidAction=this.invalidAction,this.setState({recycling:{name:`recycling-${this.name}`,isValidAction:e=>!e.sum},uncharging:{name:`uncharging-${this.name}`,isValidAction:e=>e.data.travelRoom&&e.sum<e.carryCapacity||!1},withdrawing:{name:`withdrawing-${this.name}`,isValidAction:e=>e.data.travelRoom&&e.room.storage&&e.room.storage.store.energy>0&&e.sum<e.carryCapacity||!1},travelling:{name:`travelling-${this.name}`,newTarget:e=>{if(!e.data.travelRoom)if(e.data.travelPos)e.data.travelRoom=e.data.travelPos.roomName;else{if(e.room.structures.spawns.length)return null;e.data.travelRoom=e.data.homeRoom}const t=Game.rooms[e.data.travelRoom];let r=t&&(t.storage||t.structures.spawns[0]);return r||e}}}),this.invalidAction=(e=>!(!this._invalidAction(e)&&e.action.isMember(this.actions())||(delete e.data.targetId,delete e.data.path,0)))}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(1);t.default=new class extends o.CreepBehaviour{constructor(){super("ranger"),this.heal=(e=>{!e.attacking&&void 0!==e.data.body.heal&&e.hits<e.hitsMax&&e.heal(e)}),this.actions=(e=>[CreepManager.action.defending,CreepManager.action.healing,CreepManager.action.invading,CreepManager.action.guarding]),this._run=this.run,this.setState({healing:{moveOptions:e=>(e.respectRamparts=!0,e)}}),this.run=(e=>{e.flee=e.flee||!e.hasActiveBodyparts([ATTACK,RANGED_ATTACK]),e.attacking=!1,e.attackingRanged=!1,this._run(e),this.heal(e)})}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(1);t.default=new class extends o.CreepBehaviour{constructor(){super("upgrader"),this.invalidCreep=(e=>["miner","upgrader"].includes(e.data.creepType)&&e.data.determinatedSpot&&(e.data.ttl>e.data.spawningTime||e.data.ttl>e.data.predictedRenewal)),this.approach=(e=>{let t=new RoomPosition(e.data.determinatedSpot.x,e.data.determinatedSpot.y,e.pos.roomName),r=e.pos.getRangeTo(t);if(r>0){e.data.movingToTarget=!0;const o=t.lookFor(LOOK_CREEPS),a=o.length?1:0;1===r&&o.length&&_.some(o,this.invalidCreep)&&delete e.data.determinatedSpot,e.travelTo(t,{range:a})}else e.data.movingToTarget&&(e.room.invalidateCostMatrix(),delete e.data.movingToTarget);return r}),this.run=(e=>{if(e.room.controller.upgradeBlocked)e.data.creepType="recycler";else{if(e.action&&"upgrading"===e.action.name||PopManager.registerAction(e,CreepManager.action.upgrading,e.room.controller),!e.data.determinatedSpot){let t=(t=!1)=>{let r=r=>{let o={spots:[{pos:e.room.controller.pos,range:3},{pos:r.pos,range:1}],checkWalkable:!0,where:r=>!_.some(r.lookFor(LOOK_CREEPS),this.invalidCreep)&&(t||0===r.findInRange(e.room.sources,1).length),roomName:e.pos.roomName};return RoomManager.fieldsInRange(o)},o=e.room.structures.links.controller?_.flatten(_.map(e.room.structures.links.controller,r)):[],a=e.room.structures.container.controller?_.flatten(_.map(e.room.structures.container.controller,r)):[],i=e.room.storage?r(e.room.storage):[],n=e.room.terminal?r(e.room.terminal):[];if(o.length){let e=[];return 0===e.length&&a.length&&(e=_.filter(o,e=>_.some(a,t=>t.isEqualTo(e)))),0===e.length&&i.length&&(e=_.filter(o,e=>_.some(i,t=>t.isEqualTo(e)))),0===e.length&&n.length&&(e=_.filter(o,e=>_.some(n,t=>t.isEqualTo(e)))),e.length?e:o}return a.length?a:i.length?i:n},r=t();if(r.length>0&&(r=t(!0)),r.length>0){let t=e.pos.findClosestByPath(r,{filter:t=>!_.some(e.room.lookForAt(LOOK_STRUCTURES,t),{structureType:STRUCTURE_ROAD})});if(t||(t=e.pos.findClosestByPath(r)||r[0]),t){e.data.determinatedSpot={x:t.x,y:t.y};let r=Game.spawns[e.data.motherSpawn];if(r){let o=t.findPathTo(r,{ignoreCreeps:!0});const a=e.data.body?Math.ceil(e.data.body.work/(2*e.data.body.move)):1;o&&(e.data.predictedRenewal=e.data.spawningTime+o.length*a)}}}e.data.determinatedSpot?SAY_ASSIGNMENT&&e.say(String.fromCharCode(9962),SAY_PUBLIC):Log.error("Unable to determine working location for upgrader in room "+e.pos.roomName)}if(e.data.determinatedSpot&&(CHATTY&&e.say("upgrading",SAY_PUBLIC),this.approach(e),e.room.controller&&e.pos.getRangeTo(e.room.controller)<=3)){let t=e.data.body&&e.data.body.work?e.data.body.work:e.carryCapacity/2;if(e.carry.energy<=t){let t=_.find(e.room.structures.links.controller,t=>t.energy>0&&e.pos.isNearTo(t));t||(t=_.find(e.room.structures.container.controller,t=>t.store[RESOURCE_ENERGY]>0&&e.pos.isNearTo(t))),t||(t=e.room.storage&&e.room.storage.charge>0&&e.pos.isNearTo(e.room.storage)),t||(t=e.room.terminal&&e.room.terminal.store[RESOURCE_ENERGY]>.5*TERMINAL_ENERGY&&e.pos.isNearTo(e.room.terminal)),t&&e.withdraw(t,RESOURCE_ENERGY)}e.controllerSign(),e.upgradeController(e.room.controller)}}})}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(1);t.default=new class extends o.CreepBehaviour{constructor(){super("worker"),this.inflowActions=(e=>{let t=[CreepManager.action.bulldozing,CreepManager.action.picking,CreepManager.action.dismantling,CreepManager.action.withdrawing,CreepManager.action.uncharging,CreepManager.action.harvesting,CreepManager.action.reallocating];return e.sum>e.carry.energy&&t.unshift(CreepManager.action.storing),t}),this.outflowActions=(e=>{if(e.room.situation.invasion&&e.room.controller&&e.room.RCL>2)return[CreepManager.action.fueling,CreepManager.action.feeding,CreepManager.action.repairing];{let t=[CreepManager.action.repairing,CreepManager.action.feeding,CreepManager.action.building,CreepManager.action.fueling,CreepManager.action.fortifying,CreepManager.action.charging,CreepManager.action.upgrading,CreepManager.action.storing];const r=e=>{const t=e.population&&e.population.typeCount;return!t.hauler||t.hauler<1||!t.miner||t.miner<1};return e.room.relativeEnergyAvailable<1&&r(e.room)&&t.unshift(CreepManager.action.feeding),e.room.controller&&e.room.controller.ticksToDowngrade<2e3&&t.unshift(CreepManager.action.upgrading),e.sum>e.carry.energy&&t.unshift(CreepManager.action.storing),t.unshift(CreepManager.action.bulldozing),t}}),this.nextAction=(e=>"worker"==e.data.creepType&&e.pos.roomName!=e.data.homeRoom&&Game.rooms[e.data.homeRoom]&&Game.rooms[e.data.homeRoom].controller?(LOG_TRACE&&Log.trace("Behaviour",{actionName:"travelling",behaviourName:this.name,creepName:e.name,assigned:!0,Behaviour:"nextAction",Action:"assign"}),CreepManager.action.travelling.assignRoom(e,e.data.homeRoom),!0):this.nextEnergyAction(e))}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(1);t.default=new class extends o.CreepBehaviour{constructor(){super("safeGen"),this.actions=(e=>[CreepManager.action.safeGen,CreepManager.action.recycling])}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(5);t.default=new class extends o.CreepSetup{constructor(){super("hauler"),this.maxMulti=(e=>{let t=7;e.minerals.length>0&&(t+=2);let r=_.sum(e.structures.container.in,"sum");return r+=_.sum(e.droppedResources,"amount"),t+=Math.floor(r/1e3),t+=CreepManager.setup.upgrader._maxMulti(e),Math.min(t,16)}),this.maxCount=(e=>{if(!e.population)return 0;let t=0,r=e.population.typeCount.miner||0,o=e.population.typeCount.worker||0,a=e.population.typeCount.mineralMiner||0,i=e.structures.container.in.length+e.structures.links.storage.length;if(r>0||i>0&&o>CreepManager.setup.worker._maxCount(e)){e.storage&&e.storage.id===e.controller.memory.storage||(t+=Math.round(CreepManager.setup.upgrader._maxCount(e)/2)),(e.structures.links.all.length<3||e.storage&&e.storage.active&&e.storage.charge>1&&e.structures.container.controller&&0==_.sum(e.structures.container.controller,"store.energy"))&&t++,a>0&&t++;let r=0,o=t=>e.sources.some(e=>e.pos.x===t.x&&e.pos.y===t.y),i=e=>{e.resourceType===RESOURCE_ENERGY&&e.pos.adjacent.some(o)&&(r+=e.amount)};e.droppedResources.forEach(i),0===t&&(t=1)}return t}),this.maxWeight=(e=>2e3*this._maxCount(e)),this.minControllerLevel=2}get default(){return{fixedBody:[WORK,CARRY,MOVE],multiBody:[CARRY,CARRY,MOVE],minAbsEnergyAvailable:200,minEnergyAvailable:.4,maxMulti:e=>this.maxMulti(e),maxCount:e=>this.maxCount(e),maxWeight:e=>this.maxWeight(e)}}get high(){return{fixedBody:[WORK,CARRY,MOVE],multiBody:[CARRY,CARRY,MOVE],minAbsEnergyAvailable:200,minEnergyAvailable:.1,maxMulti:e=>this.maxMulti(e),maxCount:e=>this.maxCount(e),maxWeight:e=>this.maxWeight(e)}}get RCL(){return{1:this.none,2:this.none,3:this.default,4:this.default,5:this.default,6:this.default,7:this.default,8:this.high}}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(5);t.default=new class extends o.CreepSetup{constructor(){super("healer"),this.minControllerLevel=7,this.globalMeasurement=!0}get RCL(){return{1:this.none,2:this.none,3:this.none,4:this.none,5:this.none,6:this.none,7:{fixedBody:[],multiBody:[MOVE,HEAL],minAbsEnergyAvailable:300,minEnergyAvailable:.8,maxMulti:4,maxCount:0,maxWeight:0},8:{fixedBody:[],multiBody:[MOVE,HEAL],minAbsEnergyAvailable:300,minEnergyAvailable:.8,maxMulti:4,maxCount:0,maxWeight:0}}}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(5);t.default=new class extends o.CreepSetup{constructor(){super("miner"),this.minControllerLevel=1}get default(){return{fixedBody:{[CARRY]:1,[MOVE]:1,[WORK]:4},multiBody:[WORK,MOVE],minAbsEnergyAvailable:500,minEnergyAvailable:.3,maxMulti:2,maxCount:e=>e.sources.length}}get low(){return{fixedBody:[WORK,WORK,MOVE],multiBody:[WORK],minAbsEnergyAvailable:250,minEnergyAvailable:.9,maxMulti:3,maxCount:e=>e.sources.length}}get high(){return{fixedBody:{[CARRY]:1,[MOVE]:1,[WORK]:4},multiBody:[WORK,MOVE],minAbsEnergyAvailable:500,minEnergyAvailable:.1,maxMulti:2,maxCount:e=>e.sources.length}}get RCL(){return{1:this.low,2:this.low,3:this.default,4:this.default,5:this.default,6:this.default,7:this.default,8:this.high}}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(5);t.default=new class extends o.CreepSetup{constructor(){super("mineralMiner"),this.maxCount=(e=>{if(e.memory.noMineralMiners)return 0;let t=0;if(0===(e.population.typeCount.hauler||0))return 0;if(e.storage&&e.storage.sum<.9*e.storage.storeCapacity){let r=e=>{e.mineralAmount>0&&t++};e.minerals.forEach(r)}return t}),this.minControllerLevel=6}get default(){return{fixedBody:{[CARRY]:1,[MOVE]:1,[WORK]:3},multiBody:{[MOVE]:1,[WORK]:3},minAbsEnergyAvailable:750,minEnergyAvailable:.3,maxMulti:11,minMulti:1,maxCount:e=>this.maxCount(e)}}get RCL(){return{1:this.none,2:this.none,3:this.none,4:this.none,5:this.none,6:this.default,7:this.default,8:this.default}}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(5);t.default=new class extends o.CreepSetup{constructor(){super("privateer"),this.minControllerLevel=3,this.globalMeasurement=!0,this.measureByHome=!0}get default(){return{fixedBody:[WORK,CARRY,MOVE],multiBody:[WORK,CARRY,MOVE],minAbsEnergyAvailable:400,minEnergyAvailable:.8,maxMulti:15,minMulti:e=>e.RCL,maxWeight:e=>e.privateerMaxWeight}}get RCL(){return{1:this.none,2:this.none,3:this.default,4:this.default,5:this.default,6:this.default,7:this.default,8:this.default}}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(5);t.default=new class extends o.CreepSetup{constructor(){super("upgrader"),this.maxMulti=(e=>{let t=0;const r=e.storage&&e.storage.active?e.storage.charge:0;if((!e.storage||e.storage.active&&r>0)&&t++,(!e.storage||e.storage.active&&r>.5)&&t++,e.storage&&e.storage.active&&r>=1){let r=e.storage.store.energy-MAX_STORAGE_ENERGY[e.RCL];t+=Math.ceil(r/2e4)}return Math.min(11,t)}),this.maxCount=(e=>{const t=_.get(e,["memory","addUpgrader"],0);if(e.situation.invasion||e.lowDefenseEnergy||e.structures.container.controller.length+e.structures.links.controller.length===0||e.controller.upgradeBlocked||e.myConstructionSites.length>0&&!e.storage)return 0;if(8==e.RCL)return 1;let r=0;if(e.structures.container.controller.forEach(e=>r+=e.store.energy),e.structures.links.controller.forEach(e=>r+=e.energy),0===r)return 0;if(e.storage&&e.storage.active)return t+Math.max(1,Math.floor((e.storage.store.energy-MAX_STORAGE_ENERGY[e.RCL])/35e4));if(e.droppedResources){let t=0,r=t=>e.sources.some(e=>e.pos.x===t.x&&e.pos.y===t.y),o=e=>{e.resourceType===RESOURCE_ENERGY&&e.pos.adjacent.some(r)&&(t+=e.amount)};e.droppedResources.forEach(o)}return t+2}),this.minControllerLevel=2}get default(){return{fixedBody:{[CARRY]:1,[MOVE]:1,[WORK]:2},multiBody:{[MOVE]:1,[WORK]:3},minAbsEnergyAvailable:400,minEnergyAvailable:.5,maxMulti:e=>this.maxMulti(e),maxCount:e=>this.maxCount(e)}}get low(){return{fixedBody:{[CARRY]:1,[MOVE]:1,[WORK]:2},multiBody:{[MOVE]:1,[WORK]:2},minAbsEnergyAvailable:300,minEnergyAvailable:1,maxMulti:e=>this.maxMulti(e),maxCount:e=>this.maxCount(e)}}get level8(){return{fixedBody:{[CARRY]:1,[MOVE]:3},multiBody:[WORK],minAbsEnergyAvailable:1700,minEnergyAvailable:.5,maxMulti:CONTROLLER_MAX_UPGRADE_PER_TICK/UPGRADE_CONTROLLER_POWER,maxCount:e=>this.maxCount(e)}}get RCL(){return{1:this.none,2:this.low,3:this.default,4:this.default,5:this.default,6:this.default,7:this.default,8:this.level8}}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(5);t.default=new class extends o.CreepSetup{constructor(){super("worker"),this.maxWorker=(e=>{let t=0;return(e.structures.fortifyable.length>0||e.isCriticallyFortifyable)&&(t++,e.storage&&e.storage.store.energy>4e5&&(t+=2)),e.RCL<4?e.situation.invasion?1:(2===e.RCL?3*e.sources.length:2*e.sources.length)-(e.population&&e.population.typeCount.pioneer||0):(this.hasMinerOrHauler(e)||t++,e.myConstructionSites.length>0&&(!e.storage||!e.storage.active||e.storage.store&&e.storage.charge>0)&&t<=1&&t++,t)}),this.hasMinerOrHauler=(e=>!!e.population&&(e.population.typeCount.hauler>0||e.population.typeCount.miner>0)),this.byPopulation=((e,t,r,o)=>{let a=t;return e.population&&(a+=e.population.typeCount[this.type]*r),!o||a<=o?a:o}),this.minEnergyAvailable=(e=>{switch(e.RCL){case 1:return this.byPopulation(e,0,1,1);case 2:return this.byPopulation(e,0,.8,1);case 3:return this.byPopulation(e,0,.6,1);case 4:return this.hasMinerOrHauler(e)?.5:0;case 7:return this.hasMinerOrHauler(e)?.2:1;default:return this.hasMinerOrHauler(e)?.1:1}}),this.maxMulti=((e,t,r,o)=>_.min([Math.floor((e.energyCapacityAvailable-t)/r),Math.floor(50/o)]))}get default(){return{fixedBody:[],multiBody:{[CARRY]:1,[WORK]:1,[MOVE]:1},minMulti:1,maxMulti:e=>this.maxMulti(e,0,200,_.size(this.default.multiBody)),maxWeight:9600,maxCount:e=>this.maxWorker(e),minEnergyAvailable:e=>this.minEnergyAvailable(e)}}get low(){return{fixedBody:[],multiBody:{[CARRY]:1,[WORK]:1,[MOVE]:2},minMulti:1,maxMulti:8,maxWeight:e=>2===e.RCL?14400:4e3,maxCount:e=>this.maxWorker(e),minEnergyAvailable:e=>this.minEnergyAvailable(e)}}get RCL(){return{1:this.low,2:this.low,3:this.default,4:this.default,5:this.default,6:this.default,7:this.default,8:this.default}}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(3),a=r(8);t.default=new class extends o.Component{constructor(){super(...arguments),this.pathfinderCache={},this.pathfinderCacheDirty=!1,this.pathfinderCacheLoaded=!1,this.COSTMATRIX_CACHE_VERSION=COMPRESS_COST_MATRICES?4:5,this.extend=(()=>{for(const e of Object.keys(RoomManager.extra))RoomManager.extra[e].extend&&RoomManager.extra[e].extend()}),this.fresh=(()=>{a.Install(RoomManager,{newInvader:new o.EventConstructor,knownInvader:new o.EventConstructor,goneInvader:new o.EventConstructor,collapsed:new o.EventConstructor,costMatrixInvalid:new o.EventConstructor,RCLChange:new o.EventConstructor});for(const e of Object.keys(RoomManager.extra))RoomManager.extra[e].fresh&&RoomManager.extra[e].fresh();_.forEach(Game.rooms,e=>{_.forEach(RoomManager.extra,t=>{t.freshRoom&&t.freshRoom(e)})})}),this.register=(()=>{_.forEach(RoomManager.extra,e=>{e.register&&e.register()}),RoomManager.costMatrixInvalid.on(e=>this.rebuildCostMatrix(e.name||e)),RoomManager.RCLChange.on(e=>e.structures.all.filter(e=>![STRUCTURE_ROAD,STRUCTURE_WALL,STRUCTURE_RAMPART].includes(e.structureType)).forEach(t=>{t.isActive()||_.set(e.memory,["structures",t.id,"active"],!1)}))}),this.analyze=(()=>{_.forEach(RoomManager.extra,e=>{e.analyze&&e.analyze()});const e=e=>{try{const t=e.name,r=_.includes(CPU_CHECK_CONFIG.ROOM,t);for(const o of Object.keys(RoomManager.extra))r&&CPU.check("analyze",t,o),RoomManager.extra[o].analyzeRoom&&RoomManager.extra[o].analyzeRoom(e,this.needMemoryResync(e)),r&&CPU.end("analyze",t,o);r&&CPU.check("analyze",t,"countMySites"),this.totalSitesChanged()&&e.countMySites(),r&&CPU.end("analyze",t,"countMySites"),r&&CPU.check("analyze",t,"countMyStructures"),this.totalStructuresChanged()&&e.countMyStructures(),r&&CPU.end("analyze",t,"countMyStructures"),e.checkRCL()}catch(t){Game.notify(t+"<br/>"+t.stack),Log.error(`Error in room.js (RoomManager.prototype.loop) for "${e.name}":`,"<br/>",t.stack||t.toString(),"<br/>",t.stack)}};_.forEach(Game.rooms,t=>{t.skip||e(t)})}),this.run=(()=>{_.forEach(RoomManager.extra,e=>{e.run&&e.run()}),_.forEach(Memory.rooms,(e,t)=>{((e,t)=>{try{const r=_.includes(CPU_CHECK_CONFIG.ROOM,t);for(const o of Object.keys(RoomManager.extra))r&&CPU.check("run",t,o),RoomManager.extra[o].runRoom&&RoomManager.extra[o].runRoom(e,t),r&&CPU.end("run",t,o);r&&CPU.check("run",t,"collapsed");const o=Game.rooms[t];o&&o.collapsed&&RoomManager.collapsed.trigger(o),r&&CPU.end("run",t,"collapsed")}catch(e){Log.error(e.stack||e.message)}})(e,t),Game.time%MEMORY_RESYNC_INTERVAL!=0||Game.rooms[t]||_.isBoolean(Memory.rooms[t].hostile)||delete Memory.rooms[t]})}),this.cleanup=(()=>{if(_.forEach(RoomManager.extra,e=>{e.cleanup&&e.cleanup()}),_.isUndefined(Memory.pathfinder)||(MemoryManager.saveSegment(MEM_SEGMENTS.COSTMATRIX_CACHE,Memory.pathfinder),delete Memory.pathfinder),this.pathfinderCacheDirty&&this.pathfinderCacheLoaded){let e={};for(const t in this.pathfinderCache){const r=this.pathfinderCache[t];r.version===this.COSTMATRIX_CACHE_VERSION&&(e[t]={serializedMatrix:r.serializedMatrix||(COMPRESS_COST_MATRICES?CompressedMatrix.serialize(r.costMatrix):r.costMatrix.serialize()),updated:r.updated,version:r.version},r.stale&&(e[t].stale=!0))}MemoryManager.saveSegment(MEM_SEGMENTS.COSTMATRIX_CACHE,e),this.pathfinderCacheDirty=!1}}),this.totalSitesChanged=(()=>{let e;if(Game.time!==Memory.rooms.myTotalSitesChangeTime){const t=_.size(Game.constructionSites),r=Memory.rooms.myTotalSites||0;e=r&&r!==t,Memory.rooms.myTotalSitesChange=e,Memory.rooms.myTotalSitesChangeTime=Game.time,t>0?Memory.rooms.myTotalSites=t:delete Memory.rooms.myTotalSites}else e=Memory.rooms.myTotalSitesChange;return e}),this.totalStructuresChanged=(()=>{let e;if(Game.time!==Memory.rooms.myTotalStructuresChangeTime){const t=Object.keys(Game.structures).length,r=Memory.rooms.myTotalStructures||0;e=r&&r!==t,Memory.rooms.myTotalStructuresChange=e,Memory.rooms.myTotalStructuresChangeTime=Game.time,t>0?Memory.rooms.myTotalStructures=t:delete Memory.rooms.myTotalStructures}else e=Memory.rooms.myTotalStructuresChange;return e}),this.needMemoryResync=(e=>_.isUndefined(e.memory.initialized)?(e.memory.initialized=Game.time,!0):Game.time%MEMORY_RESYNC_INTERVAL==0||"sim"==e.name),this.routeCallback=((e,t,r)=>((_.isUndefined(e)||_.isUndefined(t))&&Log.error("RoomManager.routeCallback","both origin and destination must be defined - origin:"+e+" destination:"+t),o=>{if(Game.map.getRoomLinearDistance(e,o)>r.restrictDistance)return!1;if(o!==t&&ROUTE_ROOM_COST[Game.shard.name]&&ROUTE_ROOM_COST[Game.shard.name][o])return ROUTE_ROOM_COST[Game.shard.name][o];let a=!1;if(r.preferHighway){const e=/^[WE]([0-9]+)[NS]([0-9]+)$/.exec(o);a=e[1]%10==0||e[2]%10==0}let i=!1;const n=_.get(Memory.rooms[o],"hostile",!1);if(r.checkOwner){const e=Game.rooms[o];i=!n||e&&e.controller&&(e.controller.my||void 0===e.controller.owner)}return!r.allowSK&&this.isSKRoom(o)?10:!r.allowHostile&&n&&o!==t&&o!==e?Number.POSITIVE_INFINITY:i||o==e||o==t?1:a?3:Game.map.isRoomAvailable(o)?r.checkOwner||r.preferHighway?11:1:Number.POSITIVE_INFINITY})),this.getCostMatrix=(e=>{let t=Game.rooms[e];if(t)return t.costMatrix}),this.isMine=(e=>{let t=Game.rooms[e];return t&&t.my}),this.calcCardinalDirection=(e=>{const t=/^([WE])[0-9]+([NS])[0-9]+$/.exec(e);return[t[1],t[2]]}),this.calcGlobalCoordinates=((e,t)=>{if(!t)return null;const r=/^[WE]([0-9]+)[NS]([0-9]+)$/.exec(e);return t(+r[1],+r[2])}),this.calcCoordinates=((e,t)=>t?this.calcGlobalCoordinates(e,(e,r)=>t(e%10,r%10)):null),this.isCenterRoom=(e=>RoomManager.calcCoordinates(e,(e,t)=>5===e&&5===t)),this.isCenterNineRoom=(e=>RoomManager.calcCoordinates(e,(e,t)=>e>3&&e<7&&t>3&&t<7)),this.isControllerRoom=(e=>RoomManager.calcCoordinates(e,(e,t)=>0!==e&&0!==t&&(e<4||e>6||t<4||t>6))),this.isSKRoom=(e=>RoomManager.calcCoordinates(e,(e,t)=>e>3&&e<7&&t>3&&t<7&&(5!==e||5!==t))),this.isHighwayRoom=(e=>RoomManager.calcCoordinates(e,(e,t)=>0===e||0===t)),this.adjacentRooms=(e=>{let t=e.split(/([NESW])/),r=["N","E","S","W"],o=e=>r[(r.indexOf(e)+2)%4],a=[];for(let e=parseInt(t[2])-1;e<parseInt(t[2])+2;e++)for(let r=parseInt(t[4])-1;r<parseInt(t[4])+2;r++)a.push((e<0?o(t[1])+"0":t[1]+e)+(r<0?o(t[3])+"0":t[3]+r));return a}),this.adjacentAccessibleRooms=((e,t=!0)=>{let r=[],o=Game.map.describeExits(e);return _.forEach(o,(e,o)=>{if(t){let t=Game.map.describeExits(e),a=(o+1)%8+1,i=(o+5)%8+1;t&&t[a]&&!r.includes(t[a])&&r.push(t[a]),t&&t[i]&&!r.includes(t[i])&&r.push(t[i])}r.push(e)}),r}),this.roomDistance=((e,t,r,o)=>{if(r)return Game.map.getRoomLinearDistance(e,t,o);if(e==t)return 0;let a=e.split(/([NESW])/),i=t.split(/([NESW])/);return(a[1]==i[1]?Math.abs(a[2]-i[2]):a[2]+i[2]+1)+(a[3]==i[3]?Math.abs(a[4]-i[4]):a[4]+i[4]+1)}),this.rebuildCostMatrix=(e=>{Log.room(e,"Invalidating costmatrix to force a rebuild when we have vision."),_.set(Room,["pathfinderCache",e,"stale"],!0),_.set(Room,["pathfinderCache",e,"updated"],Game.time),this.pathfinderCacheDirty=!0}),this.loadCostMatrixCache=(e=>{let t=0;for(const r in e)(!this.pathfinderCache[r]||this.pathfinderCache[r].updated<e[r].updated)&&(t++,this.pathfinderCache[r]=e[r]);t>0&&Log.module("MemoryManager","loading pathfinder cache.. updated "+t+" stale entries."),this.pathfinderCacheLoaded=!0}),this.getCachedStructureMatrix=(e=>{if((e=>{if(_.isUndefined(this.pathfinderCache))return this.pathfinderCache={},this.pathfinderCache[e]={},!1;if(_.isUndefined(this.pathfinderCache[e]))return this.pathfinderCache[e]={},!1;const t=this.pathfinderCache[e],r=Game.time-t.updated;return!(t.version!==this.COSTMATRIX_CACHE_VERSION||!t.serializedMatrix&&!t.costMatrix||t.stale||!(r<COST_MATRIX_VALIDITY)||(LOG_TRACE&&Log.trace("PathFinder",{roomName:e,ttl:r,PathFinder:"CostMatrix"},"cached costmatrix"),0))})(e)){const t=this.pathfinderCache[e];if(t.costMatrix)return t.costMatrix;if(t.serializedMatrix){const e=COMPRESS_COST_MATRICES?CompressedMatrix.deserialize(t.serializedMatrix):PathFinder.CostMatrix.deserialize(t.serializedMatrix);return t.costMatrix=e,e}Log.error("RoomManager.getCachedStructureMatrix",`Cached costmatrix for ${e} is invalid ${t}`),delete this.pathfinderCache[e]}}),this.getStructureMatrix=((e,t)=>{const r=Game.rooms[e];let o;return(o=this.isSKRoom(e)&&t.avoidSKCreeps?_.get(r,"avoidSKMatrix"):_.get(r,"structureMatrix"))||(o=_.get(this.getCachedStructureMatrix(e),"costMatrix")),o}),this.validFields=((e,t,r,o,a,i=!1,n=null)=>{const s=Game.rooms[e],l=i?s.lookAtArea(o,t,a,r):null;let m=[];for(let c=t;c<=r;c++)for(let t=o;t<=a;t++)if(c>1&&c<48&&t>1&&t<48&&(!i||s.isWalkable(c,t,l))){let r=new RoomPosition(c,t,e);n&&!n(r)||m.push(r)}return m}),this.fieldsInRange=(e=>{let t=e.spots.map(e=>e.pos.x+e.range),r=e.spots.map(e=>e.pos.y+e.range),o=e.spots.map(e=>e.pos.x-e.range),a=e.spots.map(e=>e.pos.y-e.range),i=Math.max(...o),n=Math.min(...t),s=Math.max(...a),l=Math.min(...r);return this.validFields(e.roomName,i,n,s,l,e.checkWalkable,e.where)}),this.shouldRepair=((e,t)=>t.hits<t.hitsMax&&(!e.my||t.hits<MAX_REPAIR_LIMIT[e.RCL]||t.hits<LIMIT_URGENT_REPAIRING+(2*DECAY_AMOUNT[t.structureType]||0))&&(!DECAYABLES.includes(t.structureType)||t.hitsMax-t.hits>GAP_REPAIR_DECAYABLE)&&(void 0===Memory.pavementArt[e.name]||Memory.pavementArt[e.name].indexOf("x"+t.pos.x+"y"+t.pos.y+"x")<0)&&!FlagManager.list.some(e=>e.roomName==t.pos.roomName&&e.color==COLOR_ORANGE&&e.x==t.pos.x&&e.y==t.pos.y))}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(2);t.default=new class extends o.RoomExtra{constructor(){super("construction"),this.register=(()=>{FlagManager.found.on(e=>RoomManager.roomLayout(e))}),this.analyzeRoom=((e,t)=>{t&&e.processConstructionFlags(),e.roadConstruction()}),this.prototypeExtend=(()=>{this.assignRoomPrototype({constructionSites:{get(){return _.isUndefined(this._constructionSites)&&(this._constructionSites=this.find(FIND_CONSTRUCTION_SITES)),this._constructionSites}},myConstructionSites:{get(){return _.isUndefined(this._myConstructionSites)&&(this._myConstructionSites=this.find(FIND_MY_CONSTRUCTION_SITES)),this._myConstructionSites}},roadConstructionTrace:{get(){return _.isUndefined(this.memory.roadConstructionTrace)&&(this.memory.roadConstructionTrace={}),this.memory.roadConstructionTrace},set(e){this.memory.roadConstructionTrace=e}},getBestConstructionSiteFor:{value(e,t=null){let r;if(0==(r=t?this.constructionSites.filter(t):this.constructionSites).length)return null;let o=Util.fieldOrFunction(CONSTRUCTION_PRIORITY,this);return _.min(r,t=>{let r=o.indexOf(t.structureType);return e.getRangeTo(t)+(r<0?1e5:100*r)})}},roadConstruction:{value(e=ROAD_CONSTRUCTION_MIN_DEVIATION){const t=ROAD_CONSTRUCTION_FORCED_ROOMS[Game.shard.name]&&-1!=ROAD_CONSTRUCTION_FORCED_ROOMS[Game.shard.name].indexOf(this.name);if(!ROAD_CONSTRUCTION_ENABLE&&!t||Game.time%ROAD_CONSTRUCTION_INTERVAL!=0)return;if(!t&&_.isNumber(ROAD_CONSTRUCTION_ENABLE)&&(!this.my||ROAD_CONSTRUCTION_ENABLE>this.controller.level))return;let r=Object.keys(this.roadConstructionTrace).map(e=>({n:this.roadConstructionTrace[e],x:e.charCodeAt(0)-32,y:e.charCodeAt(1)-32})),o=Math.max(ROAD_CONSTRUCTION_ABS_MIN,r.reduce((e,t)=>e+t.n,0)/r.length*e);r=r.filter(e=>{if(e.n>=o){let t=this.lookForAt(LOOK_STRUCTURES,e.x,e.y);return(0===t.length||t[0].structureType===STRUCTURE_RAMPART)&&0===this.lookForAt(LOOK_CONSTRUCTION_SITES,e.x,e.y).length}return!1}),_.forEach(r,e=>{Log.module(this.name,`Constructing new road at ${e.x}'${e.y} (${e.n} Log.traces)`),this.createConstructionSite(e.x,e.y,STRUCTURE_ROAD)}),this.roadConstructionTrace={}}},processConstructionFlags:{value(){if(!this.my||!Util.fieldOrFunction(SEMI_AUTOMATIC_CONSTRUCTION,this))return;let e=_.size(Game.constructionSites);if(e>=100)return;const t=this.controller.level,r=[new RoomPosition(25,25,this.name),!0],o=(t,r)=>{if(e>=100)return;if(!t)return;const o=new RoomPosition(t.x,t.y,t.roomName);if(!o)return;const a=o.lookFor(LOOK_CONSTRUCTION_SITES);if(a&&a.length)return;const i=o.lookFor(LOOK_STRUCTURES).filter(e=>!(e instanceof StructureRoad||e instanceof StructureRampart));if(i&&i.length)return;const n=o.createConstructionSite(r);Util.fieldOrFunction(REMOVE_CONSTRUCTION_FLAG,this,r)&&n===OK&&(t.name&&(t=Game.flags[t.name])instanceof Flag&&t.remove(),e++)};let a=CONTROLLER_STRUCTURES[STRUCTURE_EXTENSION][t]-(this.structures.extensions.length+_.filter(this.constructionSites,e=>e.structureType===STRUCTURE_EXTENSION).length);if(a>0&&FlagManager.filter(FLAG_COLOR.construct,...r).splice(0,a).forEach(e=>{o(e,STRUCTURE_EXTENSION)}),(a=CONTROLLER_STRUCTURES[STRUCTURE_SPAWN][t]-(this.structures.spawns.length+_.filter(this.constructionSites,e=>e.structureType===STRUCTURE_SPAWN).length))>0&&FlagManager.filter(FLAG_COLOR.construct.spawn,...r).splice(0,a).forEach(e=>{o(e,STRUCTURE_SPAWN)}),(a=CONTROLLER_STRUCTURES[STRUCTURE_TOWER][t]-(this.structures.towers.length+_.filter(this.constructionSites,e=>e.structureType===STRUCTURE_TOWER).length))>0&&FlagManager.filter(FLAG_COLOR.construct.tower,...r).splice(0,a).forEach(e=>{o(e,STRUCTURE_TOWER)}),(a=CONTROLLER_STRUCTURES[STRUCTURE_LINK][t]-(this.structures.links.all.length+_.filter(this.constructionSites,e=>e.structureType===STRUCTURE_LINK).length))>0&&FlagManager.filter(FLAG_COLOR.construct.link,...r).splice(0,a).forEach(e=>{o(e,STRUCTURE_LINK)}),(a=CONTROLLER_STRUCTURES[STRUCTURE_LAB][t]-(this.structures.labs.all.length+_.filter(this.constructionSites,e=>e.structureType===STRUCTURE_LAB).length))>0&&FlagManager.filter(FLAG_COLOR.construct.lab,...r).splice(0,a).forEach(e=>{o(e,STRUCTURE_LAB)}),!this.storage&&CONTROLLER_STRUCTURES[STRUCTURE_STORAGE][t]>0&&FlagManager.filter(FLAG_COLOR.construct.storage,...r).splice(0,1).forEach(e=>{o(e,STRUCTURE_STORAGE)}),!this.terminal&&CONTROLLER_STRUCTURES[STRUCTURE_TERMINAL][t]>0&&FlagManager.filter(FLAG_COLOR.construct.terminal,...r).splice(0,1).forEach(e=>{o(e,STRUCTURE_TERMINAL)}),!this.structures.observer&&CONTROLLER_STRUCTURES[STRUCTURE_OBSERVER][t]>0&&FlagManager.filter(FLAG_COLOR.construct.observer,...r).splice(0,1).forEach(e=>{o(e,STRUCTURE_OBSERVER)}),!this.structures.nuker&&CONTROLLER_STRUCTURES[STRUCTURE_NUKER][t]>0&&FlagManager.filter(FLAG_COLOR.construct.nuker,...r).splice(0,1).forEach(e=>{o(e,STRUCTURE_NUKER)}),!this.structures.powerSpawn&&CONTROLLER_STRUCTURES[STRUCTURE_POWER_SPAWN][t]>0&&FlagManager.filter(FLAG_COLOR.construct.powerSpawn,...r).splice(0,1).forEach(e=>{o(e,STRUCTURE_POWER_SPAWN)}),CONTROLLER_STRUCTURES[STRUCTURE_EXTRACTOR][t]>0){const[e]=this.find(FIND_MINERALS),t=e.pos.lookFor(LOOK_STRUCTURES);if(t.length&&t[0]instanceof StructureExtractor)return;o(e.pos,STRUCTURE_EXTRACTOR)}}}})}),this.roomManagerExtend=(()=>{this.assignRoomManager({roomLayoutArray:[[null,null,null,null,null,STRUCTURE_EXTENSION,STRUCTURE_ROAD,STRUCTURE_EXTENSION],[null,null,null,STRUCTURE_ROAD,STRUCTURE_EXTENSION,STRUCTURE_ROAD,STRUCTURE_TOWER,STRUCTURE_ROAD,STRUCTURE_EXTENSION,STRUCTURE_ROAD],[null,null,STRUCTURE_ROAD,STRUCTURE_EXTENSION,STRUCTURE_ROAD,STRUCTURE_EXTENSION,STRUCTURE_SPAWN,STRUCTURE_EXTENSION,STRUCTURE_ROAD,STRUCTURE_EXTENSION,STRUCTURE_ROAD],[null,STRUCTURE_ROAD,STRUCTURE_EXTENSION,STRUCTURE_EXTENSION,STRUCTURE_EXTENSION,STRUCTURE_ROAD,STRUCTURE_TOWER,STRUCTURE_ROAD,STRUCTURE_EXTENSION,STRUCTURE_EXTENSION,STRUCTURE_EXTENSION,STRUCTURE_ROAD],[null,STRUCTURE_EXTENSION,STRUCTURE_ROAD,STRUCTURE_EXTENSION,STRUCTURE_EXTENSION,STRUCTURE_EXTENSION,STRUCTURE_ROAD,STRUCTURE_EXTENSION,STRUCTURE_EXTENSION,STRUCTURE_EXTENSION,STRUCTURE_ROAD,STRUCTURE_EXTENSION],[STRUCTURE_EXTENSION,STRUCTURE_ROAD,STRUCTURE_EXTENSION,STRUCTURE_ROAD,STRUCTURE_EXTENSION,STRUCTURE_ROAD,STRUCTURE_NUKER,STRUCTURE_ROAD,STRUCTURE_EXTENSION,STRUCTURE_ROAD,STRUCTURE_EXTENSION,STRUCTURE_ROAD,STRUCTURE_EXTENSION],[STRUCTURE_ROAD,STRUCTURE_TOWER,STRUCTURE_EXTENSION,STRUCTURE_SPAWN,STRUCTURE_ROAD,STRUCTURE_POWER_SPAWN,STRUCTURE_LINK,STRUCTURE_TERMINAL,STRUCTURE_ROAD,STRUCTURE_OBSERVER,STRUCTURE_EXTENSION,STRUCTURE_TOWER,STRUCTURE_ROAD],[STRUCTURE_EXTENSION,STRUCTURE_ROAD,STRUCTURE_EXTENSION,STRUCTURE_ROAD,STRUCTURE_EXTENSION,STRUCTURE_ROAD,STRUCTURE_STORAGE,STRUCTURE_ROAD,STRUCTURE_EXTENSION,STRUCTURE_ROAD,STRUCTURE_EXTENSION,STRUCTURE_ROAD,STRUCTURE_EXTENSION],[null,STRUCTURE_EXTENSION,STRUCTURE_ROAD,STRUCTURE_EXTENSION,STRUCTURE_EXTENSION,STRUCTURE_EXTENSION,STRUCTURE_ROAD,STRUCTURE_EXTENSION,STRUCTURE_EXTENSION,STRUCTURE_EXTENSION,STRUCTURE_ROAD,STRUCTURE_EXTENSION],[null,STRUCTURE_ROAD,STRUCTURE_EXTENSION,STRUCTURE_EXTENSION,STRUCTURE_EXTENSION,STRUCTURE_ROAD,STRUCTURE_TOWER,STRUCTURE_ROAD,STRUCTURE_EXTENSION,STRUCTURE_EXTENSION,STRUCTURE_EXTENSION,STRUCTURE_ROAD],[null,null,STRUCTURE_ROAD,STRUCTURE_EXTENSION,STRUCTURE_ROAD,STRUCTURE_EXTENSION,STRUCTURE_SPAWN,STRUCTURE_EXTENSION,STRUCTURE_ROAD,STRUCTURE_EXTENSION,STRUCTURE_ROAD],[null,null,null,STRUCTURE_ROAD,STRUCTURE_EXTENSION,STRUCTURE_ROAD,STRUCTURE_TOWER,STRUCTURE_ROAD,STRUCTURE_EXTENSION,STRUCTURE_ROAD],[null,null,null,null,null,STRUCTURE_EXTENSION,STRUCTURE_ROAD,STRUCTURE_EXTENSION]],roomLayout:e=>{if(!FlagManager.compare(e,FLAG_COLOR.command.roomLayout))return;const t=(e=Game.flags[e.name]).room;if(!t)return;const r=RoomManager.roomLayoutArray,o={[STRUCTURE_SPAWN]:FLAG_COLOR.construct.spawn,[STRUCTURE_TOWER]:FLAG_COLOR.construct.tower,[STRUCTURE_EXTENSION]:FLAG_COLOR.construct,[STRUCTURE_LINK]:FLAG_COLOR.construct.link,[STRUCTURE_STORAGE]:FLAG_COLOR.construct.storage,[STRUCTURE_TERMINAL]:FLAG_COLOR.construct.terminal,[STRUCTURE_NUKER]:FLAG_COLOR.construct.nuker,[STRUCTURE_POWER_SPAWN]:FLAG_COLOR.construct.powerSpawn,[STRUCTURE_OBSERVER]:FLAG_COLOR.construct.observer},[a,i]=[e.pos.x,e.pos.y],n=[],s=[],l=()=>(e.pos.newFlag(FLAG_COLOR.command.invalidPosition,"NO_ROOM"),e.remove(),!1);for(let e=0;e<r.length;e++)for(let m=0;m<r[e].length;m++){const c=Math.floor(a+(e-r.length/2)+1),u=Math.floor(i+(m-r.length/2)+1);if(c>=50||c<0||u>=50||u<0)return l();const d=t.getPositionAt(c,u),h=r[e]&&r[e][m];if(h){if("wall"===Game.map.getTerrainAt(d))return l();if(h===STRUCTURE_ROAD)s.push(d);else{const e=o[h];n.push({flagColour:e,pos:d})}}}n.forEach(e=>{e.pos.newFlag(e.flagColour)}),_.forEach(s,e=>{if(_.size(Game.constructionSites)>=100)return!1;e.createConstructionSite(STRUCTURE_ROAD)}),e.remove()}})})}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(2);t.default=new class extends o.RoomExtra{constructor(){super("container"),this.analyzeRoom=((e,t)=>{t&&e.saveContainers()}),this.prototypeExtend=(()=>{this.assignRoomPrototype({saveContainers:{value(){let e=this.structures.all.filter(e=>e.structureType==STRUCTURE_CONTAINER);if(e.length>0){this.memory.container=[];let t=e=>{let t=this.find(FIND_MINERALS),r=e.pos.findInRange(this.sources,2),o=e.pos.findInRange(t,2),a=!!(this.my&&e.pos.getRangeTo(this.controller)<=3);this.memory.container.push({id:e.id,source:r.length>0,controller:a,mineral:o.length>0});let i=t=>t.memory.container=e.id;r.forEach(i),o.forEach(i)};e.forEach(t)}else delete this.memory.container;if(this.terminal){let e=[],t=t=>{e=_(e).concat(RoomManager.validFields(this.name,t.pos.x-1,t.pos.x+1,t.pos.y-1,t.pos.y+1,!0))};_.forEach(this.sources,t);let r=this.terminal.pos.findClosestByRange(e,1),o=[];r&&(1==this.sources.length?o=this.sources:o.push(r.isNearTo(this.sources[0])?this.sources[0]:this.sources[1]));let a=this.terminal.pos.findInRange(this.minerals,2),i=e=>e.memory.terminal=this.terminal.id;o.forEach(i),a.forEach(i),this.terminal.pos.getRangeTo(this.controller)<4&&(this.controller.memory.storage=this.terminal.id)}if(this.storage){let e=this.storage.pos.findInRange(this.sources,2),t=this.storage.pos.findInRange(this.minerals,2),r=e=>e.memory.storage=this.storage.id;e.forEach(r),t.forEach(r),this.storage.pos.getRangeTo(this.controller)<4&&(this.controller.memory.storage=this.storage.id)}}},findContainerWith:{value(e,t){t||(t=1);let r=this.memory;if(r&&r.container&&r.container.length>0)for(let o=0;o<r.container.length;o++){let a=r.container[o],i=Game.getObjectById(a.id);if(i){let r=-i.getNeeds(e);if((!this.structures.container.out.includes(i)||e!==RESOURCE_ENERGY)&&r>0&&r>=t)return{structure:i,amount:r}}}return null}}})}),this.roomManagerExtend=(()=>{this.assignRoomManager({Containers:function(e){this.room=e,Object.defineProperties(this,{all:{get(){if(_.isUndefined(this._container)){this._container=[];let e=e=>{let t=Game.getObjectById(e.id);t&&(_.assign(t,e),this._container.push(t))};_.forEach(this.room.memory.container,e)}return this._container}},controller:{get(){if(_.isUndefined(this._controller))if(this.room.my&&this.room.controller.memory.storage)this._controller=[Game.getObjectById(this.room.controller.memory.storage)],this._controller[0]||delete this.room.controller.memory.storage;else{let e=e=>1==e.controller;this._controller=_.filter(this.all,e)}return this._controller}},in:{get(){if(_.isUndefined(this._in)){let e=e=>0==e.controller;this._in=_.filter(this.all,e);let t=e=>e.sum>=e.storeCapacity*(1-MANAGED_CONTAINER_TRIGGER);this._in=this._in.concat(this.managed.filter(t))}return this._in}},out:{get(){if(_.isUndefined(this._out)){let e=e=>1==e.controller;this._out=_.filter(this.all,e);let t=e=>e.sum<=e.storeCapacity*MANAGED_CONTAINER_TRIGGER;this._out=this._out.concat(this.managed.filter(t))}return this._out}},privateers:{get(){if(_.isUndefined(this._privateers)){let e=e=>!1===e.source&&!e.mineral&&e.sum<e.storeCapacity;this._privateers=_.filter(this.all,e)}return this._privateers}},managed:{get(){if(_.isUndefined(this._managed)){let e=e=>!0===e.source&&1==e.controller;this._managed=_.filter(this.all,e)}return this._managed}}})}})})}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(2);t.default=new class extends o.RoomExtra{constructor(){super("defense"),this.analyzeRoom=(e=>{(e.hostiles.length||e.memory.hostileIds&&e.memory.hostileIds.length)&&e.processInvaders()}),this.runRoom=((e,t)=>{const r=Game.rooms[t];r?(r.goneInvader.forEach(this._triggerGoneInvaders),r.hostileIds.forEach(this._triggerKnownInvaders),r.newInvader.forEach(this._triggerNewInvaders)):e.hostileIds&&_.forEach(e.hostileIds,this._triggerKnownInvaders)}),this.freshRoom=(e=>{e.newInvader=[],e.goneInvader=[]}),this._triggerNewInvaders=(e=>{const t=JSON.stringify(_.countBy(e.body,"type"));(NOTIFICATE_INVADER||NOTIFICATE_INTRUDER&&e.room.my||NOTIFICATE_HOSTILES)&&(Log.room(e.pos.roomName,Dye(COLOR_RED,`Hostile intruder from "${e.owner.username}".`)),Log.table(t)),(NOTIFICATE_INVADER||NOTIFICATE_INTRUDER&&"Invader"!==e.owner.username&&"Source Keeper"!==e.owner.username&&e.room.my||NOTIFICATE_HOSTILES&&"Invader"!==e.owner.username&&"Source Keeper"!==e.owner.username)&&Game.notify(`Hostile intruder ${e.id} (${t}) from "${e.owner.username}" in room ${e.pos.roomName} at ${Util.toDateTimeString(Util.toLocalDate(new Date))}`),RoomManager.newInvader.trigger(e)}),this._triggerKnownInvaders=(e=>RoomManager.knownInvader.trigger(e)),this._triggerGoneInvaders=(e=>RoomManager.goneInvader.trigger(e))}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(2);t.default=new class extends o.RoomExtra{constructor(){super("extension"),this.analyzeRoom=((e,t)=>{t&&e.saveExtensions()}),this.prototypeExtend=(()=>{this.assignRoomPrototype({saveExtensions:{value(){const e=this.find(FIND_MY_STRUCTURES,{filter:e=>e instanceof StructureExtension}).map(e=>e.id);e.length>0?this.memory.extensions=e:delete this.memory.extensions}}})})}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(2);t.default=new class extends o.RoomExtra{constructor(){super("lab"),this.analyzeRoom=((e,t)=>{t&&e.saveLabs(),e.structures.labs.all.length>0&&e.processLabs()}),this.prototypeExtend=(()=>{this.assignRoomPrototype({saveLabs:{value(){let e=this.find(FIND_MY_STRUCTURES,{filter:e=>e.structureType==STRUCTURE_LAB});if(e.length>0){this.memory.labs=[];let t=this.storage?this.storage.pos.findInRange(e,2).map(e=>e.id):[];this.memory.labs=[];let r=e=>{this.memory.labs.find(t=>t.id==e.id)||this.memory.labs.push({id:e.id,storage:t.includes(e.id)})};e.forEach(r)}else delete this.memory.labs}},processLabs:{value(){if(Game.time%LAB_COOLDOWN!=5)return;let e=this.find(FIND_MY_STRUCTURES,{filter:e=>e.structureType==STRUCTURE_LAB});if(!this.memory.resources)return;let t=e.filter(e=>{let t=this.memory.resources.lab.find(t=>t.id==e.id);return!!t&&t.slave_a&&t.slave_b});for(let e=0;e<t.length;e++){let r=t[e];if(r.cooldown>0)continue;let o=this.memory.resources.lab.find(e=>e.id==r.id);if(!o)continue;let a=o.reactionType;if(r.mineralAmount>0&&r.mineralType!=a)continue;let i=Game.getObjectById(o.slave_a),n=Game.getObjectById(o.slave_b);i&&i.mineralType==LAB_REACTIONS[a][0]&&n&&n.mineralType==LAB_REACTIONS[a][1]&&r.runReaction(i,n)==OK&&(o.reactionAmount-=LAB_REACTION_AMOUNT,LOG_TRACE&&Log.trace("Room",{roomName:this.name,actionName:"processLabs",labId:r.id,resourceType:a,amountRemaining:o.reactionAmount}),o.reactionAmount<=0&&this.cancelReactionOrder(r.id))}let r=this.memory.resources.reactions;if(r)switch(r.reactorType){case REACTOR_TYPE_FLOWER:this.processReactorFlower()}}},processReactorFlower:{value(){let e=this.memory.resources.reactions;if(!e||e.reactorType!==REACTOR_TYPE_FLOWER)return;for(let t=0;t<e.orders.length&&e.orders[t].amount<LAB_REACTION_AMOUNT;t++)e.orders.splice(t--,1);if(0===e.orders.length){let t=this.find(FIND_MY_STRUCTURES,{filter:e=>e.structureType==STRUCTURE_LAB});for(let e=0;e<t.length;e++){let r=t[e],o=this.memory.resources.lab.find(e=>e.id===r.id);!o||o.reactionState!==LAB_IDLE&&o.reactionState!==LAB_SEED||this.cancelReactionOrder(r.id)}return void(e.reactorMode=REACTOR_MODE_IDLE)}let t=e.orders[0];switch(e.reactorMode=t.mode,e.reactorMode){case REACTOR_MODE_BURST:this.processReactorFlowerBurst()}}},processReactorFlowerBurst:{value(){let e=this.memory.resources.reactions;if(!e||e.reactorType!==REACTOR_TYPE_FLOWER||e.reactorMode!==REACTOR_MODE_BURST)return;let t=e.orders[0];if(t.mode!==REACTOR_MODE_BURST)return;let r=LAB_REACTIONS[t.type][0],o=LAB_REACTIONS[t.type][1],a=Game.getObjectById(e.seed_a),i=Game.getObjectById(e.seed_b),n=_.filter(Game.rooms,{my:!0}),s=!1,l=!1,m=e=>{let t=0;for(let r of n){if(r.name===this.name)continue;let o=r.resourcesAll[e]||0;o>=MIN_OFFER_AMOUNT&&(t+=o)}return t},c=m(r),u=m(o);if(!a||!i)return;let d=this.memory.resources.lab.find(t=>t.id===e.seed_a),h=this.memory.resources.lab.find(t=>t.id===e.seed_b);if(!d||!_.some(d.orders,"type",r)){this.placeOrder(e.seed_a,r,t.amount),l=!0;const o=(this.resourcesStorage[r]||0)+(this.resourcesTerminal[r]||0)+(this.resourcesLabs[r]||0);let a=(this.resourcesOffers[r]||0)+t.amount-o,i=Util.roundUpTo(a,MIN_OFFER_AMOUNT);a<TRADE_THRESHOLD&&a>0?c>=TRADE_THRESHOLD?a=TRADE_THRESHOLD:c>=i&&(a=i):a>0&&i<=c&&(a=i),a>0&&a<=c&&(this.placeRoomOrder(e.seed_a,r,a),s=!0),(d=this.memory.resources.lab.find(t=>t.id===e.seed_a)).reactionType=r}if(!h||!_.some(h.orders,"type",o)){this.placeOrder(e.seed_b,o,t.amount),l=!0;const r=(this.resourcesStorage[o]||0)+(this.resourcesTerminal[o]||0)+(this.resourcesLabs[o]||0);let a=(this.resourcesOffers[o]||0)+t.amount-r,i=Util.roundUpTo(a,MIN_OFFER_AMOUNT);a<TRADE_THRESHOLD&&a>0?u>=TRADE_THRESHOLD?a=TRADE_THRESHOLD:u>=i&&(a=i):a>0&&i<=u&&(a=i),a>0&&a<=u&&(this.placeRoomOrder(e.seed_b,o,a),s=!0),(h=this.memory.resources.lab.find(t=>t.id===e.seed_b)).reactionType=o}if(!d||!h)return;let g=d.orders.find(e=>e.type===r),p=h.orders.find(e=>e.type===o);if(!g||g.amount<t.amount){let o=t.amount-(g?g.orderAmount:0);this.placeOrder(e.seed_a,r,o),l=!0;const a=(this.resourcesStorage[r]||0)+(this.resourcesTerminal[r]||0)+(this.resourcesLabs[r]||0);let i=(this.resourcesOffers[r]||0)+t.amount-a,n=Util.roundUpTo(i,MIN_OFFER_AMOUNT);i<TRADE_THRESHOLD&&i>0?c>=TRADE_THRESHOLD?i=TRADE_THRESHOLD:c>=n&&(i=n):i>0&&n<=c&&(i=n),i>0&&i<=c&&(this.placeRoomOrder(e.seed_a,r,i),s=!0),i>0&&(this.placeRoomOrder(e.seed_a,r,i),s=!0)}if(!p||p.amount<t.amount){let r=t.amount-(p?p.orderAmount:0);this.placeOrder(e.seed_b,o,r),l=!0;const a=(this.resourcesStorage[o]||0)+(this.resourcesTerminal[o]||0)+(this.resourcesLabs[o]||0);let i=(this.resourcesOffers[o]||0)+t.amount-a,n=Util.roundUpTo(i,MIN_OFFER_AMOUNT);i<TRADE_THRESHOLD&&i>0?u>=TRADE_THRESHOLD?i=TRADE_THRESHOLD:u>=n&&(i=n):i>0&&n<=u&&(i=n),i>0&&i<=u&&(this.placeRoomOrder(e.seed_b,o,i),s=!0),i>0&&(this.placeRoomOrder(e.seed_b,o,i),s=!0)}let f=this.memory.resources.boostTiming;s?(f.roomState="ordersPlaced",this.GCOrders()):l&&(f.roomState="ordersPlaced");let R=this.find(FIND_MY_STRUCTURES,{filter:e=>e.structureType==STRUCTURE_LAB}).filter(e=>{let t=this.memory.resources.lab.find(t=>t.id===e.id),r=this.memory.resources.reactions;return!t||t.reactionState===LAB_IDLE&&(t.id!==r.seed_a||t.id!==r.seed_b)});for(let e=0;e<R.length;e++){let r=R[e],o=this.memory.resources.lab.find(e=>e.id===r.id);o||(this.prepareReactionOrder(r.id,t.type,t.amount),o=this.memory.resources.lab.find(e=>e.id===r.id)),o&&(o.reactionType=t.type)}if(a.mineralType!==r||i.mineralType!==o)return;let y=Math.floor(Math.min(a.mineralAmount,i.mineralAmount,t.amount)/LAB_REACTION_AMOUNT);if(0===y)return;let C=0;for(let e=0;e<R.length;e++){let r=R[e];if(!(r.cooldown>0)&&(0===r.mineralAmount||r.mineralType===t.type&&r.mineralAmount<=r.mineralCapacity-LAB_REACTION_AMOUNT&&C<y)){C++;let e=r.runReaction(a,i);e===OK?(t.amount-=LAB_REACTION_AMOUNT,LOG_TRACE&&Log.trace("Room",{roomName:this.name,actionName:"processLabs",reactorType:REACTOR_TYPE_FLOWER,labId:r.id,resourceType:t.type,amountRemaining:t.amount})):Log.module(this.name,`${this.name} runReactions not OK. returnValue: ${Util.translateErrorCode(e)}`)}}}},cancelReactionOrder:{value(e,t){let r=this.memory.resources.lab.find(t=>t.id==e);if(!t||_.matches(t)(e)){if(r){r.slave_a&&this.cancelReactionOrder(r.slave_a,{master:e}),r.slave_b&&this.cancelReactionOrder(r.slave_b,{master:e}),[LAB_MASTER,LAB_SLAVE_1,LAB_SLAVE_2,LAB_SLAVE_3].includes(r.reactionState)&&(r.reactionState=LAB_IDLE),delete r.reactionType,delete r.reactionAmount,delete r.master,delete r.slave_a,delete r.slave_b,void 0===this.memory.resources&&(this.memory.resources={lab:[],container:[],terminal:[],storage:[]}),void 0===this.memory.resources.orders&&(this.memory.resources.orders=[]),this.memory.resources.orders;for(let e=0;e<r.orders.length;e++){let t=r.orders[e];t.type!=RESOURCE_ENERGY&&(t.orderAmount=0,t.orderRemaining=0,t.storeAmount=0)}}return OK}}},prepareReactionOrder:{value(e,t,r){if(r<=0)return OK;let o=Game.getObjectById(e);if(!this.my||!o||!o.structureType==STRUCTURE_LAB)return ERR_INVALID_TARGET;if(!LAB_REACTIONS.hasOwnProperty(t))return ERR_INVALID_ARGS;void 0===this.memory.resources&&(this.memory.resources={lab:[],container:[],terminal:[],storage:[]});let a=this.memory.resources.lab.find(t=>t.id==e);return a||(this.memory.resources.lab.push({id:e,orders:[],reactionState:LAB_IDLE}),a=this.memory.resources.lab.find(t=>t.id==e)),this.cancelReactionOrder(e),OK}},placeBasicReactionOrder:{value(e,t,r,o=1){if(r<=0)return OK;if(!LAB_REACTIONS.hasOwnProperty(t))return ERR_INVALID_ARGS;void 0===this.memory.resources&&(this.memory.resources={lab:[],container:[],terminal:[],storage:[]}),void 0===this.memory.resources.powerSpawn&&(this.memory.resources.powerSpawn=[]);let a=Game.getObjectById(e),i=LAB_REACTIONS[t][0],n=LAB_REACTIONS[t][1],s=null,l=null,m=a.pos.findInRange(FIND_MY_STRUCTURES,2,{filter:e=>e.structureType==STRUCTURE_LAB&&e.id!=a.id});for(let e=0;e<m.length;e++){let t=m[e],r=this.memory.resources.lab.find(e=>e.id==t.id);if(null==s&&r&&r.reactionType==i?s=t:null==l&&r&&r.reactionType==n&&(l=t),s&&l)break}if(!s||!l){m.sort((e,t)=>a.pos.getRangeTo(e)-a.pos.getRangeTo(t));for(let e=0;e<m.length;e++){let t=m[e],r=this.memory.resources.lab.find(e=>e.id==t.id);r&&r.reactionState&&r.reactionState!=LAB_IDLE||(null==s?s=t:null==l&&(l=t))}}if(null==s||null==l)return ERR_NOT_FOUND;let c=this.prepareReactionOrder(e,t,r);if(c!=OK)return c;if((c=this.prepareReactionOrder(s.id,t,r))!=OK)return c;if((c=this.prepareReactionOrder(l.id,t,r))!=OK)return c;let u=this.memory.resources.lab.find(t=>t.id==e),d=LAB_MASTER;u&&(u.reactionState==LAB_SLAVE_1&&(d=LAB_SLAVE_1),u.reactionState==LAB_SLAVE_2&&(d=LAB_SLAVE_2),u.reactionState=d,u.reactionType=t,u.reactionAmount=r,u.slave_a=s.id,u.slave_b=l.id),u=this.memory.resources.lab.find(e=>e.id==s.id);let h=LAB_SLAVE_1,g=1;if(d==LAB_SLAVE_1?(h=LAB_SLAVE_2,g=2):d==LAB_SLAVE_2&&(h=LAB_SLAVE_3,g=3),u){u.reactionState=h,u.reactionType=i,u.master=a.id,this.placeOrder(s.id,i,r);let e=0;if(this.memory.container)for(let t=0;t<this.memory.container.length;t++){let r=this.memory.container[t],o=Game.getObjectById(r.id);o&&o.store[i]&&(e+=o.store[i])}if(this.storage&&(e+=this.storage.store[i]||0),this.terminal&&(e+=this.terminal.store[i]||0),o>g&&g<3&&e<r&&this.placeReactionOrder(s.id,i,r-e)==OK){let t=u.orders.find(e=>e.type==i);t&&(t.orderRemaining=e)}}if(u=this.memory.resources.lab.find(e=>e.id==l.id)){u.reactionState=h,u.reactionType=n,u.master=a.id,this.placeOrder(l.id,n,r);let e=0;if(this.memory.container)for(let t=0;t<this.memory.container.length;t++){let r=this.memory.container[t],o=Game.getObjectById(r.id);o&&(e+=o.store[n]||0)}if(this.storage&&(e+=this.storage.store[n]||0),this.terminal&&(e+=this.terminal.store[n]||0),o>g&&g<3&&e<r&&this.placeReactionOrder(s.id,i,r-e)==OK){let t=u.orders.find(e=>e.type==n);t&&(t.orderRemaining=e)}}return OK}},placeFlowerReactionOrder:{value(e,t,r,o=REACTOR_MODE_BURST){if(r<=0)return OK;if(!LAB_REACTIONS.hasOwnProperty(t))return ERR_INVALID_ARGS;void 0===this.memory.resources&&(this.memory.resources={lab:[],container:[],terminal:[],storage:[]}),void 0===this.memory.resources.powerSpawn&&(this.memory.resources.powerSpawn=[]);let a=this.memory.resources;if(a.reactions){let i=a.reactions.orders.find(r=>r.id==e&&r.type==t);i?(LOG_TRACE&&Log.trace("Room",{roomName:this.name,actionName:"placeReactionOrder",subAction:"update",orderId:e,resourceType:t,amount:r}),i.mode=o,i.amount=r):(LOG_TRACE&&Log.trace("Room",{roomName:this.name,actionName:"placeReactionOrder",subAction:"new",orderId:e,resourceType:t,amount:r}),a.reactions.orders.push({id:e,type:t,mode:o,amount:r})),a.reactions.reactorMode=o}return OK}},placeReactionOrder:{value(e,t,r,o=REACTOR_MODE_BURST){if(r<=0)return OK;if(!LAB_REACTIONS.hasOwnProperty(t))return ERR_INVALID_ARGS;void 0===this.memory.resources&&(this.memory.resources={lab:[],container:[],terminal:[],storage:[]}),void 0===this.memory.resources.powerSpawn&&(this.memory.resources.powerSpawn=[]);let a=Game.getObjectById(e);if(a&&a.structureType===STRUCTURE_LAB)return this.placeBasicReactionOrder(e,t,r,1);let i=this.memory.resources;if(!i.reactions)return LOG_TRACE&&Log.trace("Room",{roomName:this.name,actionName:"placeRoomOrder",subAction:"no_reactor"}),ERR_INVALID_TARGET;switch(i.reactions.reactorType,i.reactions.reactorType){case REACTOR_TYPE_FLOWER:this.placeFlowerReactionOrder(e,t,r,o)}return OK}},registerReactorFlower:{value(e,t){void 0===this.memory.resources&&(this.memory.resources={lab:[],container:[],terminal:[],storage:[]}),void 0===this.memory.resources.powerSpawn&&(this.memory.resources.powerSpawn=[]);let r=Game.getObjectById(e),o=Game.getObjectById(t);if(!r||!o||r.structureType!==STRUCTURE_LAB||o.structureType!==STRUCTURE_LAB)return ERR_INVALID_TARGET;let a=this.memory.resources;void 0===a.reactions&&(a.reactions={orders:[]}),a.reactions.reactorType=REACTOR_TYPE_FLOWER,a.reactions.reactorMode=REACTOR_MODE_IDLE,a.reactions.seed_a=e,a.reactions.seed_b=t;const i=a.lab.find(t=>t.id===e);i&&(i.reactionState=LAB_SEED);const n=a.lab.find(e=>e.id===t);return n&&(n.reactionState=LAB_SEED),OK}}})}),this.roomManagerExtend=(()=>{this.assignRoomManager({Labs:function(e){this.room=e,Object.defineProperties(this,{all:{get(){if(_.isUndefined(this._all)){this._all=[];let e=e=>{let t=Game.getObjectById(e.id);t&&(_.assign(t,e),this._all.push(t))};_.forEach(this.room.memory.labs,e)}return this._all}},storage:{get(){if(_.isUndefined(this._storage)){let e=e=>!0===e.storage;this._storage=this.all.filter(e)}return this._storage}}})}})})}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(2);t.default=new class extends o.RoomExtra{constructor(){super("link"),this.analyzeRoom=((e,t)=>{t&&e.saveLinks(),e.structures.links.all.length>0&&e.linkDispatcher()}),this.prototypeExtend=(()=>{this.assignRoomPrototype({saveLinks:{value(){let e=this.find(FIND_MY_STRUCTURES,{filter:e=>e.structureType==STRUCTURE_LINK});if(e.length>0){this.memory.links=[];let t=this.storage?this.storage.pos.findInRange(e,2).map(e=>e.id):[];this.memory.links=[];let r=e=>{if(!this.memory.links.find(t=>t.id==e.id)){let r=e.pos.getRangeTo(this.controller)<=4,o=!1;if(!r){let t=e.pos.findInRange(this.sources,2),r=t=>t.memory.link=e.id;t.forEach(r),o=t.length>0}this.memory.links.push({id:e.id,storage:t.includes(e.id),controller:r,source:o})}};e.forEach(r)}else delete this.memory.links}},linkDispatcher:{value(){let e=e=>0==e.cooldown&&e.energy>=e.energyCapacity*(e.source?.85:.5),t=e=>e.energy<.15*e.energyCapacity,r=this.structures.links.in.filter(e),o=this.structures.links.controller.filter(t);if(r.length>0){let e=this.structures.links.storage.filter(t),a=t=>{o.length>0?(t.transferEnergy(o[0]),o.shift()):e.length>0&&(t.transferEnergy(e[0]),e.shift())};r.forEach(a)}if(o.length>0){let t=e=>{o.length>0&&(e.transferEnergy(o[0]),o.shift())};this.structures.links.storage.filter(e).forEach(t)}}}})}),this.roomManagerExtend=(()=>{this.assignRoomManager({Links:function(e){this.room=e,Object.defineProperties(this,{all:{get(){if(_.isUndefined(this._all)){this._all=[];let e=e=>{let t=Game.getObjectById(e.id);t&&(_.assign(t,e),this._all.push(t))};_.forEach(this.room.memory.links,e)}return this._all}},controller:{get(){if(_.isUndefined(this._controller)){let e=e=>!0===e.controller;this._controller=this.all.filter(e)}return this._controller}},storage:{get(){if(_.isUndefined(this._storage)){let e=e=>1==e.storage;this._storage=this.all.filter(e)}return this._storage}},in:{get(){if(_.isUndefined(this._in)){let e=e=>0==e.storage&&0==e.controller;this._in=_.filter(this.all,e)}return this._in}},privateers:{get(){if(_.isUndefined(this._privateers)){let e=e=>0==e.storage&&0==e.controller&&0==e.source&&e.energy<.85*e.energyCapacity;this._privateers=_.filter(this.all,e)}return this._privateers}}})}})})}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(2);t.default=new class extends o.RoomExtra{constructor(){super("nuker"),this.analyzeRoom=((e,t)=>{t&&e.saveNuker()}),this.prototypeExtend=(()=>{this.assignRoomPrototype({saveNuker:{value(){let e=this.find(FIND_MY_STRUCTURES,{filter:e=>e.structureType==STRUCTURE_NUKER});if(e.length>0){this.memory.nukers=[];let t=e=>{this.memory.nukers.find(t=>t.id==e.id)||this.memory.nukers.push({id:e.id})};e.forEach(t)}else delete this.memory.nukers}}})}),this.roomManagerExtend=(()=>{this.assignRoomManager({Nuker:function(e){this.room=e,Object.defineProperties(this,{all:{get(){if(_.isUndefined(this._all)){this._all=[];let e=e=>{let t=Game.getObjectById(e.id);t&&(_.assign(t,e),this._all.push(t))};_.forEach(this.room.memory.nukers,e)}return this._all}}})}})})}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(2);t.default=new class extends o.RoomExtra{constructor(){super("observer"),this.analyzeRoom=((e,t)=>{t&&(e.saveObserver(),e.structures.observer&&e.initObserverRooms())}),this.runRoom=((e,t)=>{const r=Game.rooms[t];r&&r.structures.observer&&r.controlObserver()}),this.fresh=(()=>{Memory.observerSchedule=[]}),this.prototypeExtend=(()=>{this.assignRoomPrototype({controlObserver:{value(){const e=this.structures.observer;if(!e)return;let t;if(this.memory.observer.rooms||this.initObserverRooms(),observerRequests.length>0)for(const e of observerRequests)if(Game.map.getRoomLinearDistance(this.name,e.roomName)<=10&&!Memory.observerSchedule.includes(e.roomName)){const r=e.room||Game.rooms[e.roomName];if(r&&r.creeps&&r.creeps.length&&r.creeps.length>0)continue;Memory.observerSchedule.push(e.roomName),t=e.roomName;break}let r=0;const o=this.memory.observer.rooms;if(!t){let e=Number.isInteger(this.memory.observer.lastLookedIndex)?this.memory.observer.lastLookedIndex:o.length;do{if(t=e>=o.length?o[0]:o[e+1],e=o.indexOf(t),++r>=o.length)break}while(Memory.observerSchedule.includes(t)||t in Game.rooms);this.memory.observer.lastLookedIndex=e,Memory.observerSchedule.push(t)}e.observeRoom(t)===ERR_INVALID_ARGS&&r<o.length&&(Memory.observerSchedule.splice(Memory.observerSchedule.indexOf(t),1),this.controlObserver())}},initObserverRooms:{value(){const e=OBSERVER_OBSERVE_RANGE>10?10:OBSERVER_OBSERVE_RANGE,[t,r]=RoomManager.calcGlobalCoordinates(this.name,(e,t)=>[e,t]),[o,a]=RoomManager.calcCardinalDirection(this.name);this.memory.observer.rooms=[];for(let i=t-e;i<t+e;i++)for(let t=r-e;t<r+e;t++){let e=o,r=a,n=i;i<0&&(e="W"===e?"E":"W",n=Math.abs(i)-1),e+=n,n=t,t<0&&(r="N"===r?"S":"N",n=Math.abs(t)-1);const s=e+(r+=n);OBSERVER_OBSERVE_HIGHWAYS_ONLY&&!RoomManager.isHighwayRoom(s)||s in Game.rooms&&Game.rooms[s].my||Game.map.isRoomAvailable(s)&&this.memory.observer.rooms.push(s)}}},saveObserver:{value(){this.memory.observer={},[this.memory.observer.id]=this.find(FIND_MY_STRUCTURES,{filter:e=>e instanceof StructureObserver}).map(e=>e.id),_.isUndefined(this.memory.observer.id)&&delete this.memory.observer}}})})}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(2);class a extends Room{constructor(){}GCOrders(){const e=this.memory.resources,t=_.filter(Game.rooms,{my:!0});if(_.isUndefined(e))return void Log.room(this.name,Util.emoji.order,`There is no ${this.name}.memory.resources.`);if(0===e.orders.length)return;Log.room(this.name,Util.emoji.order,`Garbage collecting ${this.name} roomOrders`);const r=e.reactions;if(r.orders.length>0&&r.orders[0].amount>0){const t=r.orders[0],o=LAB_REACTIONS[t.type][0],a=LAB_REACTIONS[t.type][1];e.orders=_.filter(e.orders,e=>e.amount>0&&(e.type===o||e.type===a||!_.isUndefined(COMPOUNDS_TO_ALLOCATE[e.type])&&COMPOUNDS_TO_ALLOCATE[e.type].allocate))}else e.orders=_.filter(e.orders,e=>e.amount>0&&!_.isUndefined(COMPOUNDS_TO_ALLOCATE[e.type])&&COMPOUNDS_TO_ALLOCATE[e.type].allocate);if(this.ordersWithOffers())return e.boostTiming.checkRoomAt=Game.time+CHECK_ORDERS_INTERVAL,!1;Log.room(this.name,Util.emoji.order,"not enough or no offers found."),_.isUndefined(e.boostTiming.getOfferAttempts)?e.boostTiming.getOfferAttempts=0:e.boostTiming.getOfferAttempts++,Log.room(this.name,Util.emoji.order,`${this.name} running room offers...`);for(let e of t){if(!e.memory.resources)continue;const t=e.memory.resources.offers;let r;for(let o=0;o<t.length;o++){let a=t[o],i=Game.rooms[a.room];if(!(i&&i.memory&&i.memory.resources&&i.memory.resources.orders))continue;let n=i.memory.resources.orders.find(e=>e.id===a.id&&e.type===a.type);n&&(r=n.offers.findIndex(t=>t.room===e.name)),n&&-1!==r||(Log.room(this.name,Util.emoji.order,`Orphaned offer found and deleted in ${e.print}.`),t.splice(o,1),o--)}}if(e.boostTiming.getOfferAttempts<3)return this.updateRoomOrders(),e.boostTiming.ordersPlaced=Game.time,e.boostTiming.checkRoomAt=Game.time+1,!0;e.orders=[],e.reactions.orders[0].amount=0,delete e.boostTiming.getOfferAttempts,Log.room(this.name,Util.emoji.order,"no offers found, Reaction and orders deleted.")}GCOffers(){const e=this.memory.resources;let t=!1,r=0;if(_.isUndefined(e))return Log.room(this.name,Util.emoji.order,Dye(COLOR_RED,`there is no ${this.name}.memory.resources.`)),{readyOffersFound:r,terminalOrderPlaced:t};if(0===e.offers.length)return{readyOffersFound:r,terminalOrderPlaced:t};if(Log.room(this.name,Util.emoji.order,"Garbage collecting for room offers"),e.offers=_.filter(e.offers,e=>{const t=Game.rooms[e.room],r=t.memory.resources.orders,o=this.resourcesAll[e.type];for(let a=0;a<r.length;a++){let i=r[a];if(e.id===i.id&&!_.isUndefined(o)&&o>=0)return!0;if(e.id===i.id)return t.memory.resources.orders[a].offers=[],!1}return!1}),e.offers.length>0)for(let o of e.offers){let a=this.terminal.store[o.type]||0;if(Log.room(this.name,Util.emoji.order,`${a} / ${o.amount} ${o.type} are in terminal`),a>=.5*o.amount&&a<o.amount-MIN_OFFER_AMOUNT||a>=o.amount)Log.room(this.name,Util.emoji.order,Dye(COLOR_GREEN,`${Math.min(a,o.amount)} ${o.type} are ready to send from ${o.room}`)),r++;else{0===this.memory.resources.terminal.length&&this.memory.resources.terminal.push({id:this.terminal.id,orders:[]});const r=this.memory.resources.terminal[0],o=this.memory.resources.terminal[0].id,a=this.terminal;r.orders.length>0&&(r.orders=_.filter(r.orders,t=>(t.orderRemaining>0||t.storeAmount>0)&&_.some(e.offers,e=>e.type===t.type&&e.amount===t.orderRemaining+(a.store[e.type]||0))));for(let i of e.offers){const e=Util.sumCompoundType(r.orders,"orderRemaining"),n=(e[i.type]||0)+(a.store[i.type]||0);i.amount>n?(Log.room(this.name,Util.emoji.order,`no / not enough terminal order found for ${i.amount} ${i.type}`),Log.room(this.name,Util.emoji.order,`terminal stores: ${a.store[i.type]||0} ordered: ${e[i.type]||0}`),Log.room(this.name,Util.emoji.order,`terminal order placed for ${Math.max(i.amount,MIN_OFFER_AMOUNT)} ${i.type}`),this.placeOrder(o,i.type,Math.max(i.amount,MIN_OFFER_AMOUNT)),t=!0):Log.room(this.name,Util.emoji.order,Dye(COLOR_GREEN,`Terminal orders for ${i.amount} ${i.type} is OK.`))}}}return{readyOffersFound:r,terminalOrderPlaced:t}}GCLabs(){Log.room(this.name,Util.emoji.lab,"Garbage collecting lab orders.");const e=this.memory.resources,t=e.lab,r=e.reactions.orders[0];for(let o=0;o<t.length;o++){const a=t[o];let i;if(a.orders.length>0){if(e.reactions.orders.length>0){const e=LAB_REACTIONS[r.type][0],t=LAB_REACTIONS[r.type][1];i=_.filter(a.orders,r=>{if((r.orderAmount>0||r.orderRemaining>0||r.storeAmount>0)&&(r.type===e||r.type===t||"energy"===r.type||"Storage"===a.reactionState))return r})}else i=_.filter(a.orders,e=>{if("energy"===e.type||"Storage"===a.reactionState)return e});a.orders.length>i.length&&(this.memory.resources.lab[o].orders=i,Log.room(this.name,Util.emoji.lab,`Lab orders fixed in ${this.name}, ${a.id}`))}}}checkOffers(){if(Memory.boostTiming.multiOrderingRoomName===this)return Log.room(this.name,Util.emoji.order,"Early room check, multiOrdering in progress"),!0;const e=this.memory.resources,t=e.orders;let r,o=[],a=!1;for(let e of t)if(e.offers.length>0)for(let t of e.offers){if(!_.some(o,e=>e.room===t.room)){(r=Game.rooms[t.room].GCOffers()).terminalOrderPlaced&&(a=!0),r.readyOffersFound>0&&o.push({room:t.room,readyOffers:r.readyOffersFound})}}if(1!==o.length||1!==o[0].readyOffers||!_.isUndefined(e.boostTiming.ordersReady))return(o.length>=1||1===o.length&&o[0].readyOffers>1)&&_.isUndefined(e.boostTiming.ordersReady)?(Log.room(this.name,Util.emoji.order,"has more than one offers ready, boostTiming.ordersReady created"),Log.stringify(o),e.boostTiming.ordersReady={time:Game.time,orderCandidates:o},Memory.boostTiming||(Memory.boostTiming={}),Memory.boostTiming.multiOrderingRoomName=this.name,e.boostTiming.checkRoomAt=Game.time+_.sum(o,"readyOffers")+1,!0):r.terminalOrderPlaced?(Log.room(this.name,Util.emoji.order,"terminal orders placed."),e.boostTiming.checkRoomAt=Game.time+CHECK_ORDERS_INTERVAL,!1):(Log.room(this.name,Util.emoji.order,`${this.name} no ready offers found.`),e.boostTiming.checkRoomAt=Game.time+CHECK_ORDERS_INTERVAL,!1);{let t=Game.rooms[o[0].room];Log.room(this.name,Util.emoji.order,`There is only one offersReady from ${o[0].room}, running fill room order...`);let r=!1;if(0!==t.terminal.cooldown)return e.boostTiming.checkRoomAt=Game.time+t.terminal.cooldown+1,Log.room(this.name,Util.emoji.order,`${t.name} terminal cooldown is: ${t.terminal.cooldown}`),Log.room(this.name,Util.emoji.order,`time: ${Game.time}, boosTiming:`,"<br/>",Util.jsonToTable(e.boostTiming)),!1;if(!0===(r=t.fillARoomOrder())&&0===e.orders.length||0===_.sum(e.orders,"amount"))return e.boostTiming.checkRoomAt=Game.time+1,Log.room(this.name,Util.emoji.order,`${t.name} terminal send was successful. And there are no more orders`),Log.room(this.name,Util.emoji.order,`time: ${Game.time} boost timing:`,"<br/>",Util.jsonToTable(e.boostTiming)),!0;if(!0===r)return e.boostTiming.checkRoomAt=Game.time+CHECK_ORDERS_INTERVAL,Log.room(this.name,Util.emoji.order,`${t.name} terminal send was successful. BTW, there are orders remained to fulfill`),Log.room(this.name,Util.emoji.order,`time: ${Game.time}, boostTiming:`,"<br/>",Util.jsonToTable(e.boostTiming)),!0}}ordersWithOffers(){const e=this.memory.resources.orders;return 0!==e.length&&_.some(e,e=>{return(_.sum(e.offers,"amount")||0)>=e.amount&&e.amount>0})}makeReaction(){let e,t={};const r=(e,t,r)=>{let o=Game.rooms[e];if(!o.memory.labs)return!1;if(o.memory.labs.length<3)return!1;if(3===o.memory.labs.length&&!MAKE_REACTIONS_WITH_3LABS)return!1;if(_.isUndefined(o.memory.resources))return!1;if(_.isUndefined(o.memory.resources.reactions))return!1;const a=o.memory.resources.reactions,i=(e,t,r)=>{if(!PURCHASE_MINERALS)return Log.error(`${e} needs to buy ${r} ${t} but PURCHASE_MINERALS is false`),!1;if(o.storage.charge<STORE_CHARGE_PURCHASE)return Log.warn(`storage.charge in ${e} is ${o.storage.charge}, purchase for ${t} is delayed`),!1;if(o.terminal.cooldown>0)return Log.warn(`terminal.coolDown in ${e} is ${o.terminal.cooldown}, purchase for ${t} is delayed`),!1;if("idle"!==a.reactorMode)return!1;let i,n,s;Log.room(this.name,Util.emoji.terminal,Dye(COLOR_GREEN,`buying ${r} ${t} in ${e}.`)),AUTOMATED_RATIO_COUNT?(i=Util.countPrices(ORDER_SELL,t,e),Log.room(this.name,Util.emoji.terminal,`avg sell ratio: ${e} ${t} ${i}`)):i=MAX_BUY_RATIO[t];const l=Game.market.getAllOrders(o=>{const a=Game.rooms[e];let n,s;return o.type===ORDER_SELL&&(o.resourceType===t&&(o.transactionAmount=Math.min(o.amount,r),!((n=Game.market.calcTransactionCost(o.transactionAmount,o.roomName,e))>a.terminal.store[RESOURCE_ENERGY])&&(s=o.transactionAmount*o.price,!(Game.market.credits<s&&(o.transactionAmount=Game.market.credits/o.price,0===o.transactionAmount))&&(o.ratio=(s-n*ENERGY_VALUE_CREDITS)/o.transactionAmount,!(o.price>i||o.ratio>i||o.amount<100)))))});return l.length>0?(n=_.min(l,"ratio"),Log.room(this.name,Util.emoji.order,"selected order: ","<br/>",Util.jsonToTable(n)),n&&Log.room(this.name,Util.emoji.terminal,Dye(COLOR_BLUE,`Market deal: ${n.id} ${n.transactionAmount} from ${e}`)),(s=Game.market.deal(n.id,n.transactionAmount,e))===OK?(Log.room(this.name,Util.emoji.terminal,Dye(COLOR_GREEN,`Purchased ${n.transactionAmount} ${t} at price: ${n.price} it costs: ${n.transactionAmount*n.price}`)),!0):(Log.error(`purchase was FAILED error code: ${Util.translateErrorCode(s)}`),!1)):(0===i?Log.warn(`There are no sellOrders for ${t}`):(Log.warn(`No sell order found for ${r} ${t} at ratio ${MAX_BUY_RATIO[t]} in room ${e}`),Log.warn(`You need to adjust MAX_BUY_RATIO or use AUTOMATED_RATIO_COUNT: true in parameters, current is: ${MAX_BUY_RATIO[t]}, recommended: ${i}`)),!1)},n=((e,t)=>{if(1===e.length&&"G"!==e)return;const r=(e,t)=>{const r=(e=>{const t=_.filter(Game.rooms,{my:!0});let r=0;for(let o of t){let t=o.resourcesAll[e]||0;t>=MIN_OFFER_AMOUNT&&(r+=t)}return r})(e),a=o.resourcesAll[e]||0;let i;return r-a<TRADE_THRESHOLD?(i=t-a)<0?i=0:i<MIN_COMPOUND_AMOUNT_TO_MAKE&&(i=MIN_COMPOUND_AMOUNT_TO_MAKE):(i=t-r)<0?i=0:i<MIN_COMPOUND_AMOUNT_TO_MAKE&&(i=MIN_COMPOUND_AMOUNT_TO_MAKE),Util.roundUpTo(i,MIN_OFFER_AMOUNT)},a=(e,t)=>{let o={},a={};return o[e]=((e,t)=>{const o=LAB_REACTIONS[e][0],a=LAB_REACTIONS[e][1];return{[o]:r(o,t),[a]:r(a,t)}})(e,t),Object.keys(o).forEach(e=>{Object.keys(o[e]).forEach(t=>{(t.length>1||"G"===t)&&(a[t]=o[e][t])})}),{product:o,slice:(e=>0!==Object.keys(e).length&&e)(a)}};let i=a(e,t),n=i.product,s=i.slice;do{let e=[];Object.keys(s).forEach(t=>{i=a(t,s[t]),n[t]=i.product[t],e.push(i.slice)}),s={};for(let t of e)s=Object.assign(s,t)}while(_.some(s,Object));return n})(t,r);let s,l=!1,m=!1,c=[];return o.storage&&o.terminal?_.isUndefined(o.memory.labs)||0===o.memory.labs.length?(Log.warn(`there are no labs in ${o.name}`),!1):!1!==o.terminal.isActive()&&!1!==o.storage.isActive()&&!1!==Game.getObjectById(o.memory.labs[0].id).isActive()&&(Object.keys(n).forEach(t=>{Object.keys(n[t]).forEach(r=>{let a=n[t][r];if(a>0&&!l){if(1===r.length&&"G"!==r&&(o.resourcesAll[r]||0)<a&&!l&&!(l=i(e,r,a)))return{ingredientMade:m,mineralPurchased:l};l||(r.length>1||"G"===r)&&c.push({compound:r,amount:a})}})}),0===c.length&&c.push({compound:t,amount:r}),l||(s=c[c.length-1],m=((e,t,r)=>{if(_.isUndefined(a)||"flower"!==a.reactorType)return Log.room(e,Util.emoji.lab,Dye(COLOR_ORANGE,"labs are not registered as flower")),!1;const o=Game.rooms[e];let i=!1;"idle"===a.reactorMode&&(Log.room(e,Util.emoji.lab,`${o.name} - placeReactionOrder(${t}, ${t}, ${r})`),o.GCLabs(),o.placeReactionOrder(t,t,r),Memory.boostTiming.roomTrading.boostProduction=!0,Memory.boostTiming.timeStamp=Game.time,Log.room(o,`${o.name}, placeReaction ${r} ${t} at time: ${Game.time}`),o.memory.resources.boostTiming.roomState="reactionPlaced",i=!0);return i})(e,s.compound,s.amount)),{ingredientMade:m,mineralPurchased:l}):(Log.warn(`there are no storage/terminal in ${o.name}`),!1)};return Object.keys(COMPOUNDS_TO_MAKE).forEach(o=>{if(COMPOUNDS_TO_MAKE[o].make&&!t.ingredientMade&&(this.name.indexOf(COMPOUNDS_TO_MAKE[o].rooms)>-1||0===COMPOUNDS_TO_MAKE[o].rooms.length)){let a=this.resourcesAll[o]||0;0===a?(e=Util.roundUpTo(COMPOUNDS_TO_MAKE[o].amount+COMPOUNDS_TO_MAKE[o].threshold,MIN_OFFER_AMOUNT),(t=r(this.name,o,e)).ingredientMade&&Log.room(this.name,`there is no ${o}, so start to make the compounds for ${COMPOUNDS_TO_MAKE[o].amount} ${o} in ${this.name}`)):a<=COMPOUNDS_TO_MAKE[o].threshold&&(e=Util.roundUpTo(COMPOUNDS_TO_MAKE[o].amount+COMPOUNDS_TO_MAKE[o].threshold-a,MIN_OFFER_AMOUNT),(t=r(this.name,o,e)).ingredientMade&&Log.room(this.name,`it is below the threshold, so start to make the compounds for ${e} ${o} in ${this.name}`))}}),t.ingredientMade||t.mineralPurchased}storedMinerals(e){let t=(this.resourcesStorage[e]||0)+(this.resourcesTerminal[e]||0)-(this.resourcesOffers[e]||0)-(this.resourcesReactions[e]||0);return t<0&&(t=0),t}countCheckRoomAt(){const e=this.memory.resources,t=e.boostTiming,r=e.lab.length,o=REACTION_TIME[e.reactions.orders[0].type],a=LAB_REACTION_AMOUNT*(r-_.filter(e.lab,e=>"Storage"===e.reactionState).length-2)/o,i=e.reactions.orders[0].amount;t.checkRoomAt=t.reactionMaking+Util.roundUpTo(i/a,o)+o}getSeedLabOrders(){let e=this.memory.resources;if(_.isUndefined(e)||_.isUndefined(e.reactions)||0===e.reactions.orders.length)return;const t=e.reactions.orders[0].type,r=LAB_REACTIONS[t][0],o=LAB_REACTIONS[t][1],a=e.lab.findIndex(t=>t.id===e.reactions.seed_a),i=e.lab.findIndex(t=>t.id===e.reactions.seed_b),n=_.filter(e.lab[a].orders,e=>e.type===r),s=_.filter(e.lab[i].orders,e=>e.type===o);return{labOrderAmountA:n[0].orderRemaining,labOrderAmountB:s[0].orderRemaining}}updateResourceOrders(){let e=this.memory.resources;if(this.my&&e)for(let t in e)for(let r=0;r<e[t].length;r++){let o=e[t][r];if((t!=STRUCTURE_LAB||o.reactionState==LAB_IDLE)&&o.orders)for(let e=0;e<o.orders.length;e++){let r=o.orders[e];if(r.orderRemaining<=0){let e=0,a=this.RCL;t==STRUCTURE_STORAGE?e=r.type==RESOURCE_ENERGY?MIN_STORAGE_ENERGY[a]:MAX_STORAGE_MINERAL:t==STRUCTURE_TERMINAL&&(e=r.type==RESOURCE_ENERGY?TERMINAL_ENERGY:0),e+=r.storeAmount;let i=0,n=Game.getObjectById(o.id);if(n)switch(t){case STRUCTURE_LAB:r.type==n.mineralType?i=n.mineralAmount:r.type==RESOURCE_ENERGY&&(i=n.energy);break;case STRUCTURE_POWER_SPAWN:r.type==RESOURCE_POWER?i=n.power:r.type==RESOURCE_ENERGY&&(i=n.energy);break;case STRUCTURE_NUKER:r.type==RESOURCE_GHODIUM?i=n.ghodium:r.type==RESOURCE_ENERGY&&(i=n.energy);break;default:i=n.store[r.type]||0}i<=e&&(r.orderAmount=0,r.orderRemaining=0)}}}}updateRoomOrders(){if(!this.memory.resources||!this.memory.resources.orders)return;let e=_.filter(Game.rooms,e=>e.my&&e.storage&&e.terminal&&e.name!==this.name),t=this.memory.resources.orders;for(let r=0;r<t.length;r++){let o=t[r],a=o.amount;for(let e=0;e<o.offers.length;e++){let t=o.offers[e];if(Memory.rooms[t.room]&&Memory.rooms[t.room].resources&&Memory.rooms[t.room].resources.offers){let e=Memory.rooms[t.room].resources.offers,r=e.indexOf(e=>e.room===this.name&&e.id===o.id&&e.type===o.type);-1!==r&&e.splice(r,1)}}if(o.offers=[],a<=0)delete t[r],t.splice(r--,1);else{e.sort((e,t)=>Game.map.getRoomLinearDistance(this.name,e.name,!0)-Game.map.getRoomLinearDistance(this.name,t.name,!0));for(let t=0;t<e.length;t++){let r=e[t];void 0===r.memory.resources&&(r.memory.resources={lab:[],container:[],terminal:[],storage:[],powerSpawn:[],nuker:[]}),r.memory.resources.offers||(r.memory.resources.offers=[]);let i=r.memory.resources.offers,n=r.resourcesAll[o.type]||0;if(n>0&&Log.room(r.name,Util.emoji.order,`available: ${n} ${o.type}`),n<MIN_OFFER_AMOUNT)continue;if(!_.isUndefined(COMPOUNDS_TO_ALLOCATE[o.type])){let e=COMPOUNDS_TO_ALLOCATE[o.type].amount+COMPOUNDS_TO_ALLOCATE[o.type].threshold;if(n<e+MIN_OFFER_AMOUNT)continue;n-=e}a<MIN_OFFER_AMOUNT&&a>0&&(a=MIN_OFFER_AMOUNT),n=Math.min(n,a);let s=o.offers.find(e=>e.room===r.name),l=i.find(e=>e.room===this.name&&e.id===o.id&&e.type===o.type);if(s?(LOG_TRACE&&Log.trace("Room",{roomName:this.name,remoteRoom:r.name,actionName:"updateRoomOrders",subAction:"update",orderId:o.id,resourceType:o.type,amount:n}),a-=n-s.amount,s.amount=n):(LOG_TRACE&&Log.trace("Room",{roomName:this.name,remoteRoom:r.name,actionName:"updateRoomOrders",subAction:"new",orderId:o.id,resourceType:o.type,amount:n}),Log.room(this.name,Util.emoji.order,Dye(COLOR_PURPLE,`Room offer from ${r.print} with id ${o.id} placed for ${n} ${o.type}.`)),a-=n,o.offers.push({room:r.name,amount:n})),l?l.amount=n:i.push({room:this.name,id:o.id,type:o.type,amount:n}),a<=0)break}}}}fillARoomOrder(){if(!(this.terminal&&this.memory&&this.memory.resources&&this.memory.resources.offers))return!1;const e=this.memory.resources.offers;let t=!1;for(let r=0;r<e.length;r++){let o=e[r],a=Game.rooms[o.room];if(!(a&&a.memory&&a.memory.resources&&a.memory.resources.orders))continue;let i=a.memory.resources.orders.find(e=>e.id==o.id&&e.type==o.type);if(!i)continue;let n=i.offers.findIndex(e=>e.room==this.name);if(-1==n){Log.room(this.name,"Orphaned offer found and deleted"),e.splice(r--,1);continue}let s=this.terminal.store[o.type]||0,l=0,m=null;this.memory.resources.terminal[0]&&(m=this.memory.resources.terminal[0].orders.find(e=>e.type==o.type)),m&&(l=m.orderRemaining);let c=Math.max(o.amount,MIN_OFFER_AMOUNT);if(c>s+l){let e=c-(s+l);LOG_TRACE&&Log.trace("Room",{actionName:"fillARoomOrder",subAction:"terminalOrder",roomName:this.name,targetRoomName:a.name,resourceType:o.type,amount:e}),this.placeOrder(this.terminal.id,o.type,e)}if(!a.terminal)continue;let u=a.terminal.storeCapacity-a.terminal.sum;c=Math.min(c,u,s);let d=Game.market.calcTransactionCost(c,this.name,a.name);if(o.type==RESOURCE_ENERGY&&(d+=c-=d),!(d>(this.terminal.store.energy||0)||c<MIN_OFFER_AMOUNT)){if((t=this.terminal.send(o.type,c,a.name,i.id))==OK)return LOG_TRACE&&Log.trace("Room",{actionName:"fillARoomOrder",roomName:this.name,targetRoomName:a.name,resourceType:o.type,amount:c}),Log.room(this.name,Util.emoji.order,Dye(COLOR_GREEN,`Send ${o.type} ${c} to ${Util.makeRoomUrl(a.name)}.`)),o.amount-=c,o.amount>0?i.offers[n].amount=o.amount:(delete i.offers[n],i.offers.splice(n,1),delete e[r],e.splice(r--,1)),i.amount-=c,!0;Log.error(`Send Error: ${Util.translateErrorCode(t)} | ${this.name} send ${o.type} ${c} to ${Util.makeRoomUrl(a.name)}.`)}}return t}prepareResourceOrder(e,t,r){let o=Game.getObjectById(e);if(!this.my||!o||!o.room.name==this.name||o.structureType!=STRUCTURE_LAB&&o.structureType!=STRUCTURE_NUKER&&o.structureType!=STRUCTURE_POWER_SPAWN&&o.structureType!=STRUCTURE_CONTAINER&&o.structureType!=STRUCTURE_STORAGE&&o.structureType!=STRUCTURE_TERMINAL)return ERR_INVALID_TARGET;if(!RESOURCES_ALL.includes(t))return ERR_INVALID_ARGS;if(void 0===this.memory.resources&&(this.memory.resources={lab:[],powerSpawn:[],nuker:[],container:[],terminal:[],storage:[]}),void 0===this.memory.resources.nuker&&(this.memory.resources.nuker=[]),void 0===this.memory.resources.powerSpawn&&(this.memory.resources.powerSpawn=[]),this.memory.resources[o.structureType].find(t=>t.id==e)||this.memory.resources[o.structureType].push(o.structureType==STRUCTURE_LAB?{id:e,orders:[],reactionState:LAB_IDLE}:{id:e,orders:[]}),o.structureType==STRUCTURE_LAB&&t!=RESOURCE_ENERGY&&r>0){let r=this.memory.resources[STRUCTURE_LAB].find(t=>t.id==e).orders;for(let e=0;e<r.length;e++)r[e].type!=t&&r[e].type!=RESOURCE_ENERGY&&(r[e].orderAmount=0,r[e].orderRemaining=0,r[e].storeAmount=0)}return OK}cancelOrder(e,t=null){let r=Game.getObjectById(e);if(this.prepareResourceOrder(e,RESOURCE_ENERGY,0)!=OK)return ret;let o=this.memory.resources[r.structureType].find(t=>t.id==e);if(o)if(t){let e=o.orders.find(e=>e.type==t);e&&(LOG_TRACE&&Log.trace("Room",{roomName:this.name,actionName:"cancelOrder",orderId:orderId,resourceType:t}),o.orders.splice(o.orders.indexOf(e),1))}else LOG_TRACE&&Log.trace("Room",{roomName:this.name,actionName:"cancelOrder",orderId:orderId,resourceType:"all"}),o.orders=[];return OK}registerBoostLab(e){if(Game.getObjectById(e)){_.isUndefined(this.memory.resources)&&(this.memory.resources={lab:[],powerSpawn:[],nuker:[],container:[],terminal:[],storage:[]});let t=this.memory.resources.lab.findIndex(t=>t.id==e);if(t>-1)delete this.memory.resources.lab[t].reactionType,this.memory.resources.lab[t].reactionState="Storage";else{let t={id:e,orders:[],reactionState:"Storage"};this.memory.resources.lab.push(t)}}}unRegisterBoostLab(e){const t=Game.getObjectById(e),r=this.memory.resources;if(t&&r){let t=this.memory.resources.lab.findIndex(t=>t.id===e);t>-1&&(r.reactions.orders.length>0&&(this.memory.resources.lab[t].reactionType=this.memory.resources.reactions.orders[0].type),this.memory.resources.lab[t].reactionState="idle",this.memory.resources.lab[t].orders=_.filter(this.memory.resources.lab[t].orders,"type","energy"))}}placeOrder(e,t,r){const o=Game.getObjectById(e);let a=this.prepareResourceOrder(e,t,r);if(a!=OK)return a;let i=this.memory.resources[o.structureType].find(t=>t.id==e);if(i){let e=i.orders.find(e=>e.type==t);if(e)e.orderAmount+=r,e.orderRemaining+=r;else{let e=0;e=o.structureType===STRUCTURE_LAB?o.mineralType==t?o.mineralAmount:0:o.store[t]||0,i.orders.push({type:t,orderAmount:r,orderRemaining:r-e,storeAmount:0}),o.structureType===STRUCTURE_LAB&&"Storage"!=i.reactionState&&(i.reactionType=t)}}return OK}setStore(e,t,r){let o=Game.getObjectById(e),a=this.prepareResourceOrder(e,t,r);if(a!=OK)return a;let i=this.memory.resources[o.structureType].find(t=>t.id==e);if(i){let e=i.orders.find(e=>e.type==t);e?e.storeAmount=r:i.orders.push({type:t,orderAmount:0,orderRemaining:0,storeAmount:r})}return OK}cancelRoomOrder(e=null,t=null){void 0===this.memory.resources&&(this.memory.resources={lab:[],powerSpawn:[],nuker:[],container:[],terminal:[],storage:[]}),void 0===this.memory.resources.nuker&&(this.memory.resources.nuker=[]),void 0===this.memory.resources.powerSpawn&&(this.memory.resources.powerSpawn=[]),void 0===this.memory.resources.orders&&(this.memory.resources.orders=[]);let r=this.memory.resources.orders;if(e&&t){let o=r.find(r=>r.id==e&&r.type==t);o&&(LOG_TRACE&&Log.trace("Room",{roomName:this.name,actionName:"cancelRoomOrder",orderId:e,resourceType:t}),r.splice(r.indexOf(o),1))}else if(e){LOG_TRACE&&Log.trace("Room",{roomName:this.name,actionName:"cancelRoomOrder",orderId:e,resourceType:"all"});for(let t=0;t<r.length;t++){r[t].id===e&&r.splice(t--,1)}}else this.memory.resources.orders=[];return OK}placeRoomOrder(e,t,r){if(r<=0)return OK;void 0===this.memory.resources&&(this.memory.resources={lab:[],powerSpawn:[],nuker:[],container:[],terminal:[],storage:[]}),void 0===this.memory.resources.nuker&&(this.memory.resources.nuker=[]),void 0===this.memory.resources.powerSpawn&&(this.memory.resources.powerSpawn=[]),void 0===this.memory.resources.orders&&(this.memory.resources.orders=[]);let o=this.memory.resources.orders,a=o.find(r=>r.id==e&&r.type==t);return a?(LOG_TRACE&&Log.trace("Room",{roomName:this.name,actionName:"placeRoomOrder",subAction:"update",orderId:e,resourceType:t,amount:r}),a.amount=r):(LOG_TRACE&&Log.trace("Room",{roomName:this.name,actionName:"placeRoomOrder",subAction:"new",orderId:e,resourceType:t,amount:r}),Log.room(this.name,`New room order with id ${e} placed for ${r} ${t}.`),o.push({id:e,type:t,amount:r,offers:[]})),OK}terminalBroker(){if(!this.my||!this.terminal||!this.storage)return;if(this.terminal.cooldown&&this.terminal.cooldown>0)return;let e=!1;for(const t in this.terminal.store){if(t===RESOURCE_ENERGY||t===RESOURCE_POWER)continue;if((MAKE_COMPOUNDS||ALLOCATE_COMPOUNDS)&&t!==this.memory.mineralType)continue;let r=this.terminal.sum===this.terminal.storeCapacity>.8;if(this.terminal.store[t]>=MIN_MINERAL_SELL_AMOUNT){let o;AUTOMATED_RATIO_COUNT?0===(o=Util.countPrices(ORDER_BUY,t,this.name))?Log.room(this.name,Util.emoji.terminal,Dye(COLOR_ORANGE,`there is no buy order for ${t}`)):Log.room(this.name,Util.emoji.terminal,Dye(COLOR_BLUE,`auto-count avg buy ratio: ${t} ${o}`)):o=MIN_SELL_RATIO[t];let a=Game.market.getAllOrders(e=>!(!e.roomName||e.resourceType!=t||e.type!=ORDER_BUY||e.amount<MIN_MINERAL_SELL_AMOUNT)&&(e.range=Game.map.getRoomLinearDistance(e.roomName,this.name,!0),e.transactionAmount=Math.min(e.amount,this.terminal.store[t]),e.transactionCost=Game.market.calcTransactionCost(e.transactionAmount,this.name,e.roomName),e.transactionCost>this.terminal.store.energy&&e.transactionAmount>MIN_MINERAL_SELL_AMOUNT&&(e.transactionAmount=MIN_MINERAL_SELL_AMOUNT,e.transactionCost=Game.market.calcTransactionCost(e.transactionAmount,this.name,e.roomName)),e.credits=e.transactionAmount*e.price,e.ratio=(e.credits-e.transactionCost*ENERGY_VALUE_CREDITS)/e.transactionAmount,r||e.price>=o&&e.ratio>=o&&e.transactionCost<=this.terminal.store.energy));if(a.length>0){let r=_.max(a,"ratio");Log.room(this.name,Util.emoji.terminal,"selected order: ","<br/>",Util.jsonToTable(r));let o=Game.market.deal(r.id,r.transactionAmount,this.name);SELL_NOTIFICATION&&Log.room(this.name,Util.emoji.terminal,Dye(COLOR_GREEN,`Selling ${r.transactionAmount} ${t} for ${Util.roundUp(r.credits)} (C:${r.price}, E:${r.transactionCost}): ${Util.translateErrorCode(o)}`)),SELL_NOTIFICATION&&Game.notify(`<h2>Room ${this.name} rund an order!</h2><br/>Result: ${Util.translateErrorCode(o)}<br/>Details:<br/>${JSON.stringify(r).replace(",",",<br/>")}`),e=o==OK;break}}}if(8==this.controller.level&&!e&&Util.chargeScale(this.storage.store.energy-ENERGY_BALANCE_TRANSFER_AMOUNT,MIN_STORAGE_ENERGY[this.controller.level],MAX_STORAGE_ENERGY[this.controller.level])>1&&(this.terminal.store[this.mineralType]||0)<15e4&&this.terminal.store.energy>1.1*ENERGY_BALANCE_TRANSFER_AMOUNT){let t=e=>e.my&&e.storage&&e.terminal&&e.terminal.sum<e.terminal.storeCapacity-ENERGY_BALANCE_TRANSFER_AMOUNT&&e.storage.sum<e.storage.storeCapacity*TARGET_STORAGE_SUM_RATIO&&!e._isReceivingEnergy&&e.storage.store[RESOURCE_ENERGY]<MAX_STORAGE_ENERGY[e.RCL],r=_.min(_.filter(Game.rooms,t),"storage.store.energy");if(r instanceof Room&&Game.market.calcTransactionCost(ENERGY_BALANCE_TRANSFER_AMOUNT,this.name,r.name)<this.terminal.store.energy-ENERGY_BALANCE_TRANSFER_AMOUNT){r._isReceivingEnergy=!0;let t=this.terminal.send("energy",ENERGY_BALANCE_TRANSFER_AMOUNT,r.name,"have fun");Log.room(this.name,Util.emoji.terminal,Dye(COLOR_GREEN,`Transferring ${Util.formatNumber(ENERGY_BALANCE_TRANSFER_AMOUNT)} energy to ${r.name}: ${Util.translateErrorCode(t)}`)),e=t==OK}}!0!==e&&_.isUndefined(Memory.boostTiming)&&(Log.room(this.name,Util.emoji.order,"Fill room order..."),this.fillARoomOrder())}}t.default=new class extends o.RoomExtra{constructor(){super("orders"),this.analyzeRoom=((e,t)=>{Game.time%PROCESS_ORDERS_INTERVAL==0&&(e.updateResourceOrders(),Util.orderingRoom().length>1&&(e.updateRoomOrders(),e.terminalBroker()))}),this.prototypeExtend=(()=>{Util.define(Room,a)})}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(2);t.default=new class extends o.RoomExtra{constructor(){super("power"),this.analyzeRoom=((e,t)=>{t&&e.savePowerSpawn(),e.structures.powerSpawn&&e.processPower()}),this.freshRoom=(e=>{e._powerBank||delete e.memory.powerBank}),this.prototypeExtend=(()=>{this.assignRoomPrototype({powerBank:{get(){return _.isUndefined(this.memory.powerBank)&&([this._powerBank]=this.find(FIND_STRUCTURES,{filter:e=>e instanceof StructurePowerBank}),this._powerBank&&(this.memory.powerBank=this._powerBank.id)),_.isUndefined(this._powerBank)&&(this._powerBank=Game.getObjectById(this.memory.powerBank)),this._powerBank}},savePowerSpawn:{value(){let e=this.find(FIND_MY_STRUCTURES,{filter:e=>e.structureType==STRUCTURE_POWER_SPAWN});if(e.length>0){this.memory.powerSpawns=[];let t=e=>{this.memory.powerSpawns.find(t=>t.id==e.id)||this.memory.powerSpawns.push({id:e.id})};e.forEach(t)}else delete this.memory.powerSpawns}},processPower:{value(){let e=this.find(FIND_MY_STRUCTURES,{filter:e=>e.structureType==STRUCTURE_POWER_SPAWN});for(let t=0;t<e.length;t++){let r=e[t];r.energy>=POWER_SPAWN_ENERGY_RATIO&&r.power>=1&&(LOG_TRACE&&Log.trace("Room",{roomName:this.name,actionName:"processPower"}),r.processPower())}}}})}),this.roomManagerExtend=(()=>{this.assignRoomManager({PowerSpawn:function(e){this.room=e,Object.defineProperties(this,{all:{get(){if(_.isUndefined(this._all)){this._all=[];let e=e=>{let t=Game.getObjectById(e.id);t&&(_.assign(t,e),this._all.push(t))};_.forEach(this.room.memory.powerSpawns,e)}return this._all}}})}})})}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(2);t.default=new class extends o.RoomExtra{constructor(){super("resources"),this.analyzeRoom=((e,t)=>{t&&e.saveMinerals()}),this.prototypeExtend=(()=>{this.assignRoomPrototype({resourcesStorage:{get(){return _.isUndefined(this._resourcesStorage)&&(this._resourcesStorage={},_.isUndefined(this.storage)||Object.keys(this.storage.store).forEach(e=>{_.isUndefined(this._resourcesStorage[e])&&(this._resourcesStorage[e]=this.storage.store[e])})),this._resourcesStorage}},resourcesTerminal:{get(){return _.isUndefined(this._resourcesTerminal)&&(this._resourcesTerminal={},_.isUndefined(this.terminal)||Object.keys(this.terminal.store).forEach(e=>{_.isUndefined(this._resourcesTerminal[e])&&(this._resourcesTerminal[e]=this.terminal.store[e])})),this._resourcesTerminal}},resourcesLabs:{get(){if(_.isUndefined(this._resourcesLabs)){this._resourcesLabs={};let e=this.memory.resources;if(!_.isUndefined(e)&&!_.isUndefined(e.lab))for(let t of e.lab)if("Storage"!==t.reactionState){const e=Game.getObjectById(t.id),r=e.mineralType,o=e.mineralAmount;_.isUndefined(r)||(_.isUndefined(this._resourcesLabs[r])?this._resourcesLabs[r]=o:this._resourcesLabs[r]+=o)}}return this._resourcesLabs}},resourcesCreeps:{get(){if(_.isUndefined(this._resourcesCreeps)){this._resourcesCreeps={};for(let e of this.creeps)Object.keys(e.carries).forEach(t=>{_.isUndefined(this._resourcesCreeps[t])?this._resourcesCreeps[t]=e.carry[t]:this._resourcesCreeps[t]+=e.carry[t]})}return this._resourcesCreeps}},resourcesOffers:{get(){if(_.isUndefined(this._resourcesOffers)){this._resourcesOffers={};let e=this.memory.resources;_.isUndefined(e)||_.isUndefined(e.offers)||(this._resourcesOffers=Util.sumCompoundType(e.offers))}return this._resourcesOffers}},resourcesOrders:{get(){if(_.isUndefined(this._resourcesOrders)){this._resourcesOrders={};let e=this.memory.resources;_.isUndefined(e)||_.isUndefined(e.orders)||(this._resourcesOrders=Util.sumCompoundType(e.orders))}return this._resourcesOrders}},resourcesReactions:{get(){if(_.isUndefined(this._resourcesReactions)){this._resourcesReactions={};let e=this.memory.resources;if(!_.isUndefined(e)&&!_.isUndefined(e.reactions)&&!_.isUndefined(e.reactions.orders)&&1===e.reactions.orders.length){const t=e.reactions,r=t.orders[0],o=r.type,a=r.amount,i=LAB_REACTIONS[o][0],n=LAB_REACTIONS[o][1],s=Game.getObjectById(t.seed_a),l=Game.getObjectById(t.seed_b),m=s.mineralAmount,c=l.mineralAmount;this._resourcesReactions[i]=a-m,this._resourcesReactions[n]=a-c}}return this._resourcesReactions}},resourcesAll:{get(){return _.isUndefined(this._resourcesAll)&&(this._resourcesAll={},_.isUndefined(this.storage)||Object.keys(this.storage.store).forEach(e=>{_.isUndefined(this._resourcesAll[e])&&(this._resourcesAll[e]=this.storedMinerals(e))}),_.isUndefined(this.terminal)||Object.keys(this.terminal.store).forEach(e=>{_.isUndefined(this._resourcesAll[e])&&(this._resourcesAll[e]=this.storedMinerals(e))})),this._resourcesAll}},droppedResources:{get(){return _.isUndefined(this._droppedResources)&&(this._droppedResources=this.find(FIND_DROPPED_RESOURCES)),this._droppedResources}},minerals:{get(){if(_.isUndefined(this._minerals)){this._minerals=[];let e=e=>{Util.addById(this._minerals,e)};_.forEach(this.memory.minerals,e)}return this._minerals}},mineralType:{get(){if(_.isUndefined(this.memory.mineralType)){let e=this.find(FIND_MINERALS);e&&e.length>0?this.memory.mineralType=e[0].mineralType:this.memory.mineralType=""}return this.memory.mineralType}},sources:{get(){if((_.isUndefined(this.memory.sources)||"sim"==this.name)&&(this._sources=this.find(FIND_SOURCES),this._sources.length>0?this.memory.sources=this._sources.map(e=>e.id):this.memory.sources=[]),_.isUndefined(this._sources)){this._sources=[];let e=e=>{Util.addById(this._sources,e)};this.memory.sources.forEach(e)}return this._sources}},sourceAccessibleFields:{get(){if(_.isUndefined(this.memory.sourceAccessibleFields)){let e=0,t=this.sources,r=t=>e+=t.accessibleFields;_.forEach(t,r),this.memory.sourceAccessibleFields=e}return this.memory.sourceAccessibleFields}},sourceEnergyAvailable:{get(){if(_.isUndefined(this._sourceEnergyAvailable)){this._sourceEnergyAvailable=0;let e=e=>this._sourceEnergyAvailable+=e.energy;_.forEach(this.sources,e)}return this._sourceEnergyAvailable}},ticksToNextRegeneration:{get(){return _.isUndefined(this._ticksToNextRegeneration)&&(this._ticksToNextRegeneration=_(this.sources).map("ticksToRegeneration").min()||0),this._ticksToNextRegeneration}},saveMinerals:{value(){let e=this.structures.all.filter(e=>e.structureType===STRUCTURE_EXTRACTOR&&e.active).map(e=>({x:e.pos.x,y:e.pos.y}));const t=this.find(FIND_MINERALS).filter(t=>_.some(e,{x:t.pos.x,y:t.pos.y}));if(t.length>0){let e=e=>e.id;this.memory.minerals=_.map(t,e)}else delete this.memory.minerals}}})})}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(2);t.default=new class extends o.RoomExtra{constructor(){super("spawn"),this.analyzeRoom=((e,t)=>{t&&e.saveSpawns()}),this.prototypeExtend=(()=>{this.assignRoomPrototype({spawnQueueHigh:{get(){return _.isUndefined(this.memory.spawnQueueHigh)&&(this.memory.spawnQueueHigh=[]),this.memory.spawnQueueHigh}},spawnQueueMedium:{get(){return _.isUndefined(this.memory.spawnQueueMedium)&&(this.memory.spawnQueueMedium=[]),this.memory.spawnQueueMedium}},spawnQueueLow:{get(){return _.isUndefined(this.memory.spawnQueueLow)&&(this.memory.spawnQueueLow=[]),this.memory.spawnQueueLow}},saveSpawns:{value(){let e=this.find(FIND_MY_SPAWNS);if(e.length>0){let t=e=>e.id;this.memory.spawns=_.map(e,t)}else delete this.memory.spawns}}})}),this.roomManagerExtend=(()=>{this.assignRoomManager({bestSpawnRoomFor:e=>_.min(Game.rooms,t=>t.my?Util.routeRange(t.name,e):1/0),findSpawnRoom:e=>{if(!e||!e.targetRoom)return null;let t=_.filter(Game.rooms,t=>t.my&&(void 0===e.maxRange||Util.routeRange(t.name,e.targetRoom)<=e.maxRange)&&(void 0===e.minEnergyCapacity||e.minEnergyCapacity<=t.energyCapacityAvailable)&&(void 0===e.minEnergyAvailable||e.minEnergyAvailable<=t.energyAvailable)&&(t.name!=e.targetRoom||!0===e.allowTargetRoom)&&(void 0===e.minRCL||t.RCL>=e.minRCL)&&(void 0===e.callBack||e.callBack(t)));if(0==t.length)return null;let r=e=>_.sum(e,e=>3*e.parts.length);return _.min(t,t=>Util.routeRange(t.name,e.targetRoom)+(8-t.RCL)/(e.rangeRclRatio||3)+(e=>(.9*r(e.spawnQueueLow)+r(e.spawnQueueMedium)+1.1*r(e.spawnQueueHigh))/e.structures.spawns.length)(t)/(e.rangeQueueRatio||51))}})})}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(2);t.default=new class extends o.RoomExtra{constructor(){super("tower"),this.analyzeRoom=((e,t)=>{t&&e.saveTowers()}),this.runRoom=((e,t)=>{const r=Game.rooms[t];r&&r.structures.towers.length>0&&TowerManager.loop(r)}),this.prototypeExtend=(()=>{this.assignRoomPrototype({towerFreeCapacity:{get(){if(_.isUndefined(this._towerFreeCapacity)){this._towerFreeCapacity=0;let e=e=>this._towerFreeCapacity+=e.energyCapacity-e.energy;_.forEach(this.structures.towers,e)}return this._towerFreeCapacity}},saveTowers:{value(){let e=this.find(FIND_MY_STRUCTURES,{filter:{structureType:STRUCTURE_TOWER}});if(e.length>0){let t=e=>e.id;this.memory.towers=_.map(e,t)}else delete this.memory.towers}}})})}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(2);t.default=new class extends o.RoomExtra{constructor(){super("fillRoomOrders"),this.analyze=(()=>{this.fillRoomOrders()}),this.fillRoomOrders=(()=>{if(!MAKE_COMPOUNDS&&!ALLOCATE_COMPOUNDS)return;_.isUndefined(Memory.boostTiming)&&(Memory.boostTiming={}),_.isUndefined(Memory.boostTiming.roomTrading)&&(Memory.boostTiming.roomTrading={boostProduction:!1,boostAllocation:!1}),_.isUndefined(Memory.boostTiming.timeStamp)&&(Memory.boostTiming.timeStamp=Game.time);const e=Util.orderingRoom(),t=e.length,r=Memory.boostTiming.roomTrading,o=_.filter(Game.rooms,{my:!0}),a=_.some(o,e=>{let t=e.memory.resources;return!(!t||!t.boostTiming)&&"reactionPlaced"===t.boostTiming.roomState});let i;if(a&&!1===Memory.boostTiming.roomTrading.boostProduction&&(Memory.boostTiming.roomTrading.boostProduction=!0,Memory.boostTiming.timeStamp=Game.time),1===t){let t=e[0];r.boostProduction&&(i=`BOOST_PRODUCTION since: ${Game.time-Memory.boostTiming.timeStamp}`),r.boostAllocation&&(i=`BOOST_ALLOCATION since: ${Game.time-Memory.boostTiming.timeStamp}`),Memory.boostTiming.multiOrderingRoomName?Log.module(t.name,`multi ordering in progress at ${Memory.boostTiming.multiOrderingRoomName}`):Log.module(t.name,`orderingRoom.name: ${t.name}, checkRoomAt: ${(t.memory.resources.boostTiming.checkRoomAt||0)-Game.time} ${i}`)}else t>1&&(Log.warn(`${t} ordering rooms!`),Log.table(e));if(1===e.length&&Game.time>=e[0].memory.resources.boostTiming.checkRoomAt&&!Memory.boostTiming.multiOrderingRoomName){const t=e[0],r=t.memory.resources;if(t.ordersWithOffers()){let e=t.checkOffers();Log.module(t.name,`checkOffers running from ${t.name} returnValue: ${e}`)}else Log.module(t.name,`${t.name} no offers found, updating offers`),t.GCOrders(),Log.stringify(r.orders)}else if(0===e.length){let e=Memory.boostTiming.roomTrading;!0!==e.boostProduction||a?!0===e.boostAllocation&&(e.boostAllocation=!1,Memory.boostTiming.timeStamp=Game.time):(e.boostProduction=!1,Memory.boostTiming.timeStamp=Game.time)}if((MAKE_COMPOUNDS||ALLOCATE_COMPOUNDS)&&Memory.boostTiming&&Memory.boostTiming.multiOrderingRoomName){const e=Game.rooms[Memory.boostTiming.multiOrderingRoomName],t=e.memory.resources.boostTiming.ordersReady,r=t.orderCandidates;let o=!1;if(Game.time<t.time)return;if(0===r.length)return Log.module(e.name,`all ready offers completed to ${Memory.boostTiming.multiOrderingRoomName} Memory.boostTiming.multiOrderingRoomName deleted.`),Game.rooms[Memory.boostTiming.multiOrderingRoomName].memory.resources.boostTiming.checkRoomAt=Game.time+CHECK_ORDERS_INTERVAL,delete Memory.boostTiming.multiOrderingRoomName,void delete e.memory.resources.boostTiming.ordersReady;for(let a=0;a<r.length;a++){const i=r[a],n=Game.rooms[i.room];if(i.readyOffers>0){if(n.terminal.cooldown>0){Log.module(n.name,`${n.name} terminal.cooldown: ${n.terminal.cooldown} fillARoomOrder() delayed.`),t.time=Game.time+n.terminal.cooldown;continue}t.time=Game.time+1,Log.module(e.name,`running ${i.room} fillARoomOrder() in a row, time: ${Game.time} readyOffers: ${i.readyOffers}`),!0===(o=n.fillARoomOrder())?(i.readyOffers--,i.readyOffers>=1?Log.module(i.room,`has ${i.readyOffers} remains fillRoomOrders check. readyOffers: ${i.readyOffers}`):(Log.module(e.name,`offers from ${i.room} are completed`),r.splice(a,1),a--)):o===ERR_TIRED?(t.time=Game.time+n.terminal.cooldown,Log.module(i.room,`${i.room} offers from ${i.room} failed send to ${e.name}.  Terminal.cooldown: ${n.terminal.cooldown}`)):o===ERR_NOT_ENOUGH_RESOURCES?(Log.module(e.name,`WARNING: offers from ${i.room} are not completed: not enough resources`),r.splice(a,1),a--):!0!==o&&o!==OK&&(Log.module(e.name,`WARNING: offers from ${i.room} are not completed. Offers deleted. terminal.send returns: ${Util.translateErrorCode(o)}`),r.splice(a,1),a--)}}}})}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(2);t.default=new class extends o.RoomExtra{constructor(){super("boostProduction"),this.analyze=(()=>{this.boostProduction()}),this.boostProduction=(()=>{if(!MAKE_COMPOUNDS)return;let e=Memory.boostTiming.roomTrading;if(!e.boostAllocation&&!e.reallocating&&Game.time%MAKE_COMPOUNDS_INTERVAL==0){const e=_.filter(Game.rooms,{my:!0}),t=Util.orderingRoom(),r=_.some(e,e=>{let t=e.memory.resources;return!(!t||!t.boostTiming)&&"reactionPlaced"===t.boostTiming.roomState}),o=t.length;let a=!1;for(let t of e){let e=t.memory.resources;if(_.isUndefined(e))continue;const i=e.boostTiming,n=()=>{if(0===e.reactions.orders.length)return!1;let t=e.reactions.orders[0].type;return _.some(e.lab,e=>{let r=Game.getObjectById(e.id);return r.mineralType===t&&r.mineralAmount>0})};if(0!==e.orders.length&&0!==_.sum(e.orders,"amount")||"ordersPlaced"!==i.roomState||n()&&(i.roomState="reactionMaking",i.checkRoomAt=Game.time,delete i.getOfferAttempts,Log.module(t.name,`${t.name} orders done.`)),0!==o||r||a||(a=t.makeReaction()),e.reactions&&"burst"===e.reactions.reactorMode&&"reactionMaking"===e.boostTiming.roomState&&i.checkRoomAt-Game.time<=150&&Game.time%50==0){let r=e.reactions.orders[0];Log.module(t.name,`${t.name}, finishing ${r.type}. checkRoomAt: ${i.checkRoomAt-Game.time}`);const o=Game.getObjectById(e.reactions.seed_a),a=Game.getObjectById(e.reactions.seed_b),n=r.type,s=LAB_REACTIONS[n][0],l=LAB_REACTIONS[n][1],m=r.amount,c=t.getSeedLabOrders(),u=c.labOrderAmountA,d=c.labOrderAmountB,h=t.resourcesAll[s],g=t.resourcesAll[l],p=o.mineralAmount+u,f=a.mineralAmount+d;if(Log.module(t.name,`reactionAmount ${m}`),Log.module(t.name,`labs stored: seed_a: ${o.mineralAmount} ${s} seed_b: ${a.mineralAmount} ${l}`),Log.module(t.name,`labs ordered: seed_a: ${u} ${s} seed_b: ${d} ${l}`),p===m&&f===m)Log.module(t.name,"lab orders OK"),m>0&&((_.isUndefined(h)||0===h)&&o.mineralAmount<LAB_REACTION_AMOUNT||(_.isUndefined(g)||0===g)&&a.mineralAmount<LAB_REACTION_AMOUNT)&&(r.amount=0,Log.module(t.name,"resources NOT OK"),Log.module(t.name,`resourcesA: ${h} resourcesB: ${g}`),Log.module(t.name,`reactionOrders fixed: ${r.amount}`));else if(m>p||m>f){Log.module(t.name,"NOT ENOUGH lab orders:"),Log.module(t.name,`${t.name} reactionAmount: ${m} DIFF: labA: ${p-m} labB: ${f-m}`);let e=Math.min(p,f);e>=LAB_REACTION_AMOUNT?r.amount=e:r.amount=0,Log.module(t.name,`reactionOrders fixed: ${r.amount}`)}else if(m<p||m<f){Log.module(t.name,"TOO MUCH lab orders:"),Log.module(t.name,`${t.name} reactionAmount: ${m} DIFF: labA: ${p-m} labB: ${f-m}`);let e=Math.min(p,f);e>=LAB_REACTION_AMOUNT?r.amount=e:r.amount=0,Log.module(t.name,`reactionOrders fixed: ${r.amount}`)}}Game.time>=i.checkRoomAt&&"reactionMaking"===e.boostTiming.roomState&&(_.sum(e.reactions.orders,"amount")>0?(i.reactionMaking=Game.time,t.countCheckRoomAt(),Log.module(t.name,`${t.name} checkRoomAt counted: ${i.checkRoomAt-Game.time}`)):(Log.module("BoostPriduction",`Game.time: ${Game.time}`),Log.module(t.name,`reactions done in in ${t.name}`),e.boostTiming={}))}}})}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(3);t.default=new class extends o.Component{constructor(){super(...arguments),this.priorityHigh=[CreepManager.setup.worker,CreepManager.setup.miner,CreepManager.setup.hauler,CreepManager.setup.upgrader],this.priorityLow=[CreepManager.setup.mineralMiner,CreepManager.setup.privateer],this.register=(()=>{CreepManager.spawningCompleted.on(e=>this.handleSpawningCompleted(e))}),this.handleSpawningCompleted=(e=>{LOG_TRACE&&Log.trace("Spawn",{behaviour:e.data.creepType,creepName:e.name,Spawn:"CreepManager.spawningCompleted"}),CENSUS_ANNOUNCEMENTS&&Log.room(e.pos.roomName,Dye(COLOR_GREEN,Util.emoji.tick,e.name,"was born!"))}),this.run=(()=>{_.forEach(Game.spawns,e=>{e.room.my&&e.run()})})}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(3);t.default=new class extends o.Component{constructor(){super(...arguments),this.state={},this.loop=(e=>{this.state={hurtCreeps:e.hurtCreeps,urgentRepairable:e.structures.urgentRepairable,hostiles:e.hostiles,invasion:e.situation.invasion},_.forEach(e.structures.towers,this.run)}),this.run=(e=>{e&&this.runHeal(e,this.state.hurtCreeps,this.state.invasion)!==OK&&this.runRepair(e,this.state.urgentRepairable)!==OK&&this.runAttack(e,this.state.hostiles)}),this.runHeal=((e,t,r)=>{if(0===t.length)return;let o=t[0];if(o.hitsMax-o.hits>=400||!r){const t=e.heal(o);return _.isUndefined(o.towers)&&(o.towers=[]),o.towers.push(e.id),t}}),this.runRepair=((e,t)=>{if(0===t.length)return;let r=t[0];const o=e.repair(r);return _.isUndefined(r.towers)&&(r.towers=[]),r.towers.push(e.id),o}),this.runAttack=((e,t)=>{if(0===t.length)return;let r=e.pos.findClosestByRange(t);return r?e.attack(r):void 0})}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(3);t.default=new class extends o.Component{constructor(){super(...arguments),this.run=(()=>{_.forEach(Memory.rooms,(e,t)=>{if(this.RCL=e.RCL,!this.RCL||this.RCL<1)return;if(!e.center){const e=Game.rooms[t].storage;if(!e)return;Util.setRoomCenter(t,e.pos.x,e.pos.y)}e.RBL||(e.RBL=0),e.RDL||(e.RDL=0);const r=e.RBL,o=e.RDL,a=e.center;return 8!==r||8!==o?(this.x=a.x-6,this.y=a.y-6,this.room=Game.rooms[t],r!==this.RCL?this.build(this.layout[r]):o!==this.RCL&&0===_.size(Game.constructionSites)?this.build(this.defendLayout[o],!0):void 0):void 0})}),this.build=((e,t)=>{null===e&&(t?this.room.memory.RDL++:this.room.memory.RBL++);let r=!0;_.forEach(e,(e,o)=>{_.forEach(e,(e,a)=>{if(0===e)return;const i=this.room.createConstructionSite(this.x+a,this.y+o,t?STRUCTURE_RAMPART:this.structureType[e]);_.include([ERR_INVALID_TARGET,ERR_RCL_NOT_ENOUGH]||i===ERR_FULL,i)||(r=!1)})}),r&&(t?this.room.memory.RDL++:this.room.memory.RBL++)}),this.structureType={1:STRUCTURE_ROAD,2:STRUCTURE_EXTENSION,3:STRUCTURE_TOWER,4:STRUCTURE_SPAWN,5:STRUCTURE_POWER_SPAWN,6:STRUCTURE_STORAGE,7:STRUCTURE_LINK,8:STRUCTURE_TERMINAL,9:STRUCTURE_LAB,10:STRUCTURE_NUKER},this.defendLayout={0:null,1:[[0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,1,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0]],2:[[0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,1,0,0,0,0,0,0],[0,0,0,0,0,0,1,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0]],3:[[0,1,1,1,1,1,1,1,1,1,1,1,0],[1,1,0,0,0,0,0,0,0,0,0,1,1],[1,0,0,0,0,0,0,0,0,0,0,0,1],[1,0,0,0,0,0,0,0,0,0,0,0,1],[1,0,0,0,0,0,1,0,0,0,0,0,1],[1,0,0,0,0,1,1,1,0,0,0,0,1],[1,0,0,0,0,0,1,0,0,0,0,0,1],[1,0,0,0,0,0,0,0,0,0,0,0,1],[1,0,0,0,0,0,0,0,0,0,0,0,1],[1,0,0,0,0,0,0,0,0,0,0,0,1],[1,0,0,0,0,0,0,0,0,0,0,0,1],[1,1,0,0,0,0,0,0,0,0,0,1,1],[0,1,1,1,1,1,1,1,1,1,1,1,0]],4:[[0,1,1,1,1,1,1,1,1,1,1,1,0],[1,1,0,0,0,0,0,0,0,0,0,1,1],[1,0,0,0,0,0,0,0,0,0,0,0,1],[1,0,0,0,0,0,0,0,0,0,0,0,1],[1,0,0,0,0,0,1,0,0,0,0,0,1],[1,0,0,0,0,1,1,1,0,0,0,0,1],[1,0,0,0,1,1,1,1,1,0,0,0,1],[1,0,0,0,0,1,1,1,0,0,0,0,1],[1,0,0,0,0,0,1,0,0,0,0,0,1],[1,0,0,0,0,0,0,0,0,0,0,0,1],[1,0,0,0,0,0,0,0,0,0,0,0,1],[1,1,0,0,0,0,0,0,0,0,0,1,1],[0,1,1,1,1,1,1,1,1,1,1,1,0]],5:[[0,1,1,1,1,1,1,1,1,1,1,1,0],[1,1,0,0,1,0,0,0,1,0,0,1,1],[1,0,0,0,0,0,0,0,0,0,0,0,1],[1,0,0,0,0,0,0,0,0,0,0,0,1],[1,1,0,0,0,1,1,1,0,0,0,1,1],[1,0,0,0,1,1,1,1,1,0,0,0,1],[1,0,0,0,1,1,1,1,1,0,0,0,1],[1,0,0,0,1,1,1,1,1,0,0,0,1],[1,1,0,0,0,1,1,1,0,0,0,1,1],[1,0,0,0,0,0,0,0,0,0,0,0,1],[1,0,0,0,0,0,0,0,0,0,0,0,1],[1,1,0,0,1,0,0,0,1,0,0,1,1],[0,1,1,1,1,1,1,1,1,1,1,1,0]],6:[[0,1,1,1,1,1,1,1,1,1,1,1,0],[1,1,1,1,1,1,1,1,1,1,1,1,1],[1,1,0,0,0,0,0,0,0,0,0,1,1],[1,1,0,0,0,0,0,0,0,0,0,1,1],[1,1,0,0,1,1,1,1,1,0,0,1,1],[1,1,0,0,1,1,1,1,1,0,0,1,1],[1,1,0,0,1,1,1,1,1,0,0,1,1],[1,1,0,0,1,1,1,1,1,0,0,1,1],[1,1,0,0,1,1,1,1,1,0,0,1,1],[1,1,0,0,0,0,0,0,0,0,0,1,1],[1,1,0,0,0,0,0,0,0,0,0,1,1],[1,1,1,1,1,1,1,1,1,1,1,1,1],[0,1,1,1,1,1,1,1,1,1,1,1,0]],7:[[0,1,1,1,1,1,1,1,1,1,1,1,0],[1,1,1,1,1,1,1,1,1,1,1,1,1],[1,1,0,0,0,0,0,0,0,0,0,1,1],[1,1,0,0,0,0,0,0,0,0,0,1,1],[1,1,0,0,1,1,1,1,1,0,0,1,1],[1,1,0,0,1,1,1,1,1,0,0,1,1],[1,1,0,0,1,1,1,1,1,0,0,1,1],[1,1,0,0,1,1,1,1,1,0,0,1,1],[1,1,0,0,1,1,1,1,1,0,0,1,1],[1,1,0,0,0,0,0,0,0,0,0,1,1],[1,1,0,0,0,0,0,0,0,0,0,1,1],[1,1,1,1,1,1,1,1,1,1,1,1,1],[0,1,1,1,1,1,1,1,1,1,1,1,0]]},this.layout={0:[[0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,1,0,0,0,0,0,0],[0,0,0,0,0,1,4,1,0,0,0,0,0],[0,0,0,0,1,0,0,0,1,0,0,0,0],[0,0,0,1,0,0,0,0,0,1,0,0,0],[0,0,0,0,1,0,0,0,1,0,0,0,0],[0,0,0,0,0,1,0,1,0,0,0,0,0],[0,0,0,0,0,0,1,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0]],1:[[0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,1,0,0,0,0,0,0,0,0],[0,0,0,1,2,1,0,0,0,0,0,0,0],[0,0,1,2,0,2,1,0,0,0,0,0,0],[0,1,2,0,0,1,4,1,0,0,0,0,0],[0,0,1,2,1,1,0,1,1,0,0,0,0],[0,0,0,1,0,0,0,0,0,1,0,0,0],[0,0,0,0,1,1,1,1,1,0,0,0,0],[0,0,0,0,0,1,0,1,0,0,0,0,0],[0,0,0,0,0,0,1,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0]],2:[[0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,1,0,0,0,1,0,0,0,0],[0,0,0,1,2,1,0,1,2,1,0,0,0],[0,0,1,2,0,2,1,2,0,2,1,0,0],[0,1,2,0,0,1,4,1,0,0,2,1,0],[0,0,1,2,1,1,3,1,1,2,1,0,0],[0,0,0,1,0,0,0,0,0,1,0,0,0],[0,0,0,0,1,1,1,1,1,0,0,0,0],[0,0,0,0,0,1,0,1,0,0,0,0,0],[0,0,0,0,0,0,1,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0]],3:[[0,1,1,1,0,1,1,1,0,1,1,1,0],[1,0,0,2,1,0,0,0,1,2,0,0,1],[1,0,2,1,2,1,0,1,2,1,2,0,1],[1,2,1,2,2,2,1,2,2,2,1,2,1],[0,1,2,2,0,1,4,1,0,2,2,1,0],[1,0,1,2,1,1,3,1,1,2,1,0,1],[1,0,0,1,0,0,6,0,0,1,0,0,1],[1,0,1,0,1,1,1,1,1,0,1,0,1],[0,1,0,0,0,1,0,1,0,0,0,1,0],[1,0,1,0,0,0,1,0,0,0,1,0,1],[1,0,0,1,0,1,0,1,0,1,0,0,1],[1,0,0,0,1,0,0,0,1,0,0,0,1],[0,1,1,1,0,1,1,1,0,1,1,1,0]],4:[[0,1,1,1,0,1,1,1,0,1,1,1,0],[1,0,0,2,1,0,0,0,1,2,0,0,1],[1,0,2,1,2,1,0,1,2,1,2,0,1],[1,2,1,2,2,2,1,2,2,2,1,2,1],[0,1,2,2,0,1,4,1,0,2,2,1,0],[1,0,1,2,1,1,3,1,1,2,1,0,1],[1,0,0,1,0,3,6,0,0,1,0,0,1],[1,0,1,2,1,1,1,1,1,0,1,0,1],[0,1,2,2,0,1,7,1,0,0,0,1,0],[1,2,1,2,2,2,1,0,0,0,1,0,1],[1,0,2,1,2,1,0,1,0,1,0,0,1],[1,0,0,2,1,0,0,0,1,0,0,0,1],[0,1,1,1,0,1,1,1,0,1,1,1,0]],5:[[0,1,1,1,0,1,1,1,0,1,1,1,0],[1,0,2,2,1,0,0,0,1,2,2,0,1],[1,2,2,1,2,1,2,1,2,1,2,2,1],[1,2,1,2,2,2,1,2,2,2,1,2,1],[0,1,2,2,0,1,4,1,0,2,2,1,0],[1,0,1,2,1,1,3,1,1,2,1,0,1],[1,0,2,1,0,3,6,0,0,1,2,0,1],[1,0,1,2,1,1,1,1,1,0,1,0,1],[0,1,2,2,0,1,7,1,8,0,0,1,0],[1,2,1,2,2,2,1,0,0,9,1,0,1],[1,2,2,1,2,1,2,1,9,1,9,0,1],[1,0,2,2,1,0,0,0,1,0,0,0,1],[0,1,1,1,0,1,1,1,0,1,1,1,0]],6:[[0,1,1,1,0,1,1,1,0,1,1,1,0],[1,0,2,2,1,2,0,2,1,2,2,0,1],[1,2,2,1,2,1,2,1,2,1,2,2,1],[1,2,1,2,2,2,1,2,2,2,1,2,1],[0,1,2,2,0,1,4,1,0,2,2,1,0],[1,2,1,2,1,1,3,1,1,2,1,2,1],[1,2,2,1,4,3,6,3,0,1,2,2,1],[1,2,1,2,1,1,1,1,1,0,1,2,1],[0,1,2,2,0,1,7,1,8,0,9,1,0],[1,2,1,2,2,2,1,0,0,9,1,9,1],[1,2,2,1,2,1,2,1,9,1,9,0,1],[1,0,2,2,1,2,0,2,1,9,0,0,1],[0,1,1,1,0,1,1,1,0,1,1,1,0]],7:[[0,1,1,1,2,1,1,1,2,1,1,1,0],[1,0,2,2,1,2,10,2,1,2,2,0,1],[1,2,2,1,2,1,2,1,2,1,2,2,1],[1,2,1,2,2,2,1,2,2,2,1,2,1],[2,1,2,2,3,1,4,1,3,2,2,1,2],[1,2,1,2,1,1,3,1,1,2,1,2,1],[1,2,2,1,4,3,6,3,4,1,2,2,1],[1,2,1,2,1,1,1,1,1,2,1,2,1],[2,1,2,2,3,1,7,1,8,9,9,1,2],[1,2,1,2,2,2,1,2,9,9,1,9,1],[1,2,2,1,2,1,2,1,9,1,9,9,1],[1,0,2,2,1,2,5,2,1,9,9,0,1],[0,1,1,1,2,1,1,1,2,1,1,1,0]]}}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(3);t.default=new class extends o.Component{constructor(){super(...arguments),this.run=(()=>{Memory.stats={tick:Game.time},Memory.stats.cpu=Game.cpu,Memory.stats.cpu.used=Game.cpu.getUsed(),Memory.stats.gcl=Game.gcl,Memory.stats.market={credits:Game.market.credits,numOrders:Game.market.orders?Object.keys(Game.market.orders).length:0},Memory.stats.rooms={};for(let e in Game.rooms){const t=Game.rooms[e];t&&t.my&&(Memory.stats.rooms[t.name]={name:t.name,spawns:{},storage:{},terminal:{},minerals:{},sources:{}},this.init(t,Memory.stats.rooms[t.name]))}}),this.init=((e,t)=>{this.controller(e,t),this.energy(e,t),this.spawns(e,t.spawns),this.storage(e,t.storage),this.terminal(e,t.terminal),this.minerals(e,t.minerals),this.sources(e,t.sources)}),this.controller=((e,t)=>{e.controller&&(t.controller={level:e.RCL,progress:e.controller.progress,progressTotal:e.controller.progressTotal})}),this.energy=((e,t)=>{t.energy={available:e.energyAvailable,capacityAvailable:e.energyCapacityAvailable}}),this.spawns=((e,t)=>{e.structures.spawns&&e.structures.spawns.forEach(e=>{t[e.name]={name:e.name,spawning:null!==e.spawning?1:0}})}),this.storage=((e,t)=>{e.storage&&(t.store=_.sum(e.storage.store),t.resources={},Object.keys(e.storage.store).forEach(r=>t.resources[r]=e.storage.store[r]))}),this.terminal=((e,t)=>{e.terminal&&(t.store=_.sum(e.terminal.store),t.resources={},Object.keys(e.terminal.store).forEach(r=>t.resources[r]=e.terminal.store[r]))}),this.minerals=((e,t)=>{e.minerals&&e.minerals.forEach(e=>t[e.id]={id:e.id,density:e.density,mineralAmount:e.mineralAmount,mineralType:e.mineralType,ticksToRegeneration:e.ticksToRegeneration})}),this.sources=((e,t)=>{e.sources&&e.sources.forEach(e=>t[e.id]={id:e.id,energy:e.energy,energyCapacity:e.energyCapacity,ticksToRegeneration:e.ticksToRegeneration})})}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(6),a=r(162),i=r(163),n=r(164),s=r(165),l=r(166),m=r(167);t.default=new class extends o.VisualsBase{constructor(){super(...arguments),this.state={HeatMap:new s.HeatMap,Piechart:new a.Piechart,Sidebar:new i.Sidebar,ToolTip:new n.ToolTip,CreepVis:new l.CreepVis,RoomVis:new m.RoomVis},this.run=(()=>{const e=VISUALS.VISIBLE_ONLY,t=e?Util.getVisibleRooms():Object.keys(Game.rooms);_.forEach(t,t=>{const r=Game.rooms[t];r&&(ROOM_VISUALS_ALL||r.my)&&(e||r.controller)&&_.forEach(this.state,e=>e.run(r))})}),this.drawLine=((e,t,r)=>{if(e instanceof RoomObject&&(e=e.pos),t instanceof RoomObject&&(t=t.pos),!(e instanceof RoomPosition||t instanceof RoomPosition))throw new Error("Visuals: Point not a RoomPosition");if(e.roomName!==t.roomName)return;const o=new RoomVisual(e.roomName),a=r instanceof Creep?this.creepPathStyle(r):r||{};o.line(e,t,a)}),this.drawArrow=((e,t,r)=>{if(e instanceof RoomObject&&(e=e.pos),t instanceof RoomObject&&(t=t.pos),!(e instanceof RoomPosition||t instanceof RoomPosition))throw new Error("Visuals: Point not a RoomPosition");if(e.roomName!==t.roomName)return;const o=new RoomVisual(e.roomName);this.drawLine(e,t,r);const a=e.x-t.x,i=e.y-t.y,n=Math.atan2(i,a),s=.5*Math.log1p(Util.getDistance(e,t)),l=r instanceof Creep?this.creepPathStyle(r):r||{};o.line(t.x,t.y,t.x+s*Math.cos(n+.610865),t.y+s*Math.sin(n+.610865),l),o.line(t.x,t.y,t.x+s*Math.cos(n-.610865),t.y+s*Math.sin(n-.610865),l)})}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(6);t.Piechart=class extends o.VisualsBase{constructor(){super(...arguments),this.pieStyle={radius:1.2,fill:"rgba(0,0,0,.5)",stroke:"rgba(255,255,255,.5)"},this.pieFontStyle={color:"#FFFFFF",font:"0.8 Hack",align:"center",stroke:"rgba(0,0,0,0.8)"},this.pieTitleStyle={color:"#FFFFFF",font:"0.6 Hack",align:"center"},this.color="#62e6ac",this.run=(e=>{this.vis=new RoomVisual(e.name),VISUALS.ROOM&&e.controller&&this.drawRoomInfo(e)}),this.drawPie=((e,t,r,o,a,i)=>{i||(i=e);let n=1;0!==t&&(n=e/t),a={x:a.x,y:1*a.y*4.5},this.vis.circle(a,this.pieStyle);const s=[a],l=2*Math.PI,m=l*(n+.1),c=-Math.PI/2,u=l/32;for(let e=0;e<=m;e+=u)s.push({x:a.x+Math.cos(e+c),y:a.y-Math.cos(e)});s.push(a),this.vis.poly(s,{fill:o,opacity:1,stroke:o,strokeWidth:.05}),this.vis.text(Number.isFinite(i)?Util.formatNumber(i):i,a.x,a.y+.3,this.pieFontStyle);let d=.7;n>.35&&n<.65&&(d+=.3),this.vis.text(r,a.x,a.y+1.5+d,this.pieTitleStyle)}),this.drawRoomInfo=(e=>{this.vis.text(`${Util.emoji.home}${e.name}`,24.5,1.5,{font:"1 Hack",backgroundColor:"rgba(0,0,0,.5)"});let t=.5;this.drawPie(Math.round(Game.cpu.getUsed()),Game.cpu.limit,"CPU",this.color,{x:47,y:t++}),this.drawPie(Game.cpu.bucket,1e4,"Bucket",this.color,{x:47,y:t++}),this.drawPie(Math.round(Game.gcl.progress),Game.gcl.progressTotal,`GCL ${Game.gcl.level}`,this.color,{x:47,y:t++});const r=e.controller;if(r){let e,o,a="RCL",i=!0;8===r.level?(e=1,o=1):r.reservation?(e=r.reservation.ticksToEnd,o=5e3):r.owner?(e=Math.min(r.progress,r.progressTotal),o=r.progressTotal,a+=` ${r.level}`):i=!1,i&&this.drawPie(e,o,a,this.color,{x:47,y:t++},r.level)}const o=e.storage;o&&this.drawPie(o.sum,o.storeCapacity,"Store",this.color,{x:47,y:t++})})}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(6);t.Sidebar=class extends o.VisualsBase{constructor(){super(...arguments),this.infoStyle={align:"left",font:"0.8 Hack",backgroundColor:"rgba(0,0,0,.5)"},this.objectStyle={align:"left",font:"0.6 Hack",backgroundColor:"rgba(0,0,0,.1)",backgroundPadding:.2},this.titleStyle={align:"left",font:"bold 0.5 Hack",color:"rgba(0,0,0,.7)",backgroundPadding:.2},this.subStyle={align:"left",font:"0.4 Hack",opacity:.7},this.Y_PADDING=3,this.Y_MAEGIN=1.2,this.Y_LIST_MARGIN=1,this.run=(e=>{this.vis=new RoomVisual(e.name),VISUALS.ROOM_ORDERS&&this.drawRoomOrders(e,"orders"),VISUALS.ROOM_OFFERS&&this.drawRoomOrders(e,"offers"),VISUALS.STORAGE&&this.drawStoreInfo(e,"storage"),VISUALS.TERMINAL&&this.drawStoreInfo(e,"terminal")}),this.drawRoomOrders=((e,t)=>{let r=1;e.memory.resources&&e.memory.resources[t]&&_.size(e.memory.resources[t])&&(VISUALS.STORAGE&&e.storage&&(r+=this.Y_PADDING+_.size(e.storage.store)*this.Y_LIST_MARGIN),VISUALS.TERMINAL&&e.terminal&&(r+=this.Y_PADDING+_.size(e.terminal.store)*this.Y_LIST_MARGIN),"offers"===t&&VISUALS.ROOM_ORDERS&&e.memory.resources.orders&&(r+=this.Y_PADDING+_.size(e.memory.resources.orders)*this.Y_LIST_MARGIN),this.vis.text(`Room ${_.capitalize(t)}`,1,++r,this.infoStyle),this._roomOrdersObject(e.memory.resources[t],1,r+this.Y_MAEGIN-.5))}),this.drawStoreInfo=((e,t)=>{const r=e[t];if(!r||!_.size(r.store))return;let o=1;"terminal"===t&&VISUALS.STORAGE&&e.storage&&(o+=this.Y_PADDING+_.size(e.storage.store)*this.Y_LIST_MARGIN),this.vis.text(`${_.capitalize(t)} Contents`,1,++o,this.infoStyle);const a=r.sum,i=r.storeCapacity,n=`L: ${Util.formatNumber(i-a)}`,s=`${Util.formatNumber(a)}/${Util.formatNumber(i)}`;this.vis.text(`${n} (${s})`,1,o+1.2,this.subStyle),this._storageObject(r.store,1,o+this.Y_MAEGIN)}),this._drawList=((e,t,r,o)=>{const a=r===RESOURCE_ENERGY?"E":r,i=this.getResourceColour(r);this.vis.text(`${a}`,e,t,_.assign({backgroundColor:i},this.titleStyle)),this.vis.text(`${Util.formatNumber(o)}`,e+2,t,_.assign({backgroundColor:i},this.objectStyle))}),this._roomOrdersObject=((e,t,r)=>{_.forEach(e,e=>this._drawList(t,r+=this.Y_LIST_MARGIN,e.type,e.amount))}),this._storageObject=((e,t,r)=>{_.forEach(Object.keys(e),o=>this._drawList(t,r+=this.Y_LIST_MARGIN,o,e[o]))})}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(6);t.ToolTip=class extends o.VisualsBase{constructor(){super(...arguments),this.toolTipStyle={align:"left",font:"0.4 Hack",backgroundColor:"rgba(0,0,0,.5)"},this.weakestStyle={radius:.4,fill:"#FF0000",opacity:.3,strokeWidth:0},this.run=(e=>{this.vis=new RoomVisual(e.name),VISUALS.MINERAL&&this.drawMineralInfo(e.minerals),VISUALS.SOURCE&&e.sources.forEach(e=>this.drawSourceInfo(e)),VISUALS.CONTROLLER&&this.drawControllerInfo(e.controller),VISUALS.TRANSACTIONS&&this.drawTransactions(e),VISUALS.LABS&&e.structures.labs.all.forEach(e=>this.drawLabInfo(e)),VISUALS.TOWER&&e.structures.towers.forEach(e=>this.drawTowerInfo(e)),VISUALS.SPAWN&&e.structures.spawns.filter(e=>e.spawning).forEach(e=>this.drawSpawnInfo(e)),VISUALS.WALL&&this.highlightWeakest(e,STRUCTURE_WALL),VISUALS.RAMPART&&this.highlightWeakest(e,STRUCTURE_RAMPART),VISUALS.ROAD&&this.highlightWeakest(e,STRUCTURE_ROAD)}),this.drawSpawnInfo=(e=>{e.spawning&&this.vis.text(`${Util.emoji.baby} ${e.spawning.name}`,e.pos.x-.5,e.pos.y,this.toolTipStyle)}),this.drawMineralInfo=(e=>{if(!e||!e.room)return;const t=e.pos.x+.5,r=e.pos.y;e.mineralAmount?this.vis.text(`${Util.emoji.mining} ${Math.floor(e.mineralAmount)}`,t,r,this.toolTipStyle):this.vis.text(`${Util.emoji.reload} ${Util.formatNumber(e.ticksToRegeneration)}`,t,r,this.toolTipStyle)}),this.drawSourceInfo=(e=>{const t=e.pos.x+.5,r=e.pos.y;e.energy?this.vis.text(`${Util.emoji.mining} ${e.energy}`,t,r,this.toolTipStyle):this.vis.text(`${Util.emoji.reload} ${e.ticksToRegeneration}`,t,r,this.toolTipStyle)}),this.drawControllerInfo=(e=>{const t=e.pos.x+.5;let r=e.pos.y;const o=this.toolTipStyle;let a=`${Util.emoji.upgrading} Lv${e.level}`,i=`${Util.formatNumber(e.progress)}/${Util.formatNumber(e.progressTotal)} (${(e.progress/e.progressTotal*100).toFixed(2)}%)`,n=`${Util.emoji.reload} ${Util.formatNumber(e.ticksToDowngrade)}`;if(8===e.level)i="";else if(e.reservation)a=`${Util.emoji.flag} Reserved`,i="",n=`${Util.emoji.reload} ${e.reservation.ticksToEnd}`;else if(!e.owner)return;if(""!==i?this.vis.text(a+": "+i,t,r,o):this.vis.text(a,t,r,o),e.ticksToDowngrade<CONTROLLER_DOWNGRADE[e.level]||e.reservation){let e=Object.assign({},o,{color:"#FF0000"});this.vis.text(n,t,r+=1.2,e)}}),this.drawLabInfo=(e=>{if(!e.energy&&!e.mineralAmount&&!e.cooldown)return;const t=e.pos.x+.8;let r=e.pos.y-.5;e.mineralAmount&&this.vis.text(`M: ${e.mineralType} (${Util.formatNumber(e.mineralAmount)})`,t,r+=.4,Object.assign({color:this.getResourceColour(e.mineralType)},this.toolTipStyle)),e.cooldown&&this.vis.text(`C: ${e.cooldown}`,t,r+=.4,Object.assign({color:"#FF0000"},this.toolTipStyle))}),this.drawTowerInfo=(e=>{const t=e.energyCapacity-e.energy;t>0&&this.vis.text(`${Util.emoji.fueling} ${t}`,e.pos.x,e.pos.y,this.toolTipStyle)}),this.drawTransactions=(e=>{if(!e.terminal)return;const t=e.terminal.pos.x;let r=e.terminal.pos.y-1;const o=_(Game.market.incomingTransactions).concat(Game.market.outgoingTransactions).filter(t=>t.from===e.name||t.to===e.name).sortByOrder("time","desc").slice(0,2).value();0!==o.length&&(2===o.length&&(r-=.4),_.forEach(o,o=>{const a=!!o.sender&&o.sender.username===e.controller.owner.username,i=!!o.recipient&&o.sender.username===o.recipient.username,n=e.name===o.to,s=a||n?"#00FF00":"#FF0000",l=a?"+":"-";let m="";m=i||!o.order?`${n?o.from:o.to} : ${o.amount} ${o.resourceType}`:`${l}${o.amount*o.order.price}`,this.vis.text(m,t,r,{font:this.toolTipStyle.font,color:s}),r+=.4}))}),this.highlightWeakest=((e,t)=>{const r=_(e.find(FIND_STRUCTURES)).filter({structureType:t}).min("hits");if(r&&r.pos){this.vis.circle(r.pos.x,r.pos.y,this.weakestStyle);let e=r.pos.y-.5;const t=r.pos.lookFor(LOOK_STRUCTURES);if(_.find(t,e=>e instanceof StructureTower)&&VISUALS.TOWER)e+=.4;else if(_.find(t,e=>e instanceof StructureSpawn&&e.spawning)&&VISUALS.SPAWN)e+=.4;else{const r=_.find(t,e=>e instanceof StructureLab);r&&VISUALS.LABS&&(r.energy&&(e+=.4),r.mineralAmount&&(e+=.4),r.cooldown&&(e+=.4))}this.vis.text(`H: ${Util.formatNumber(r.hits)} (${(r.hits/r.hitsMax*100).toFixed(2)}%)`,r.pos.x+1,e,this.toolTipStyle)}})}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(6);t.HeatMap=class extends o.VisualsBase{constructor(){super(...arguments),this.run=(e=>{Util.set(Memory,"heatmap",!1),this.vis=new RoomVisual(e.name),VISUALS.HEATMAP&&(Game.time%VISUALS.HEATMAP_INTERVAL==0&&this.setHeatMapData(e),Memory.heatmap&&this.drawHeatMapData(e))}),this.setHeatMapData=(e=>{Util.set(e.memory,"heatmap",()=>{const t={};for(let r=0;r<50;r++)for(let o=0;o<50;o++)"wall"!==Game.map.getTerrainAt(e.getPositionAt(r,o))&&(t[`${String.fromCharCode(32+r)}${String.fromCharCode(32+o)}_x${r}-y${o}`]=0);return t}),e.creeps.filter(e=>!e.spawning).forEach(t=>{const r=t.pos.x,o=t.pos.y,a=`${String.fromCharCode(32+r)}${String.fromCharCode(32+o)}_x${r}-y${o}`;e.memory.heatmap[a]++})}),this.drawHeatMapData=(e=>{const t=Object.keys(e.memory.heatmap).map(t=>({n:e.memory.heatmap[t],x:t.charCodeAt(0)-32,y:t.charCodeAt(1)-32})),r=_.filter(t,e=>e.n>0),o=_.sum(r,e=>e.n)/r.length*2;r.forEach(e=>{const t=e.n/o,r=this.getColourByPercentage(Math.min(1,t));this.vis.rect(e.x-.5,e.y-.5,1,1,{fill:r})})})}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(6);t.CreepVis=class extends o.VisualsBase{constructor(){super(...arguments),this.run=(e=>{this.vis=new RoomVisual(e.name),VISUALS.CREEP&&_.forEach(e.creeps,e=>this.drawCreepPath(e))}),this.drawCreepPath=(e=>{if(e.action&&"idle"===e.action.name)return;if(_(e.pos).pick(["x","y"]).eq(e.data.determinatedSpot))return;if(!e.memory||!e.memory._travel||!e.memory._travel.path)return;const t=e.memory._travel.path.substr(1),r=this.creepPathStyle(e);let o=e.pos.x,a=e.pos.y;const i={[TOP]:{x:0,y:-1},[TOP_RIGHT]:{x:1,y:-1},[RIGHT]:{x:1,y:0},[BOTTOM_RIGHT]:{x:1,y:1},[BOTTOM]:{x:0,y:1},[BOTTOM_LEFT]:{x:-1,y:1},[LEFT]:{x:-1,y:0},[TOP_LEFT]:{x:-1,y:-1}};if(0===e.fatigue){const t=+e.memory._travel.path[0];o+=i[t].x,a+=i[t].y}for(let e of t)e=+e,this.vis.line(o,a,o+=i[e].x,a+=i[e].y,r)})}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(6);t.RoomVis=class extends o.VisualsBase{constructor(){super(...arguments),this.shapeStyle={fill:"#66D9EF",opacity:.03,stroke:"rgba(0,0,0,0)"},this.lineStyle={opacity:.1,stroke:"#666"},this.run=(e=>{this.vis=new RoomVisual(e.name),this.bluePring(e),this.bluePring(e)}),this.bluePring=(e=>{if(!e.memory.center)return;const t=e.memory.center,r=this.makePoint(t);this.vis.circle(t),this.vis.poly([r.topLeftA,r.topLeftB,r.topRightA,r.topRightB,r.bottomRightA,r.bottomRightB,r.bottomLeftA,r.bottomLeftB,r.topLeftA],this.shapeStyle),this.vis.poly([r.centerTop,r.centerRight,r.centerBottom,r.centerLeft,r.centerTop],_.assign(this.lineStyle,{opacity:.3})),this.vis.poly([r.centerLeft,r.centerLeftA,r.centerTopA,r.centerTop,r.centerTopB,r.centerRightA,r.centerRight,r.centerRightB,r.centerBottomB,r.centerBottom,r.centerBottomA,r.centerLeftB,r.centerLeft],_.assign(this.lineStyle,{opacity:.2})),this.vis.poly([r.topA,r.centerTopA,r.topB,r.topC,r.centerTopB,r.topD,r.topRightA,r.topRightB,r.rightA,r.centerRightA,r.rightB,r.rightC,r.centerRightB,r.rightD,r.bottomRightA,r.bottomRightB,r.bottomD,r.centerBottomB,r.bottomC,r.bottomB,r.centerBottomA,r.bottomA,r.bottomLeftA,r.bottomLeftB,r.leftD,r.centerLeftB,r.leftC,r.leftB,r.centerLeftA,r.leftA,r.topLeftA,r.topLeftB,r.topA],_.assign(this.lineStyle,{opacity:.1}))})}makePoint(e){const{x:t,y:r}=e;return{topLeft:[t-6,r-6],topRight:[t+6,r-6],bottomRight:[t+6,r+6],bottomLeft:[t-6,r+6],topLeftA:[t-6,r-5],topLeftB:[t-5,r-6],topRightA:[t+5,r-6],topRightB:[t+6,r-5],bottomRightA:[t+6,r+5],bottomRightB:[t+5,r+6],bottomLeftA:[t-5,r+6],bottomLeftB:[t-6,r+5],topA:[t-3,r-6],topB:[t-1,r-6],topC:[t+1,r-6],topD:[t+3,r-6],rightA:[t+6,r-3],rightB:[t+6,r-1],rightC:[t+6,r+1],rightD:[t+6,r+3],bottomA:[t-3,r+6],bottomB:[t-1,r+6],bottomC:[t+1,r+6],bottomD:[t+3,r+6],leftA:[t-6,r-3],leftB:[t-6,r-1],leftC:[t-6,r+1],leftD:[t-6,r+3],centerTop:[t,r-3],centerRight:[t+3,r],centerBottom:[t,r+3],centerLeft:[t-3,r],centerTopA:[t-2,r-5],centerTopB:[t+2,r-5],centerRightA:[t+5,r-2],centerRightB:[t+5,r+2],centerBottomA:[t-2,r+5],centerBottomB:[t+2,r+5],centerLeftA:[t-5,r-2],centerLeftB:[t-5,r+2]}}}},function(e,t){e.exports=require("commands")}]);