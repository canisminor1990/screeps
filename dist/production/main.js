module.exports=function(e){var t={};function r(o){if(t[o])return t[o].exports;var i=t[o]={i:o,l:!1,exports:{}};return e[o].call(i.exports,i,i.exports,r),i.l=!0,i.exports}return r.m=e,r.c=t,r.d=function(e,t,o){r.o(e,t)||Object.defineProperty(e,t,{configurable:!1,enumerable:!0,get:o})},r.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return r.d(t,"a",t),t},r.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},r.p="",r(r.s=9)}([function(e,t,r){"use strict";function o(e){for(var r in e)t.hasOwnProperty(r)||(t[r]=e[r])}Object.defineProperty(t,"__esModule",{value:!0}),o(r(8)),o(r(1)),o(r(57)),o(r(58)),o(r(59)),o(r(60)),o(r(61))},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});t.TaskComponent=class{constructor(e){this.register=(()=>{}),this.name=e}}},function(e,t,r){"use strict";t.getArg=function(e,t,r){if(t in e)return e[t];if(3===arguments.length)return r;throw new Error('"'+t+'" is a required argument.')};var o=/^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.-]*)(?::(\d+))?(.*)$/,i=/^data:.+\,.+$/;function a(e){var t=e.match(o);return t?{scheme:t[1],auth:t[2],host:t[3],port:t[4],path:t[5]}:null}function s(e){var t="";return e.scheme&&(t+=e.scheme+":"),t+="//",e.auth&&(t+=e.auth+"@"),e.host&&(t+=e.host),e.port&&(t+=":"+e.port),e.path&&(t+=e.path),t}function n(e){var r=e,o=a(e);if(o){if(!o.path)return e;r=o.path}for(var i,n=t.isAbsolute(r),l=r.split(/\/+/),m=0,c=l.length-1;c>=0;c--)"."===(i=l[c])?l.splice(c,1):".."===i?m++:m>0&&(""===i?(l.splice(c+1,m),m=0):(l.splice(c,2),m--));return""===(r=l.join("/"))&&(r=n?"/":"."),o?(o.path=r,s(o)):r}function l(e,t){""===e&&(e="."),""===t&&(t=".");var r=a(t),o=a(e);if(o&&(e=o.path||"/"),r&&!r.scheme)return o&&(r.scheme=o.scheme),s(r);if(r||t.match(i))return t;if(o&&!o.host&&!o.path)return o.host=t,s(o);var l="/"===t.charAt(0)?t:n(e.replace(/\/+$/,"")+"/"+t);return o?(o.path=l,s(o)):l}t.urlParse=a,t.urlGenerate=s,t.normalize=n,t.join=l,t.isAbsolute=function(e){return"/"===e.charAt(0)||o.test(e)},t.relative=function(e,t){""===e&&(e="."),e=e.replace(/\/$/,"");for(var r=0;0!==t.indexOf(e+"/");){var o=e.lastIndexOf("/");if(o<0)return t;if((e=e.slice(0,o)).match(/^([^\/]+:\/)?\/*$/))return t;++r}return Array(r+1).join("../")+t.substr(e.length+1)};var m=!("__proto__"in Object.create(null));function c(e){return e}function u(e){if(!e)return!1;var t=e.length;if(t<9)return!1;if(95!==e.charCodeAt(t-1)||95!==e.charCodeAt(t-2)||111!==e.charCodeAt(t-3)||116!==e.charCodeAt(t-4)||111!==e.charCodeAt(t-5)||114!==e.charCodeAt(t-6)||112!==e.charCodeAt(t-7)||95!==e.charCodeAt(t-8)||95!==e.charCodeAt(t-9))return!1;for(var r=t-10;r>=0;r--)if(36!==e.charCodeAt(r))return!1;return!0}function d(e,t){return e===t?0:null===e?1:null===t?-1:e>t?1:-1}t.toSetString=m?c:function(e){return u(e)?"$"+e:e},t.fromSetString=m?c:function(e){return u(e)?e.slice(1):e},t.compareByOriginalPositions=function(e,t,r){var o=d(e.source,t.source);return 0!==o?o:0!=(o=e.originalLine-t.originalLine)?o:0!=(o=e.originalColumn-t.originalColumn)||r?o:0!=(o=e.generatedColumn-t.generatedColumn)?o:0!=(o=e.generatedLine-t.generatedLine)?o:d(e.name,t.name)},t.compareByGeneratedPositionsDeflated=function(e,t,r){var o=e.generatedLine-t.generatedLine;return 0!==o?o:0!=(o=e.generatedColumn-t.generatedColumn)||r?o:0!==(o=d(e.source,t.source))?o:0!=(o=e.originalLine-t.originalLine)?o:0!=(o=e.originalColumn-t.originalColumn)?o:d(e.name,t.name)},t.compareByGeneratedPositionsInflated=function(e,t){var r=e.generatedLine-t.generatedLine;return 0!==r?r:0!=(r=e.generatedColumn-t.generatedColumn)?r:0!==(r=d(e.source,t.source))?r:0!=(r=e.originalLine-t.originalLine)?r:0!=(r=e.originalColumn-t.originalColumn)?r:d(e.name,t.name)},t.parseSourceMapInput=function(e){return JSON.parse(e.replace(/^\)]}'[^\n]*\n/,""))},t.computeSourceURL=function(e,t,r){if(t=t||"",e&&("/"!==e[e.length-1]&&"/"!==t[0]&&(e+="/"),t=e+t),r){var o=a(r);if(!o)throw new Error("sourceMapURL could not be parsed");if(o.path){var i=o.path.lastIndexOf("/");i>=0&&(o.path=o.path.substring(0,i+1))}t=l(s(o),t)}return n(t)}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(48),i=r(49),a=r(50),s=r(51),n={formatNumber(e){let t=Math.log10(e)/3;if(!e)return"0";let r=e.toString();return t<1?r:t<2?r.substring(0,r.length-3)+"k":t<3?r.substring(0,r.length-6)+"M":t<4?r.substring(0,r.length-9)+"B":e.toString()},pad:(e,t="0",r=2,o=!0)=>(o&&(r-=e.toString().length),_.times(r,()=>t).join("")+e),get(e,t,r,o=!0){const i=_.get(e,t);return _.isUndefined(i)&&!_.isUndefined(r)&&o?(r=Util.fieldOrFunction(r),_.set(e,t,r),_.get(e,t)):i},areEqual:(...e)=>e.length<=1||e.every((e,t,r)=>_.isEqual(e,r[0])),set(e,t,r,o=!0){o?Util.get(e,t,r):_.set(e,t,r)},callIfExists(e,...t){if(e)return e(...t)},fieldOrFunction:(e,...t)=>_.isFunction(e)?e(...t):e,addById(e,t){e||(e=[]);const r=Game.getObjectById(t);return r&&e.push(r),e},processReports(){if(!_.isUndefined(Memory.statistics)&&!_.isUndefined(Memory.statistics.reports)&&Memory.statistics.reports.length){let e;Memory.statistics.reports.length<=REPORTS_PER_LOOP?(e=Memory.statistics.reports,Memory.statistics.reports=[]):e=Memory.statistics.reports.splice(0,REPORTS_PER_LOOP),_.forEach(e,Game.notify)}},guid:()=>"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g,e=>{const t=16*Math.random()|0;return("x"===e?t:3&t|8).toString(16)}),inQueue:e=>!!e&&(e.link&&(e={behaviour:e}),!!(e.name||e.behaviour||e.setup)&&_(Game.rooms).filter("my").map("memory").map(e=>e.spawnQueueHigh.concat(e.spawnQueueMedium,e.spawnQueueLow)).flatten().some(t=>(!e.room||!t.destiny||t.destiny.room===e.room)&&(e.behaviour?t.behaviour&&t.behaviour===e.behaviour||t.name.includes(e.behaviour):e.setup?t.setup===e.setup:void 0))),memoryUsage(e){let t="",r=0,o="";for(const i in e){i.length>o.length&&(o=i);const a=JSON.stringify(e[i]).length/1024;r+=a,t+=`<tr><td>${i}</td><td>${_.round(a,2)}</td></tr>`}return t+=`<tr><td>Total</td><td>${_.round(r,2)}</td></tr></table>`,`<table><tr><th>Key${Array(o.length+2).join(" ")}</th><th>Size (kb)</th></tr>`.concat(t)},_resources:_.memoize(()=>_.chain(global).pick((e,t)=>t.startsWith("RESOURCE_")).value()),resources(){return this._resources()},valueOrZero:e=>e||0,chargeScale(e,t,r){if(r===t)return e>r?1/0:-1/0;return(e-r)*(1/(r-t))+1},resetBoostProduction(e){let t,r=_.filter(Game.rooms,{my:!0});for(let o of r)void 0!==e&&o.name!==e||(t=o.memory.resources,console.log(o.name),_.isUndefined(t)?console.log(`${o.name} has no memory.resources`):(t.offers=[],t.orders=[],t.terminal[0]&&(t.terminal[0].orders=[]),t.storage[0]&&(t.storage[0].orders=[]),t.reactions&&(t.reactions.orders=[]),t.lab&&(t.lab=[],_.values(Game.structures).filter(e=>"lab"===e.structureType).map(e=>e.room.setStore(e.id,RESOURCE_ENERGY,2e3))),delete t.boostTiming));void 0===e&&delete Memory.boostTiming}};t.default=_.assign(n,a.roomUtils,i.logUtils,o.dateUtils,s.marketUtils),t.Install=function(e,t,r=!1){_.isString(e)?(global[e]=t,r&&_.assign(global[e],r)):(_.assign(e,t),r&&_.assign(e,r))},t.getUsername=_(Game.rooms).map("controller").filter("my").map("owner.username").first()},function(e,t,r){"use strict";var o=r(5),i=r(2),a=r(6).ArraySet,s=r(17).MappingList;function n(e){e||(e={}),this._file=i.getArg(e,"file",null),this._sourceRoot=i.getArg(e,"sourceRoot",null),this._skipValidation=i.getArg(e,"skipValidation",!1),this._sources=new a,this._names=new a,this._mappings=new s,this._sourcesContents=null}n.prototype._version=3,n.fromSourceMap=function(e){var t=e.sourceRoot,r=new n({file:e.file,sourceRoot:t});return e.eachMapping(function(e){var o={generated:{line:e.generatedLine,column:e.generatedColumn}};null!=e.source&&(o.source=e.source,null!=t&&(o.source=i.relative(t,o.source)),o.original={line:e.originalLine,column:e.originalColumn},null!=e.name&&(o.name=e.name)),r.addMapping(o)}),e.sources.forEach(function(o){var a=o;null!==t&&(a=i.relative(t,o)),r._sources.has(a)||r._sources.add(a);var s=e.sourceContentFor(o);null!=s&&r.setSourceContent(o,s)}),r},n.prototype.addMapping=function(e){var t=i.getArg(e,"generated"),r=i.getArg(e,"original",null),o=i.getArg(e,"source",null),a=i.getArg(e,"name",null);this._skipValidation||this._validateMapping(t,r,o,a),null!=o&&(o=String(o),this._sources.has(o)||this._sources.add(o)),null!=a&&(a=String(a),this._names.has(a)||this._names.add(a)),this._mappings.add({generatedLine:t.line,generatedColumn:t.column,originalLine:null!=r&&r.line,originalColumn:null!=r&&r.column,source:o,name:a})},n.prototype.setSourceContent=function(e,t){var r=e;null!=this._sourceRoot&&(r=i.relative(this._sourceRoot,r)),null!=t?(this._sourcesContents||(this._sourcesContents=Object.create(null)),this._sourcesContents[i.toSetString(r)]=t):this._sourcesContents&&(delete this._sourcesContents[i.toSetString(r)],0===Object.keys(this._sourcesContents).length&&(this._sourcesContents=null))},n.prototype.applySourceMap=function(e,t,r){var o=t;if(null==t){if(null==e.file)throw new Error('SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, or the source map\'s "file" property. Both were omitted.');o=e.file}var s=this._sourceRoot;null!=s&&(o=i.relative(s,o));var n=new a,l=new a;this._mappings.unsortedForEach(function(t){if(t.source===o&&null!=t.originalLine){var a=e.originalPositionFor({line:t.originalLine,column:t.originalColumn});null!=a.source&&(t.source=a.source,null!=r&&(t.source=i.join(r,t.source)),null!=s&&(t.source=i.relative(s,t.source)),t.originalLine=a.line,t.originalColumn=a.column,null!=a.name&&(t.name=a.name))}var m=t.source;null==m||n.has(m)||n.add(m);var c=t.name;null==c||l.has(c)||l.add(c)},this),this._sources=n,this._names=l,e.sources.forEach(function(t){var o=e.sourceContentFor(t);null!=o&&(null!=r&&(t=i.join(r,t)),null!=s&&(t=i.relative(s,t)),this.setSourceContent(t,o))},this)},n.prototype._validateMapping=function(e,t,r,o){if(t&&"number"!=typeof t.line&&"number"!=typeof t.column)throw new Error("original.line and original.column are not numbers -- you probably meant to omit the original mapping entirely and only map the generated position. If so, pass null for the original mapping instead of an object with empty or null values.");if((!(e&&"line"in e&&"column"in e&&e.line>0&&e.column>=0)||t||r||o)&&!(e&&"line"in e&&"column"in e&&t&&"line"in t&&"column"in t&&e.line>0&&e.column>=0&&t.line>0&&t.column>=0&&r))throw new Error("Invalid mapping: "+JSON.stringify({generated:e,source:r,original:t,name:o}))},n.prototype._serializeMappings=function(){for(var e,t,r,a,s=0,n=1,l=0,m=0,c=0,u=0,d="",h=this._mappings.toArray(),g=0,p=h.length;g<p;g++){if(e="",(t=h[g]).generatedLine!==n)for(s=0;t.generatedLine!==n;)e+=";",n++;else if(g>0){if(!i.compareByGeneratedPositionsInflated(t,h[g-1]))continue;e+=","}e+=o.encode(t.generatedColumn-s),s=t.generatedColumn,null!=t.source&&(a=this._sources.indexOf(t.source),e+=o.encode(a-u),u=a,e+=o.encode(t.originalLine-1-m),m=t.originalLine-1,e+=o.encode(t.originalColumn-l),l=t.originalColumn,null!=t.name&&(r=this._names.indexOf(t.name),e+=o.encode(r-c),c=r)),d+=e}return d},n.prototype._generateSourcesContent=function(e,t){return e.map(function(e){if(!this._sourcesContents)return null;null!=t&&(e=i.relative(t,e));var r=i.toSetString(e);return Object.prototype.hasOwnProperty.call(this._sourcesContents,r)?this._sourcesContents[r]:null},this)},n.prototype.toJSON=function(){var e={version:this._version,sources:this._sources.toArray(),names:this._names.toArray(),mappings:this._serializeMappings()};return null!=this._file&&(e.file=this._file),null!=this._sourceRoot&&(e.sourceRoot=this._sourceRoot),this._sourcesContents&&(e.sourcesContent=this._generateSourcesContent(e.sources,e.sourceRoot)),e},n.prototype.toString=function(){return JSON.stringify(this.toJSON())},t.SourceMapGenerator=n},function(e,t,r){"use strict";var o=r(16);t.encode=function(e){var t,r="",i=function(e){return e<0?1+(-e<<1):0+(e<<1)}(e);do{t=31&i,(i>>>=5)>0&&(t|=32),r+=o.encode(t)}while(i>0);return r},t.decode=function(e,t,r){var i,a,s,n,l=e.length,m=0,c=0;do{if(t>=l)throw new Error("Expected more digits in base 64 VLQ value.");if(-1===(a=o.decode(e.charCodeAt(t++))))throw new Error("Invalid base64 digit: "+e.charAt(t-1));i=!!(32&a),m+=(a&=31)<<c,c+=5}while(i);r.value=(n=(s=m)>>1,1==(1&s)?-n:n),r.rest=t}},function(e,t,r){"use strict";var o=r(2),i=Object.prototype.hasOwnProperty,a="undefined"!=typeof Map;function s(){this._array=[],this._set=a?new Map:Object.create(null)}s.fromArray=function(e,t){for(var r=new s,o=0,i=e.length;o<i;o++)r.add(e[o],t);return r},s.prototype.size=function(){return a?this._set.size:Object.getOwnPropertyNames(this._set).length},s.prototype.add=function(e,t){var r=a?e:o.toSetString(e),s=a?this.has(e):i.call(this._set,r),n=this._array.length;s&&!t||this._array.push(e),s||(a?this._set.set(e,n):this._set[r]=n)},s.prototype.has=function(e){if(a)return this._set.has(e);var t=o.toSetString(e);return i.call(this._set,t)},s.prototype.indexOf=function(e){if(a){var t=this._set.get(e);if(t>=0)return t}else{var r=o.toSetString(e);if(i.call(this._set,r))return this._set[r]}throw new Error('"'+e+'" is not in the set.')},s.prototype.at=function(e){if(e>=0&&e<this._array.length)return this._array[e];throw new Error("No element indexed by "+e)},s.prototype.toArray=function(){return this._array.slice()},t.ArraySet=s},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.Strategy={decorateAgent(e,...r){e.customStrategy||(e.customStrategy=function(e){}),e.staticCustomStrategy||(e.staticCustomStrategy=function(e){}),e.getStrategyHandler=function(e,t,...r){const o=this.currentStrategy||this.strategy(e),i=o[t],a=o.key,s=o.name;if(DEBUG&&TRACE&&Util.trace("Strategy",{agent:this.name,strategyKey:a,strategyName:s,method:t}),void 0===i)return void Util.logError("strategy handler returned undefined",{agent:this.name||this.id,strategyKey:a,strategyName:s,method:t,stack:(new Error).stack});if(0===r.length)return i;const n=i.apply(this.currentStrategy,r);if(void 0!==n)return n;Util.logError("handler returned undefined for args",{agent:this.name||this.id,strategyKey:a,strategyName:s,method:t,args:r.toString(),stack:(new Error).stack})},e._strategyCache={},e.strategyKey=function(e){const t=[];for(let o=r.length-1;o>=0;o--)e[o]?t[o]=e[o]:t[o]=r[o].default(this);return t},e.selectClient=function(e,t){return e[t]&&r[t].select(e[t])},e.strategy=function(e){const o=this.strategyKey(e);let i=t.Strategy.getCachedStrategy(this,o);return i?t.Strategy.customizeStrategy(this,o,i):(i=t.Strategy.buildStrategy(o,t.Strategy.strategyChainUtils,r,this.staticCustomStrategy.apply(this,o)))?(t.Strategy.putCachedStrategy(this,o,i),t.Strategy.customizeStrategy(this,o,i)):(Util.logError("no strategy",{agent:this.name||this.id,key:o}),{})},e.explain=function(){const e=this.strategyKey([]);let t=this.toString()+": ";this.explainAgent&&(t+=this.explainAgent()+" "),t+=`assigned:[${e}]`;for(let r=0;r<e.length;r++){const o=this.selectClient(r);o&&o.explain&&(t+=`\n\t${e[r]}: ${o.explain(this)}`)}return t}},allocateStrategy(e,...t){e.currentStrategy=e.strategy.apply(e,t)},freeStrategy(e){t.Strategy.freeStrategyChain(e.currentStrategy),delete e.currentStrategy},buildStrategy(e,r,o,i){const a={key:e,name:[]};let s;t.Strategy.appendstate(a,void 0,[r]);for(let r=0;r<o.length;r++){const i=e[r],n=i&&o[r].selector(i),l=n&&n.selectstate&&n.selectstate.apply(n,e);s=t.Strategy.appendstate(a,s,l)}if(i&&(s=t.Strategy.appendstate(a,s,[i])),s)return a},appendstate(e,t,r){if(!r)return t;for(let o=0;o<r.length;o++){const i=r[o];i&&(t=i,_.assign(e,i,(e,t,r)=>"name"===r?(e.push(t),e):t))}return t},freeStrategyChain(e){},customizeStrategy(e,t,r){const o=e.customStrategy.apply(e,t);return o?_.assign({},r,o,(e,t,r)=>"name"===r?Array.isArray(t)?t.slice(0):(e.push(t),e):t):r},strategyChainUtils:{toString(){const e=this.name.toString();return t.Strategy.freeStrategy(this),e},[Symbol.toPrimitive](){return this.toString()}},getCachedStrategy:(e,t)=>_.get(e._strategyCache,t),putCachedStrategy(e,t,r){Object.freeze(r),_.set(e._strategyCache,t,r)}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});t.Component=class{constructor(){this.extend=(()=>{}),this.fresh=(()=>{}),this.analyze=(()=>{}),this.register=(()=>{}),this.run=(()=>{}),this.cleanup=(()=>{})}}},function(e,t,r){r(10),e.exports=r(12)},function(e,t,r){"use strict";(function(e){var t="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e};!function(r){var o,i=Object.prototype,a=i.hasOwnProperty,s="function"==typeof Symbol?Symbol:{},n=s.iterator||"@@iterator",l=s.toStringTag||"@@toStringTag",m="@@gen",c="object"===t(e),u=r.regeneratorRuntime;if(u)c&&(e.exports=u);else{var d={};(u=r.regeneratorRuntime=c?e.exports:{}).wrap=C;var h="s",g="y",p="x",f="c",y={},R={};R[n]=function(){return this};var _=Object.getPrototypeOf,E=_&&_(_(L([])));E&&E!==i&&a.call(E,n)&&(R=E);var T=U.prototype=A.prototype=Object.create(R);S.prototype=T.constructor=U,U.constructor=S,U[l]=S.displayName="GeneratorFunction",u.isGeneratorFunction=function(e){var t="function"==typeof e&&e.constructor;return!!t&&(t===S||"GeneratorFunction"===(t.displayName||t.name))},u.mark=function(e,t){return Object.setPrototypeOf?Object.setPrototypeOf(e,U):(e.__proto__=U,l in e||(e[l]="GeneratorFunction")),e.prototype=Object.create(T),e[m]=t,d[t]=e,e},u.awrap=function(e){return{__await:e}},N(v.prototype),u.AsyncIterator=v,u.async=function(e,t,r,o){var i=new v(C(e,t,r,o));return u.isGeneratorFunction(t)?i:i.next().then(function(e){return e.done?e.value:i.next()})},N(T),T[l]="Generator",T.toString=function(){return"[object Generator]"},u.keys=function(e){var t=[];for(var r in e)t.push(r);return t.reverse(),function r(){for(;t.length;){var o=t.pop();if(o in e)return r.value=o,r.done=!1,r}return r.done=!0,r}},u.values=L,M.prototype={constructor:M,stop:function(){this.done=!0;var e=this.tryEntries[0].completion;if("throw"===e.type)throw e.arg;return this.rval},dispatchException:function(e){if(this.done)throw e;var t=this;function r(r,o){return s.type="throw",s.arg=e,t.next=r,!!o}for(var o=this.tryEntries.length-1;o>=0;--o){var i=this.tryEntries[o],s=i.completion;if("root"===i.tryLoc)return r("end");if(i.tryLoc<=this.prev){var n=a.call(i,"catchLoc"),l=a.call(i,"finallyLoc");if(n&&l){if(this.prev<i.catchLoc)return r(i.catchLoc,!0);if(this.prev<i.finallyLoc)return r(i.finallyLoc)}else if(n){if(this.prev<i.catchLoc)return r(i.catchLoc,!0)}else{if(!l)throw new Error("try statement without catch or finally");if(this.prev<i.finallyLoc)return r(i.finallyLoc)}}}},abrupt:function(e,t){for(var r=this.tryEntries.length-1;r>=0;--r){var o=this.tryEntries[r];if(o.tryLoc<=this.prev&&a.call(o,"finallyLoc")&&this.prev<o.finallyLoc){var i=o;break}}i&&("break"===e||"continue"===e)&&i.tryLoc<=t&&t<=i.finallyLoc&&(i=null);var s=i?i.completion:{};return s.type=e,s.arg=t,i?this.next=i.finallyLoc:this.complete(s),y},complete:function(e,t){if("throw"===e.type)throw e.arg;"break"===e.type||"continue"===e.type?this.next=e.arg:"return"===e.type?(this.rval=e.arg,this.next="end"):"normal"===e.type&&t&&(this.next=t)},finish:function(e){for(var t=this.tryEntries.length-1;t>=0;--t){var r=this.tryEntries[t];if(r.finallyLoc===e)return this.complete(r.completion,r.afterLoc),w(r),y}},catch:function(e){for(var t=this.tryEntries.length-1;t>=0;--t){var r=this.tryEntries[t];if(r.tryLoc===e){var o=r.completion;if("throw"===o.type){var i=o.arg;w(r)}return i}}throw new Error("illegal catch attempt")},delegateYield:function(e,t,r){return this.delegate={iterator:L(e),resultName:t,nextLoc:r},y}},u.serializeGenerator=function(e){if(Object.getPrototypeOf(Object.getPrototypeOf(e))!==A.prototype)throw new Error("Cannot serialize subclass of Generator");var t=e._context,r=Object.assign(Object.create(null),t);return t.delegate&&(r.delegate={i:t.delegate.iterator,r:t.delegate.resultName,n:t.delegate.nextLoc}),r.self=r.self,r.locals=r.locals,delete r.genHash,r[m]=t.genFun[m],r},u.deserializeGenerator=function(e){var t=d[e[m]];if(!t)throw new Error("Invalid generator hash");var r=t.call(null),o=r._context=Object.assign(Object.create(M.prototype),e);return o.delegate&&(o.delegate={iterator:L(o.delegate.i),resultName:o.delegate.r,nextLoc:o.delegate.n}),o.self=o.self,o.locals=o.locals,o.genFun=t,delete o[m],r}}function C(e,t,i,a,s,n,l){if(!t[m])throw new Error("Generator was not marked");var c=t&&t.prototype instanceof A?t:A,u=Object.create(c.prototype),d={};a&&(d[a]=Array.prototype.slice.call(n,0),Object.defineProperty(d[a],"callee",{value:t,enumerable:!1})),i.forEach(function(e,t){d[e]=n[t]});var R=new M(t,s===r?null:s,d,l||[]);return u._context=R,u._invoke=function(e){return function(t,r){if(this._context.state===p)throw new Error("Generator is already running");if(this._context.state===f){if("throw"===t)throw r;return k()}for(;;){var i=this._context.delegate;if(i){if("return"===t||"throw"===t&&i.iterator[t]===o){this._context.delegate=null;var a=i.iterator.return;if(a){var s=O(a,i.iterator,r);if("throw"===s.type){t="throw",r=s.arg;continue}}if("return"===t)continue}var s=O(i.iterator[t],i.iterator,r);if("throw"===s.type){this._context.delegate=null,t="throw",r=s.arg;continue}t="next",r=o;var n=s.arg;if(!n.done)return this._context.state=g,n;this._context[i.resultName]=n.value,this._context.next=i.nextLoc,this._context.delegate=null}if("next"===t)this._context.sent=this._context._sent=r;else if("throw"===t){if(this._context.state===h)throw this._context.state=f,r;this._context.dispatchException(r)&&(t="next",r=o)}else"return"===t&&this._context.abrupt("return",r);this._context.state=p;var s=O(e,this._context.self,this._context.locals,this._context);if("normal"===s.type){this._context.state=this._context.done?f:g;var n={value:s.arg,done:this._context.done};if(s.arg!==y)return n;this._context.delegate&&"next"===t&&(r=o)}else"throw"===s.type&&(this._context.state=f,t="throw",r=s.arg)}}}(e),u}function O(e,t,r,o){try{return{type:"normal",arg:e.call(t,r,o)}}catch(e){return{type:"throw",arg:e}}}function A(){}function S(){}function U(){}function N(e){["next","throw","return"].forEach(function(t){e[t]=function(e){return this._invoke(t,e)}})}function v(e){function r(o,i,s,n){var l=O(e[o],e,i);if("throw"!==l.type){var m=l.arg,c=m.value;return c&&"object"===(void 0===c?"undefined":t(c))&&a.call(c,"__await")?Promise.resolve(c.__await).then(function(e){r("next",e,s,n)},function(e){r("throw",e,s,n)}):Promise.resolve(c).then(function(e){m.value=e,s(m)},n)}n(l.arg)}var o;"object"===("undefined"==typeof process?"undefined":t(process))&&process.domain&&(r=process.domain.bind(r)),this._invoke=function(e,t){function i(){return new Promise(function(o,i){r(e,t,o,i)})}return o=o?o.then(i,i):i()}}function b(e){var t={tryLoc:e[0]};1 in e&&(t.catchLoc=e[1]),2 in e&&(t.finallyLoc=e[2],t.afterLoc=e[3]),this.tryEntries.push(t)}function w(e){var t=e.completion||{};t.type="normal",delete t.arg,e.completion=t}function M(e,t,r,i){this.genFun=e,this.self=t,this.locals=r,this.tryEntries=[{tryLoc:"root"}],i.forEach(b,this),this.prev=0,this.next=0,this.sent=this._sent=o,this.done=!1,this.delegate=null,this.state=h,this.tryEntries.forEach(w)}function L(e){if(e){var t=e[n];if(t)return t.call(e);if("function"==typeof e.next)return e;if(!isNaN(e.length)){var r=-1,i=function t(){for(;++r<e.length;)if(a.call(e,r))return t.value=e[r],t.done=!1,t;return t.value=o,t.done=!0,t};return i.next=i}}return{next:k}}function k(){return{value:o,done:!0}}}("object"===("undefined"==typeof global?"undefined":t(global))?global:"object"===("undefined"==typeof window?"undefined":t(window))?window:"object"===("undefined"==typeof self?"undefined":t(self))?self:void 0)}).call(t,r(11)(e))},function(e,t,r){"use strict";e.exports=function(e){return e.webpackPolyfill||(e.deprecate=function(){},e.paths=[],e.children||(e.children=[]),Object.defineProperty(e,"loaded",{enumerable:!0,get:function(){return e.l}}),Object.defineProperty(e,"id",{enumerable:!0,get:function(){return e.i}}),e.webpackPolyfill=1),e}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.loop=void 0;var o,i=r(13),a=(o=i)&&o.__esModule?o:{default:o};var s=[[n,"356a74ae3af56beb5532a5f9922c7070"]].map(function(e){return regeneratorRuntime.mark(e[0],e[1])});function n(){return regeneratorRuntime.wrap(function(e,t){for(;;)switch(t.prev=t.next){case 0:console.log(),console.log("* * * * * * * * * * * * * * * * * * * * *"),console.log("* * * * * * * Code Update ! * * * * * * *"),console.log("* * * * * * * * * * * * * * * * * * * * *"),console.log();case 5:return(0,a.default)(),t.next=9,null;case 9:t.next=5;break;case 11:case"end":return t.stop()}},s[0],[],null,this,arguments)}t.loop=function(){if(0!==Object.keys(Game.rooms).length){var e=void 0;try{if(Memory.thread)try{e=regeneratorRuntime.deserializeGenerator(Memory.thread)}finally{delete Memory.thread}else e=n();e.next().done||(Memory.thread=regeneratorRuntime.serializeGenerator(e))}catch(e){console.log("Code Changing at "+Game.time+" ...")}}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});r(14);const o=r(23),i=Game.cpu.getUsed();let a;const s=()=>{const e=Game.cpu.getUsed();Memory.pause||(_.isUndefined(global.isRoot)&&o.default.install(),a||(a=e),o.default.loop(),Game.cacheTime=Game.time,DEBUG&&TRACE&&Util.trace("main",{cpuAtLoad:i,cpuAtFirstLoop:a,cpuAtLoop:e,cpuTick:Game.cpu.getUsed(),isNewServer:global.isNewServer,lastServerSwitch:Game.lastServerSwitch,main:"cpu"}))};t.default=s},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(15);class i{static get consumer(){return null==this._consumer&&(this._consumer=new o.SourceMapConsumer(r(22))),this._consumer}static sourceMappedStackTrace(e){const t=e instanceof Error?e.stack:e;if(this.cache.hasOwnProperty(t))return this.cache[t];const r=/^\s+at\s+(.+?\s+)?\(?([0-z._\-\\/]+):(\d+):(\d+)\)?$/gm;let o,i=e.toString();for(;(o=r.exec(t))&&"main"===o[2];){const e=this.consumer.originalPositionFor({column:parseInt(o[4],10),line:parseInt(o[3],10)});if(null==e.line)break;e.name?i+=`\n    at ${e.name} (${e.source}:${e.line}:${e.column})`:o[1]?i+=`\n    at ${o[1]} (${e.source}:${e.line}:${e.column})`:i+=`\n    at ${e.source}:${e.line}:${e.column}`}return this.cache[t]=i,i}static wrapLoop(e){return()=>{try{e()}catch(e){if(!(e instanceof Error))throw e;if("sim"in Game.rooms){const t="Source maps don't work in the simulator - displaying original error";console.log(`<span style='color:red'>${t}<br>${_.escape(e.stack)}</span>`)}else console.log(`<span style='color:red'>${_.escape(this.sourceMappedStackTrace(e))}</span>`)}}}}i.cache={},t.ErrorMapper=i},function(e,t,r){"use strict";t.SourceMapGenerator=r(4).SourceMapGenerator,t.SourceMapConsumer=r(18).SourceMapConsumer,t.SourceNode=r(21).SourceNode},function(e,t,r){"use strict";var o="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split("");t.encode=function(e){if(0<=e&&e<o.length)return o[e];throw new TypeError("Must be between 0 and 63: "+e)},t.decode=function(e){return 65<=e&&e<=90?e-65:97<=e&&e<=122?e-97+26:48<=e&&e<=57?e-48+52:43==e?62:47==e?63:-1}},function(e,t,r){"use strict";var o=r(2);function i(){this._array=[],this._sorted=!0,this._last={generatedLine:-1,generatedColumn:0}}i.prototype.unsortedForEach=function(e,t){this._array.forEach(e,t)},i.prototype.add=function(e){var t,r,i,a,s,n;t=this._last,r=e,i=t.generatedLine,a=r.generatedLine,s=t.generatedColumn,n=r.generatedColumn,a>i||a==i&&n>=s||o.compareByGeneratedPositionsInflated(t,r)<=0?(this._last=e,this._array.push(e)):(this._sorted=!1,this._array.push(e))},i.prototype.toArray=function(){return this._sorted||(this._array.sort(o.compareByGeneratedPositionsInflated),this._sorted=!0),this._array},t.MappingList=i},function(e,t,r){"use strict";var o=r(2),i=r(19),a=r(6).ArraySet,s=r(5),n=r(20).quickSort;function l(e,t){var r=e;return"string"==typeof e&&(r=o.parseSourceMapInput(e)),null!=r.sections?new u(r,t):new m(r,t)}function m(e,t){var r=e;"string"==typeof e&&(r=o.parseSourceMapInput(e));var i=o.getArg(r,"version"),s=o.getArg(r,"sources"),n=o.getArg(r,"names",[]),l=o.getArg(r,"sourceRoot",null),m=o.getArg(r,"sourcesContent",null),c=o.getArg(r,"mappings"),u=o.getArg(r,"file",null);if(i!=this._version)throw new Error("Unsupported version: "+i);l&&(l=o.normalize(l)),s=s.map(String).map(o.normalize).map(function(e){return l&&o.isAbsolute(l)&&o.isAbsolute(e)?o.relative(l,e):e}),this._names=a.fromArray(n.map(String),!0),this._sources=a.fromArray(s,!0),this._absoluteSources=this._sources.toArray().map(function(e){return o.computeSourceURL(l,e,t)}),this.sourceRoot=l,this.sourcesContent=m,this._mappings=c,this._sourceMapURL=t,this.file=u}function c(){this.generatedLine=0,this.generatedColumn=0,this.source=null,this.originalLine=null,this.originalColumn=null,this.name=null}function u(e,t){var r=e;"string"==typeof e&&(r=o.parseSourceMapInput(e));var i=o.getArg(r,"version"),s=o.getArg(r,"sections");if(i!=this._version)throw new Error("Unsupported version: "+i);this._sources=new a,this._names=new a;var n={line:-1,column:0};this._sections=s.map(function(e){if(e.url)throw new Error("Support for url field in sections not implemented.");var r=o.getArg(e,"offset"),i=o.getArg(r,"line"),a=o.getArg(r,"column");if(i<n.line||i===n.line&&a<n.column)throw new Error("Section offsets must be ordered and non-overlapping.");return n=r,{generatedOffset:{generatedLine:i+1,generatedColumn:a+1},consumer:new l(o.getArg(e,"map"),t)}})}l.fromSourceMap=function(e,t){return m.fromSourceMap(e,t)},l.prototype._version=3,l.prototype.__generatedMappings=null,Object.defineProperty(l.prototype,"_generatedMappings",{configurable:!0,enumerable:!0,get:function(){return this.__generatedMappings||this._parseMappings(this._mappings,this.sourceRoot),this.__generatedMappings}}),l.prototype.__originalMappings=null,Object.defineProperty(l.prototype,"_originalMappings",{configurable:!0,enumerable:!0,get:function(){return this.__originalMappings||this._parseMappings(this._mappings,this.sourceRoot),this.__originalMappings}}),l.prototype._charIsMappingSeparator=function(e,t){var r=e.charAt(t);return";"===r||","===r},l.prototype._parseMappings=function(e,t){throw new Error("Subclasses must implement _parseMappings")},l.GENERATED_ORDER=1,l.ORIGINAL_ORDER=2,l.GREATEST_LOWER_BOUND=1,l.LEAST_UPPER_BOUND=2,l.prototype.eachMapping=function(e,t,r){var i,a=t||null;switch(r||l.GENERATED_ORDER){case l.GENERATED_ORDER:i=this._generatedMappings;break;case l.ORIGINAL_ORDER:i=this._originalMappings;break;default:throw new Error("Unknown order of iteration.")}var s=this.sourceRoot;i.map(function(e){var t=null===e.source?null:this._sources.at(e.source);return{source:t=o.computeSourceURL(s,t,this._sourceMapURL),generatedLine:e.generatedLine,generatedColumn:e.generatedColumn,originalLine:e.originalLine,originalColumn:e.originalColumn,name:null===e.name?null:this._names.at(e.name)}},this).forEach(e,a)},l.prototype.allGeneratedPositionsFor=function(e){var t=o.getArg(e,"line"),r={source:o.getArg(e,"source"),originalLine:t,originalColumn:o.getArg(e,"column",0)};if(r.source=this._findSourceIndex(r.source),r.source<0)return[];var a=[],s=this._findMapping(r,this._originalMappings,"originalLine","originalColumn",o.compareByOriginalPositions,i.LEAST_UPPER_BOUND);if(s>=0){var n=this._originalMappings[s];if(void 0===e.column)for(var l=n.originalLine;n&&n.originalLine===l;)a.push({line:o.getArg(n,"generatedLine",null),column:o.getArg(n,"generatedColumn",null),lastColumn:o.getArg(n,"lastGeneratedColumn",null)}),n=this._originalMappings[++s];else for(var m=n.originalColumn;n&&n.originalLine===t&&n.originalColumn==m;)a.push({line:o.getArg(n,"generatedLine",null),column:o.getArg(n,"generatedColumn",null),lastColumn:o.getArg(n,"lastGeneratedColumn",null)}),n=this._originalMappings[++s]}return a},t.SourceMapConsumer=l,m.prototype=Object.create(l.prototype),m.prototype.consumer=l,m.prototype._findSourceIndex=function(e){var t,r=e;if(null!=this.sourceRoot&&(r=o.relative(this.sourceRoot,r)),this._sources.has(r))return this._sources.indexOf(r);for(t=0;t<this._absoluteSources.length;++t)if(this._absoluteSources[t]==e)return t;return-1},m.fromSourceMap=function(e,t){var r=Object.create(m.prototype),i=r._names=a.fromArray(e._names.toArray(),!0),s=r._sources=a.fromArray(e._sources.toArray(),!0);r.sourceRoot=e._sourceRoot,r.sourcesContent=e._generateSourcesContent(r._sources.toArray(),r.sourceRoot),r.file=e._file,r._sourceMapURL=t,r._absoluteSources=r._sources.toArray().map(function(e){return o.computeSourceURL(r.sourceRoot,e,t)});for(var l=e._mappings.toArray().slice(),u=r.__generatedMappings=[],d=r.__originalMappings=[],h=0,g=l.length;h<g;h++){var p=l[h],f=new c;f.generatedLine=p.generatedLine,f.generatedColumn=p.generatedColumn,p.source&&(f.source=s.indexOf(p.source),f.originalLine=p.originalLine,f.originalColumn=p.originalColumn,p.name&&(f.name=i.indexOf(p.name)),d.push(f)),u.push(f)}return n(r.__originalMappings,o.compareByOriginalPositions),r},m.prototype._version=3,Object.defineProperty(m.prototype,"sources",{get:function(){return this._absoluteSources.slice()}}),m.prototype._parseMappings=function(e,t){for(var r,i,a,l,m,u=1,d=0,h=0,g=0,p=0,f=0,y=e.length,R=0,_={},E={},T=[],C=[];R<y;)if(";"===e.charAt(R))u++,R++,d=0;else if(","===e.charAt(R))R++;else{for((r=new c).generatedLine=u,l=R;l<y&&!this._charIsMappingSeparator(e,l);l++);if(a=_[i=e.slice(R,l)])R+=i.length;else{for(a=[];R<l;)s.decode(e,R,E),m=E.value,R=E.rest,a.push(m);if(2===a.length)throw new Error("Found a source, but no line and column");if(3===a.length)throw new Error("Found a source and line, but no column");_[i]=a}r.generatedColumn=d+a[0],d=r.generatedColumn,a.length>1&&(r.source=p+a[1],p+=a[1],r.originalLine=h+a[2],h=r.originalLine,r.originalLine+=1,r.originalColumn=g+a[3],g=r.originalColumn,a.length>4&&(r.name=f+a[4],f+=a[4])),C.push(r),"number"==typeof r.originalLine&&T.push(r)}n(C,o.compareByGeneratedPositionsDeflated),this.__generatedMappings=C,n(T,o.compareByOriginalPositions),this.__originalMappings=T},m.prototype._findMapping=function(e,t,r,o,a,s){if(e[r]<=0)throw new TypeError("Line must be greater than or equal to 1, got "+e[r]);if(e[o]<0)throw new TypeError("Column must be greater than or equal to 0, got "+e[o]);return i.search(e,t,a,s)},m.prototype.computeColumnSpans=function(){for(var e=0;e<this._generatedMappings.length;++e){var t=this._generatedMappings[e];if(e+1<this._generatedMappings.length){var r=this._generatedMappings[e+1];if(t.generatedLine===r.generatedLine){t.lastGeneratedColumn=r.generatedColumn-1;continue}}t.lastGeneratedColumn=1/0}},m.prototype.originalPositionFor=function(e){var t={generatedLine:o.getArg(e,"line"),generatedColumn:o.getArg(e,"column")},r=this._findMapping(t,this._generatedMappings,"generatedLine","generatedColumn",o.compareByGeneratedPositionsDeflated,o.getArg(e,"bias",l.GREATEST_LOWER_BOUND));if(r>=0){var i=this._generatedMappings[r];if(i.generatedLine===t.generatedLine){var a=o.getArg(i,"source",null);null!==a&&(a=this._sources.at(a),a=o.computeSourceURL(this.sourceRoot,a,this._sourceMapURL));var s=o.getArg(i,"name",null);return null!==s&&(s=this._names.at(s)),{source:a,line:o.getArg(i,"originalLine",null),column:o.getArg(i,"originalColumn",null),name:s}}}return{source:null,line:null,column:null,name:null}},m.prototype.hasContentsOfAllSources=function(){return!!this.sourcesContent&&(this.sourcesContent.length>=this._sources.size()&&!this.sourcesContent.some(function(e){return null==e}))},m.prototype.sourceContentFor=function(e,t){if(!this.sourcesContent)return null;var r=this._findSourceIndex(e);if(r>=0)return this.sourcesContent[r];var i,a=e;if(null!=this.sourceRoot&&(a=o.relative(this.sourceRoot,a)),null!=this.sourceRoot&&(i=o.urlParse(this.sourceRoot))){var s=a.replace(/^file:\/\//,"");if("file"==i.scheme&&this._sources.has(s))return this.sourcesContent[this._sources.indexOf(s)];if((!i.path||"/"==i.path)&&this._sources.has("/"+a))return this.sourcesContent[this._sources.indexOf("/"+a)]}if(t)return null;throw new Error('"'+a+'" is not in the SourceMap.')},m.prototype.generatedPositionFor=function(e){var t=o.getArg(e,"source");if((t=this._findSourceIndex(t))<0)return{line:null,column:null,lastColumn:null};var r={source:t,originalLine:o.getArg(e,"line"),originalColumn:o.getArg(e,"column")},i=this._findMapping(r,this._originalMappings,"originalLine","originalColumn",o.compareByOriginalPositions,o.getArg(e,"bias",l.GREATEST_LOWER_BOUND));if(i>=0){var a=this._originalMappings[i];if(a.source===r.source)return{line:o.getArg(a,"generatedLine",null),column:o.getArg(a,"generatedColumn",null),lastColumn:o.getArg(a,"lastGeneratedColumn",null)}}return{line:null,column:null,lastColumn:null}},t.BasicSourceMapConsumer=m,u.prototype=Object.create(l.prototype),u.prototype.constructor=l,u.prototype._version=3,Object.defineProperty(u.prototype,"sources",{get:function(){for(var e=[],t=0;t<this._sections.length;t++)for(var r=0;r<this._sections[t].consumer.sources.length;r++)e.push(this._sections[t].consumer.sources[r]);return e}}),u.prototype.originalPositionFor=function(e){var t={generatedLine:o.getArg(e,"line"),generatedColumn:o.getArg(e,"column")},r=i.search(t,this._sections,function(e,t){var r=e.generatedLine-t.generatedOffset.generatedLine;return r||e.generatedColumn-t.generatedOffset.generatedColumn}),a=this._sections[r];return a?a.consumer.originalPositionFor({line:t.generatedLine-(a.generatedOffset.generatedLine-1),column:t.generatedColumn-(a.generatedOffset.generatedLine===t.generatedLine?a.generatedOffset.generatedColumn-1:0),bias:e.bias}):{source:null,line:null,column:null,name:null}},u.prototype.hasContentsOfAllSources=function(){return this._sections.every(function(e){return e.consumer.hasContentsOfAllSources()})},u.prototype.sourceContentFor=function(e,t){for(var r=0;r<this._sections.length;r++){var o=this._sections[r].consumer.sourceContentFor(e,!0);if(o)return o}if(t)return null;throw new Error('"'+e+'" is not in the SourceMap.')},u.prototype.generatedPositionFor=function(e){for(var t=0;t<this._sections.length;t++){var r=this._sections[t];if(-1!==r.consumer._findSourceIndex(o.getArg(e,"source"))){var i=r.consumer.generatedPositionFor(e);if(i)return{line:i.line+(r.generatedOffset.generatedLine-1),column:i.column+(r.generatedOffset.generatedLine===i.line?r.generatedOffset.generatedColumn-1:0)}}}return{line:null,column:null}},u.prototype._parseMappings=function(e,t){this.__generatedMappings=[],this.__originalMappings=[];for(var r=0;r<this._sections.length;r++)for(var i=this._sections[r],a=i.consumer._generatedMappings,s=0;s<a.length;s++){var l=a[s],m=i.consumer._sources.at(l.source);m=o.computeSourceURL(i.consumer.sourceRoot,m,this._sourceMapURL),this._sources.add(m),m=this._sources.indexOf(m);var c=null;l.name&&(c=i.consumer._names.at(l.name),this._names.add(c),c=this._names.indexOf(c));var u={source:m,generatedLine:l.generatedLine+(i.generatedOffset.generatedLine-1),generatedColumn:l.generatedColumn+(i.generatedOffset.generatedLine===l.generatedLine?i.generatedOffset.generatedColumn-1:0),originalLine:l.originalLine,originalColumn:l.originalColumn,name:c};this.__generatedMappings.push(u),"number"==typeof u.originalLine&&this.__originalMappings.push(u)}n(this.__generatedMappings,o.compareByGeneratedPositionsDeflated),n(this.__originalMappings,o.compareByOriginalPositions)},t.IndexedSourceMapConsumer=u},function(e,t,r){"use strict";t.GREATEST_LOWER_BOUND=1,t.LEAST_UPPER_BOUND=2,t.search=function(e,r,o,i){if(0===r.length)return-1;var a=function e(r,o,i,a,s,n){var l=Math.floor((o-r)/2)+r,m=s(i,a[l],!0);return 0===m?l:m>0?o-l>1?e(l,o,i,a,s,n):n==t.LEAST_UPPER_BOUND?o<a.length?o:-1:l:l-r>1?e(r,l,i,a,s,n):n==t.LEAST_UPPER_BOUND?l:r<0?-1:r}(-1,r.length,e,r,o,i||t.GREATEST_LOWER_BOUND);if(a<0)return-1;for(;a-1>=0&&0===o(r[a],r[a-1],!0);)--a;return a}},function(e,t,r){"use strict";function o(e,t,r){var o=e[t];e[t]=e[r],e[r]=o}function i(e,t,r,a){if(r<a){var s=r-1;o(e,(c=r,u=a,Math.round(c+Math.random()*(u-c))),a);for(var n=e[a],l=r;l<a;l++)t(e[l],n)<=0&&o(e,s+=1,l);o(e,s+1,l);var m=s+1;i(e,t,r,m-1),i(e,t,m+1,a)}var c,u}t.quickSort=function(e,t){i(e,t,0,e.length-1)}},function(e,t,r){"use strict";var o=r(4).SourceMapGenerator,i=r(2),a=/(\r?\n)/,s="$$$isSourceNode$$$";function n(e,t,r,o,i){this.children=[],this.sourceContents={},this.line=null==e?null:e,this.column=null==t?null:t,this.source=null==r?null:r,this.name=null==i?null:i,this[s]=!0,null!=o&&this.add(o)}n.fromStringWithSourceMap=function(e,t,r){var o=new n,s=e.split(a),l=0,m=function(){return e()+(e()||"");function e(){return l<s.length?s[l++]:void 0}},c=1,u=0,d=null;return t.eachMapping(function(e){if(null!==d){if(!(c<e.generatedLine)){var t=(r=s[l]||"").substr(0,e.generatedColumn-u);return s[l]=r.substr(e.generatedColumn-u),u=e.generatedColumn,h(d,t),void(d=e)}h(d,m()),c++,u=0}for(;c<e.generatedLine;)o.add(m()),c++;if(u<e.generatedColumn){var r=s[l]||"";o.add(r.substr(0,e.generatedColumn)),s[l]=r.substr(e.generatedColumn),u=e.generatedColumn}d=e},this),l<s.length&&(d&&h(d,m()),o.add(s.splice(l).join(""))),t.sources.forEach(function(e){var a=t.sourceContentFor(e);null!=a&&(null!=r&&(e=i.join(r,e)),o.setSourceContent(e,a))}),o;function h(e,t){if(null===e||void 0===e.source)o.add(t);else{var a=r?i.join(r,e.source):e.source;o.add(new n(e.originalLine,e.originalColumn,a,t,e.name))}}},n.prototype.add=function(e){if(Array.isArray(e))e.forEach(function(e){this.add(e)},this);else{if(!e[s]&&"string"!=typeof e)throw new TypeError("Expected a SourceNode, string, or an array of SourceNodes and strings. Got "+e);e&&this.children.push(e)}return this},n.prototype.prepend=function(e){if(Array.isArray(e))for(var t=e.length-1;t>=0;t--)this.prepend(e[t]);else{if(!e[s]&&"string"!=typeof e)throw new TypeError("Expected a SourceNode, string, or an array of SourceNodes and strings. Got "+e);this.children.unshift(e)}return this},n.prototype.walk=function(e){for(var t,r=0,o=this.children.length;r<o;r++)(t=this.children[r])[s]?t.walk(e):""!==t&&e(t,{source:this.source,line:this.line,column:this.column,name:this.name})},n.prototype.join=function(e){var t,r,o=this.children.length;if(o>0){for(t=[],r=0;r<o-1;r++)t.push(this.children[r]),t.push(e);t.push(this.children[r]),this.children=t}return this},n.prototype.replaceRight=function(e,t){var r=this.children[this.children.length-1];return r[s]?r.replaceRight(e,t):"string"==typeof r?this.children[this.children.length-1]=r.replace(e,t):this.children.push("".replace(e,t)),this},n.prototype.setSourceContent=function(e,t){this.sourceContents[i.toSetString(e)]=t},n.prototype.walkSourceContents=function(e){for(var t=0,r=this.children.length;t<r;t++)this.children[t][s]&&this.children[t].walkSourceContents(e);var o=Object.keys(this.sourceContents);for(t=0,r=o.length;t<r;t++)e(i.fromSetString(o[t]),this.sourceContents[o[t]])},n.prototype.toString=function(){var e="";return this.walk(function(t){e+=t}),e},n.prototype.toStringWithSourceMap=function(e){var t={code:"",line:1,column:0},r=new o(e),i=!1,a=null,s=null,n=null,l=null;return this.walk(function(e,o){t.code+=e,null!==o.source&&null!==o.line&&null!==o.column?(a===o.source&&s===o.line&&n===o.column&&l===o.name||r.addMapping({source:o.source,original:{line:o.line,column:o.column},generated:{line:t.line,column:t.column},name:o.name}),a=o.source,s=o.line,n=o.column,l=o.name,i=!0):i&&(r.addMapping({generated:{line:t.line,column:t.column}}),a=null,i=!1);for(var m=0,c=e.length;m<c;m++)10===e.charCodeAt(m)?(t.line++,t.column=0,m+1===c?(a=null,i=!1):i&&r.addMapping({source:o.source,original:{line:o.line,column:o.column},generated:{line:t.line,column:t.column},name:o.name})):t.column++}),this.walkSourceContents(function(e,t){r.setSourceContent(e,t)}),{code:t.code,map:r}},t.SourceNode=n},function(e,t){e.exports=require("main.js.map")},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(24);t.default=new class{constructor(){this.loop=(()=>{this.fresh(),this.register(),this.run(),this.cleanup(),this.addon()}),this.install=(()=>{o.install(),this.extend()}),this.extend=(()=>{Room.extend(),Flag.extend(),Task.extend(),Creep.extend(),CMemory.extend()}),this.fresh=(()=>{Room.fresh(),Flag.fresh(),Task.fresh(),Population.fresh(),Creep.fresh(),CMemory.fresh()}),this.analyze=(()=>{Flag.analyze(),Room.analyze(),Population.analyze()}),this.register=(()=>{Room.register(),this.analyze(),Task.register(),Creep.register(),StructureSpawn.register()}),this.run=(()=>{Room.run(),Flag.run(),Task.run(),Population.run(),Creep.run(),StructureSpawn.run()}),this.cleanup=(()=>{Room.cleanup(),Flag.cleanup(),Population.cleanup(),CMemory.cleanup()}),this.addon=(()=>{SEND_STATISTIC_REPORTS&&((!Memory.statistics||Memory.statistics.tick&&Memory.statistics.tick+TIME_REPORT<=Game.time)&&Statistics.run(),Util.processReports()),ROOM_VISUALS&&!Memory.CPU_CRITICAL&&Visuals.run(),GRAFANA&&Game.time%GRAFANA_INTERVAL==0&&Grafana.run()})}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(25),i=r(46),a=r(3);t.install=(()=>{a.Install("_ME",a.getUsername),a.Install(global,r(52)),a.Install("Util",r(3).default,{DiamondIterator:r(53).default,SpiralIterator:r(54).default}),o.ProtoypeInstall(),i.TravelerInstall(),a.Install(global,r(55).default,{CMemory:r(56).default,Population:r(62).default,Statistics:r(63).default}),a.Install(Flag,r(64).default),a.Install("Task",r(65).default,{guard:r(66).default,defense:r(67).default,mining:r(68).default,claim:r(69).default,reserve:r(70).default,pioneer:r(71).default,attackController:r(72).default,robbing:r(73).default,reputation:r(74).default,delivery:r(75).default,labTech:r(76).default,safeGen:r(77).default,scheduler:r(78).default}),a.Install(Creep,{Action:r(0).CreepAction,Behaviour:r(0).Behaviour,Setup:r(0).CreepSetup}),a.Install(Creep.action={},{attackController:r(79).default,avoiding:r(80).default,boosting:r(81).default,building:r(82).default,bulldozing:r(83).default,charging:r(84).default,claiming:r(85).default,defending:r(86).default,dismantling:r(87).default,dropping:r(88).default,feeding:r(89).default,fortifying:r(90).default,fueling:r(91).default,guarding:r(92).default,harvesting:r(93).default,healing:r(94).default,idle:r(95).default,invading:r(96).default,mining:r(97).default,picking:r(98).default,reallocating:r(99).default,recycling:r(100).default,repairing:r(101).default,reserving:r(102).default,robbing:r(103).default,safeGen:r(104).default,storing:r(105).default,travelling:r(106).default,uncharging:r(107).default,upgrading:r(108).default,withdrawing:r(109).default}),a.Install(Creep.behaviour={},{claimer:r(110).default,collapseWorker:r(111).default,hauler:r(112).default,healer:r(113).default,labTech:r(114).default,melee:r(115).default,miner:r(116).default,mineralMiner:r(117).default,remoteMiner:r(118).default,remoteHauler:r(119).default,remoteWorker:r(120).default,pioneer:r(121).default,privateer:r(122).default,recycler:r(123).default,ranger:r(124).default,upgrader:r(125).default,worker:r(126).default,safeGen:r(127).default}),a.Install(Creep.setup={},{hauler:r(128).default,healer:r(129).default,miner:r(130).default,mineralMiner:r(131).default,privateer:r(132).default,upgrader:r(133).default,worker:r(134).default}),a.Install(Creep,r(135).default),a.Install(Room,r(136).default,{manager:{construction:r(137).default,containers:r(138).default,defense:r(139).default,extensions:r(140).default,labs:r(141).default,links:r(142).default,nuker:r(143).default,observers:r(144).default,orders:r(145).default,power:r(146).default,resources:r(147).default,spawns:r(148).default,towers:r(149).default,fillRoomOrders:r(150).default,boostProduction:r(151).default}}),a.Install(StructureTower,r(152).default),a.Install(StructureSpawn,r(153).default),a.Install(global,{Grafana:GRAFANA?r(154).default:void 0,Visuals:r(155).default}),a.Install("isRoot",!0),Util.logSystem("Global.install","Code reloaded.")})},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.ProtoypeInstall=(()=>{r(26),r(27),r(28),r(29),r(31),r(32),r(33),r(34),r(35),r(36),r(37),r(38),r(39),r(40),r(41),r(42),r(43),r(44),r(45)})},function(e,t){Object.defineProperties(global,{observerRequests:{get:()=>Util.get(global,"_observerRequests",[]),set(e){Util.get(global,"_observerRequests",[]).push(e)}},cacheValid:{get:()=>Memory.cacheValid},profiler:{get:()=>Memory.profiler}})},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(7);Object.defineProperties(Creep.prototype,{flee:{get(){if(this.data)return this.data.flee?this.data.flee=this.hits!==this.hitsMax:this.data.flee=this.hits/this.hitsMax<.35,this.data.flee},set(e){this.data.flee=e}},sum:{get(){return(_.isUndefined(this._sum)||this._sumSet!==Game.time)&&(this._sumSet=Game.time,this._sum=_.sum(this.carry)),this._sum}},carries:{get(){return(_.isUndefined(this._carries)||this._carrySet!==Game.time)&&(this._carrySet=Game.time,this._carries={},Object.keys(this.carry).forEach(e=>{_.isUndefined(this._carries[e])&&(this._carries[e]=this.carry[e])})),this._carries}},threat:{get(){return _.isUndefined(this._threat)&&(this._threat=Creep.bodyThreat(this.body)),this._threat}},trace:{get(){return Memory.debugTrace.creepName===this.name},set(e){e?Memory.debugTrace.creepName=this.name:this.trace&&delete Memory.debugTrace.creepName}},behaviour:{get(){return Creep.behaviour[this.data.creepType]}},assignAction:{value(e,t){if("string"==typeof e&&(e=Creep.action[e]),e&&e instanceof Creep.Action)return e.assign(this,t)}},assignBehaviour:{value(e){if("string"==typeof e&&(e=Creep.behaviour[e]),e&&e instanceof Creep.Behaviour)return e.assign(this)}},findGroupMemberByType:{value(e,t){return this.findGroupMemberBy(t=>t.creepType===e,t)}},findGroupMemberBy:{value(e,t){if(_.isUndefined(t)&&(t=this.data.flagName),!_.isUndefined(e)&&t){const r=_(Memory.population).filter({flagName:t}).find(e);return r?r.creepName:null}return Util.logError(`${this.name} - Invalid arguments for Creep.findGroupMemberBy ${t} ${e}`),null}},findByType:{value(e){let t;for(let r in Memory.population)if((t=Memory.population[r]).creepType===e)return r}},getBodyparts:{value(e){return _(this.body).filter({type:e}).value().length}},hasActiveBodyparts:{value(e){return this.hasBodyparts(e,this.body.length-Math.ceil(.01*this.hits))}},hasBodyparts:{value(e,t=0){const r=this.body,o=r.length;Array.isArray(e)||(e=[e]);for(let i=t;i<o;i++)if(e.includes(r[i].type))return!0;return!1}},run:{value(e){if(!this.spawning){if(!e&&this.data&&this.data.creepType){if(e=Creep.behaviour[this.data.creepType],this.room.skip)return;if(Memory.CPU_CRITICAL&&!CRITICAL_ROLES.includes(this.data.creepType))return}if(this.data&&!_.contains(["remoteMiner","miner","upgrader"],this.data.creepType)&&(this.repairNearby(),this.buildNearby()),DEBUG&&TRACE&&Util.trace("Creep",{creepName:this.name,pos:this.pos,Behaviour:e&&e.name,Creep:"run"}),e)e.run(this);else if(!this.data){DEBUG&&TRACE&&Util.trace("Creep",{creepName:this.name,pos:this.pos,Creep:"run"},"memory init");let e=this.memory.setup,t=this.memory.cost,r=this.memory.home,o=this.memory.mother,i=this.memory.breeding;if(e&&t&&r&&o&&i){let a=Population.setCreep({creepName:this.name,creepType:e,weight:t,roomName:this.pos.roomName,homeRoom:r,motherSpawn:o,actionName:this.action?this.action.name:null,targetId:this.target?this.target.id||this.target.name:null,spawningTime:i,flagName:null,body:_.countBy(this.body,"type")});Population.countCreep(this.room,a)}else{console.log(Util.dye(CRAYON.error,"Corrupt creep without population entry!! : "+this.name),Util.stack());let e=_.countBy(this.body,"type");if(e[WORK]&&e[CARRY]){let t=e[WORK]*BODYPART_COST[WORK]+e[CARRY]*BODYPART_COST[CARRY]+e[MOVE]*BODYPART_COST[MOVE],r=Population.setCreep({creepName:this.name,creepType:"worker",weight:t,roomName:this.pos.roomName,homeRoom:this.pos.roomName,motherSpawn:null,actionName:null,targetId:null,spawningTime:-1,flagName:null,body:_.countBy(this.body,"type")});Population.countCreep(this.room,r)}else this.suicide()}}this.flee&&(this.fleeMove(),Creep.behaviour.ranger.heal(this),SAY_ASSIGNMENT&&this.say(String.fromCharCode(10133),SAY_PUBLIC))}o.Strategy.freeStrategy(this)}},leaveBorder:{value(){let e=0;return 0===this.pos.y?e=BOTTOM:0===this.pos.x?e=RIGHT:49===this.pos.y?e=TOP:49===this.pos.x&&(e=LEFT),e&&this.move(e),e}},honk:{value(){HONK&&this.say("",SAY_PUBLIC)}},honkEvade:{value(){HONK&&this.say("",SAY_PUBLIC)}},fleeMove:{value(){DEBUG&&TRACE&&Util.trace("Creep",{creepName:this.name,pos:this.pos,Action:"fleeMove",Creep:"run"});if(_.forEach(Object.keys(this.carry),e=>{this.carry[e]>0&&this.drop(e)}),this.fatigue>0)return;let e;if(!this.data.fleePath||this.data.fleePath.length<2||this.data.fleePath[0].x!==this.pos.x||this.data.fleePath[0].y!==this.pos.y||this.data.fleePath[0].roomName!==this.pos.roomName){const t=_.map(this.room.hostiles,e=>({pos:e.pos,range:5}));e=PathFinder.search(this.pos,t,{flee:!0,plainCost:2,swampCost:10,maxOps:500,maxRooms:2,roomCallback:e=>{let t=Game.rooms[e];if(t)return t.creepMatrix}}).path,this.data.fleePath=e}else this.data.fleePath.shift(),e=this.data.fleePath;e&&e.length>0&&this.move(this.pos.getDirectionTo(new RoomPosition(e[0].x,e[0].y,e[0].roomName)))}},idleMove:{value(){if(this.fatigue>0)return;if(_(this.room.structures.piles).filter("pos",this.pos).concat(this.pos.lookFor(LOOK_STRUCTURES)).concat(this.pos.lookFor(LOOK_CONSTRUCTION_SITES)).size()){if(this.data.idle&&this.data.idle.path&&this.data.idle.path.length&&!this.pos.isEqualTo(this.data.idle.lastPos))this.data.idle.path=this.data.idle.path.substr(1);else{const e=Flag.find(FLAG_COLOR.command.idle,this.pos,!0,(e,t)=>{const r=Game.flags[t.name].pos.lookFor(LOOK_CREEPS);return r&&r.length?1/0:e});let t;if(e)t=PathFinder.search(this.pos,{pos:e.pos,range:0},{plainCost:2,swampCost:10,maxOps:350,maxRooms:1,roomCallback:e=>{let t=Game.rooms[e];if(t)return t.structureMatrix}});else{let e=this.room.structures.all.map(e=>({pos:e.pos,range:1})).concat(this.room.sources.map(e=>({pos:e.pos,range:2}))).concat(this.pos.findInRange(FIND_EXIT,2).map(e=>({pos:e,range:1}))).concat(this.room.myConstructionSites.map(e=>({pos:e.pos,range:1})));t=PathFinder.search(this.pos,e,{flee:!0,plainCost:2,swampCost:10,maxOps:350,maxRooms:1,roomCallback:e=>{let t=Game.rooms[e];if(t)return t.structureMatrix}})}this.data.idle={path:Traveler.serializePath(this.pos,t.path),lastPos:this.pos}}const e=parseInt(this.data.idle.path[0],10);e&&(this.data.idle.lastPos=this.pos,this.move(e)),this.data.idle.path&&!this.data.idle.path.length&&delete this.data.idle}}},repairNearby:{value(){if(!this.room.controller||!this.room.controller.owner||this.room.my||this.room.reserved||this.room.ally)if(this.carry.energy>0&&this.hasActiveBodyparts(WORK)){const e=this.data&&"remoteHauler"===this.data.creepType?REMOTE_HAULER.DRIVE_BY_REPAIR_RANGE:DRIVE_BY_REPAIR_RANGE,t=_(this.pos.findInRange(FIND_STRUCTURES,e)).find(e=>Room.shouldRepair(this.room,e));t&&(DEBUG&&TRACE&&Util.trace("Creep",{creepName:this.name,Action:"repairing",Creep:"repairNearby"},t.pos),this.repair(t))}else DEBUG&&TRACE&&Util.trace("Creep",{creepName:this.name,pos:this.pos,Action:"repairing",Creep:"repairNearby"},"not repairing")}},buildNearby:{value(){if(!REMOTE_HAULER.DRIVE_BY_BUILDING||!this.data||"remoteHauler"!==this.data.creepType)return;const e=_(this.pos.findInRange(FIND_MY_CONSTRUCTION_SITES,REMOTE_HAULER.DRIVE_BY_BUILD_RANGE)).find(e=>REMOTE_HAULER.DRIVE_BY_BUILD_ALL||e.structureType===STRUCTURE_CONTAINER||e.structureType===STRUCTURE_ROAD);e?(DEBUG&&TRACE&&Util.trace("Creep",{creepName:this.name,Action:"building",Creep:"buildNearby"},e.pos),this.build(e)):DEBUG&&TRACE&&Util.trace("Creep",{creepName:this.name,Action:"building",Creep:"buildNearby"},"not building")}},controllerSign:{value(){const e=Util.fieldOrFunction(CONTROLLER_SIGN_MESSAGE,this.room);CONTROLLER_SIGN&&(!this.room.controller.sign||this.room.controller.sign.username!==this.owner.username||CONTROLLER_SIGN_UPDATE&&this.room.controller.sign.text!==e)&&this.signController(this.room.controller,e)}},handleError:{value(e){Creep.resolvingError||(this.resolvingError=e,e.preventDefault=(()=>{Creep.resolvingError=null}),Creep.error.trigger(e),Creep.resolvingError&&(DEBUG&&Util.logErrorCode(this,e.errorCode),delete this.data.actionName,delete this.data.targetId,Creep.resolvingError=null))}},explainAgent:{value(){return this.action&&this.action.showAssignment(this,this.target),`ttl:${this.ticksToLive} pos:${this.pos}`}},travelTo:{value(e,t={}){return e=e.pos||e,global.traveler&&global.travelerTick!==Game.time&&(global.traveler=new Traveler),t=this.getStrategyHandler([],"moveOptions",t),_.defaults(t,{allowSK:!0,avoidSKCreeps:!0,debug:DEBUG,reportThreshold:TRAVELER_THRESHOLD,useFindRoute:_.get(global,"ROUTE_PRECALCULATION",!0),routeCallback:Room.routeCallback(this.pos.roomName,e.roomName,t),getStructureMatrix:e=>Room.getStructureMatrix(e.name||e,t),getCreepMatrix:e=>e.getCreepMatrix(t.getStructureMatrix(e))}),t.respectRamparts&&this.room.situation.invasion&&_.filter(this.pos.lookFor(LOOK_STRUCTURES),{my:!0,structureType:STRUCTURE_RAMPART}).length?OK:traveler.travelTo(this,e,t)}}})},function(e,t){Object.defineProperties(Flag.prototype,{cloaking:{get(){return this.memory.cloaking||"0"},set(e){this.memory.cloaking=e}},compareTo:{value(e){return Flag.compare(this,e)}}})},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(30);Room.prototype._find=Room.prototype.find,Object.defineProperties(Room.prototype,{find:{value(e,t){return _.isArray(e)?_(e).map(e=>this._find(e,t)).flatten().value():this._find(e,t)}},structures:{get(){return _.isUndefined(this._structures)&&(this._structures=new o.RoomStructures(this)),this._structures}},combatCreeps:{get(){return _.isUndefined(this._combatCreeps)&&(this._combatCreeps=this.creeps.filter(e=>["melee","ranger","healer","warrior"].includes(e.data.creepType))),this._combatCreeps}},casualties:{get(){if(_.isUndefined(this._casualties)){let e=e=>e.hits<e.hitsMax&&(void 0===e.towers||0==e.towers.length);this._casualties=_.sortBy(_.filter(this.creeps,e),"hits")}return this._casualties}},conserveForDefense:{get(){return this.my&&this.storage&&this.storage.charge<0}},defenseLevel:{get(){if(_.isUndefined(this._defenseLevel)){this._defenseLevel={towers:0,creeps:0,sum:0};let e=e=>{this._defenseLevel.creeps+=e.threat};this.combatCreeps.forEach(e),this._defenseLevel.towers=this.structures.towers.length,this._defenseLevel.sum=this._defenseLevel.creeps+this._defenseLevel.towers*CREEP_PART_THREAT.tower}return this._defenseLevel}},hostile:{get(){return this.memory.hostile}},hostiles:{get(){return _.isUndefined(this._hostiles)&&(this._hostiles=this.find(FIND_HOSTILE_CREEPS,{filter:Task.reputation.hostileOwner})),this._hostiles}},hostileIds:{get(){return _.isUndefined(this._hostileIds)&&(this._hostileIds=_.map(this.hostiles,"id")),this._hostileIds}},hostileThreatLevel:{get(){if(_.isUndefined(this._hostileThreatLevel)){this._hostileThreatLevel=0;let e=e=>{this._hostileThreatLevel+=e.threat};this.hostiles.forEach(e)}return this._hostileThreatLevel}},processInvaders:{value(){void 0===this.memory.hostileIds&&(this.memory.hostileIds=[]),SEND_STATISTIC_REPORTS?void 0===this.memory.statistics&&(this.memory.statistics={}):delete this.memory.statistics;_.forEach(this.hostiles,e=>{if(!Room.isCenterNineRoom(this.name)&&!this.memory.hostileIds.includes(e.id)&&(this.memory.hostileIds.push(e.id),this.newInvader.push(e),SEND_STATISTIC_REPORTS)){let t=JSON.stringify(_.countBy(e.body,"type"));void 0===this.memory.statistics.invaders&&(this.memory.statistics.invaders=[]),this.memory.statistics.invaders.push({owner:e.owner.username,id:e.id,body:t,enter:Game.time,time:Date.now()})}});_.forEach(this.memory.hostileIds,e=>{const t=Game.getObjectById(e);if((!t||!Task.reputation.hostileOwner(t))&&(this.goneInvader.push(e),SEND_STATISTIC_REPORTS&&this.memory.statistics&&void 0!==this.memory.statistics.invaders&&this.memory.statistics.invaders.length>0)){let t=t=>t.id==e&&void 0===t.leave,r=_.find(this.memory.statistics.invaders,t);void 0!=r&&(r.leave=Game.time)}}),this.memory.hostileIds=this.hostileIds}},registerIsHostile:{value(){this.controller&&(_.isUndefined(this.hostile)||"number"==typeof this.hostile)&&(!this.controller.owner||this.controller.my||this.ally?delete this.memory.hostile:this.memory.hostile=this.controller.level)}},flags:{get(){return Util.get(this,"_flags",_.filter(Flag.list,{roomName:this.name}))}},isCriticallyFortifyable:{get(){return _.some(this.structures.fortifyable,"isCriticallyFortifyable")}},relativeEnergyAvailable:{get(){return _.isUndefined(this._relativeEnergyAvailable)&&(this._relativeEnergyAvailable=this.energyCapacityAvailable>0?this.energyAvailable/this.energyCapacityAvailable:0),this._relativeEnergyAvailable}},relativeRemainingEnergyAvailable:{get(){return this.energyCapacityAvailable>0?this.remainingEnergyAvailable/this.energyCapacityAvailable:0}},remainingEnergyAvailable:{get(){return this.energyAvailable-this.reservedSpawnEnergy}},reservedSpawnEnergy:{get(){return _.isUndefined(this._reservedSpawnEnergy)&&(this._reservedSpawnEnergy=0),this._reservedSpawnEnergy},set(e){this._reservedSpawnEnergy=e}},creeps:{get(){return _.isUndefined(this._creeps)&&(this._creeps=this.find(FIND_MY_CREEPS)),this._creeps}},allCreeps:{get(){return _.isUndefined(this._allCreeps)&&(this._allCreeps=this.find(FIND_CREEPS)),this._allCreeps}},immobileCreeps:{get(){return _.isUndefined(this._immobileCreeps)&&(this._immobileCreeps=_.filter(this.creeps,e=>{const t=e.data&&e.data.determinatedSpot;return t&&e.pos.isEqualTo(e.room.getPositionAt(t.x,t.y))})),this._immobileCreeps}},situation:{get(){return _.isUndefined(this._situation)&&(this._situation={noEnergy:0==this.sourceEnergyAvailable,invasion:this.hostiles.length>0&&(!this.controller||!this.controller.safeMode)}),this._situation}},adjacentRooms:{get(){return _.isUndefined(this.memory.adjacentRooms)&&(this.memory.adjacentRooms=Room.adjacentRooms(this.name)),this.memory.adjacentRooms}},adjacentAccessibleRooms:{get(){return _.isUndefined(this.memory.adjacentAccessibleRooms)&&(this.memory.adjacentAccessibleRooms=Room.adjacentAccessibleRooms(this.name)),this.memory.adjacentAccessibleRooms}},privateerMaxWeight:{get(){if(_.isUndefined(this._privateerMaxWeight)&&(this._privateerMaxWeight=0,!this.situation.invasion&&!this.conserveForDefense)){let e,t,r,o,i=1e3*this.controller.level,a=this,s=e=>{e!=a.name&&Room.isMine(e)&&t++},n=n=>{this.adjacentAccessibleRooms.includes(n.roomName)&&((r=Game.rooms[n.roomName])?(e=r.adjacentAccessibleRooms,o=r.sources.length):(e=Room.adjacentAccessibleRooms(n.roomName),o=1),t=1,e.forEach(s),a._privateerMaxWeight+=o*i/t)};Flag.filter(FLAG_COLOR.invade.exploit).forEach(n)}return this._privateerMaxWeight}},claimerMaxWeight:{get(){if(_.isUndefined(this._claimerMaxWeight)){this._claimerMaxWeight=0;let e,t,r,o=1250,i=2,a=this,s=this.controller.level,n=n=>{if(s>3||n.color==FLAG_COLOR.claim.color&&n.secondaryColor==FLAG_COLOR.claim.secondaryColor){if((e=Room.roomDistance(a.name,n.roomName))>i)return;if((r=Game.flags[n.name]).room&&r.room.controller&&r.room.controller.reservation&&r.room.controller.reservation.ticksToEnd>2500)return;t=r.targetOf&&r.targetOf?_.sum(r.targetOf.map(e=>"claimer"==e.creepType?e.weight:0)):0,a._claimerMaxWeight+=o-t}};Flag.filter([FLAG_COLOR.claim,FLAG_COLOR.claim.reserve,FLAG_COLOR.invade.exploit]).forEach(n)}return this._claimerMaxWeight}},structureMatrix:{get(){if(_.isUndefined(this._structureMatrix)){const e=Room.getCachedStructureMatrix(this.name);if(e)this._structureMatrix=e;else{DEBUG&&Util.logSystem(this.name,"Calculating cost matrix");const e=new PathFinder.CostMatrix;let t=t=>{const r=t instanceof ConstructionSite;if(r&&!t.my&&Task.reputation.allyOwner(t))return e.set(t.pos.x,t.pos.y,255);if(t.structureType===STRUCTURE_ROAD){if(!r||USE_UNBUILT_ROADS)return e.set(t.pos.x,t.pos.y,1)}else{if(t.structureType===STRUCTURE_PORTAL)return e.set(t.pos.x,t.pos.y,255);if(OBSTACLE_OBJECT_TYPES.includes(t.structureType)){if(!r||Task.reputation.allyOwner(t))return e.set(t.pos.x,t.pos.y,255)}else if(t.structureType===STRUCTURE_RAMPART&&!t.my&&!t.isPublic&&(!r||Task.reputation.allyOwner(t)))return e.set(t.pos.x,t.pos.y,255)}};this.structures.all.forEach(t),this.constructionSites.forEach(t),this.immobileCreeps.forEach(t=>e.set(t.pos.x,t.pos.y,255));const r=_.get(Room.pathfinderCache,[this.name,"updated"]);Room.pathfinderCache[this.name]={costMatrix:e,updated:Game.time,version:Room.COSTMATRIX_CACHE_VERSION},Room.pathfinderCacheDirty=!0,DEBUG&&TRACE&&Util.trace("PathFinder",{roomName:this.name,prevTime:r,structures:this.structures.all.length,PathFinder:"CostMatrix"},"updated costmatrix"),this._structureMatrix=e}}return this._structureMatrix}},avoidSKMatrix:{get(){if(_.isUndefined(this._avoidSKMatrix)){const e=this.hostiles.filter(e=>"Source Keeper"===e.owner.username);this._avoidSKMatrix=this.getAvoidMatrix({"Source Keeper":e})}return this._avoidSKMatrix}},my:{get(){return _.isUndefined(this._my)&&(this._my=this.controller&&this.controller.my),this._my}},myReservation:{get(){return _.isUndefined(this._myReservation)&&(this._myReservation=this.reservation===global.ME),this._myReservation}},reserved:{get(){if(_.isUndefined(this._reserved))if(this.controller){const e=_.find(Game.spawns).owner.username;this._reserved=this.controller.my||this.controller.reservation&&this.controller.reservation.username===e}else this._reserved=!1;return this._reserved}},owner:{get(){return _.isUndefined(this._owner)&&(this.controller&&this.controller.owner?this._owner=this.controller.owner.username:this._owner=!1),this._owner}},reservation:{get(){return _.isUndefined(this._reservation)&&(this.controller&&this.controller.reservation?this._reservation=this.controller.reservation.username:this._reservation=!1),this._reservation}},ally:{get(){return _.isUndefined(this._ally)&&(this.reserved?this._ally=!0:this.controller?this._ally=Task.reputation.isAlly(this.owner)||Task.reputation.isAlly(this.reservation):this._ally=!1),this._ally}},pavementArt:{get(){return _.isUndefined(this.memory.pavementArt)&&(this.memory.pavementArt=[]),this.memory.pavementArt}},collapsed:{get(){if(_.isUndefined(this._collapsed)){if(!this.my)return void(this._collapsed=!1);if(!this.population)return void(this._collapsed=!0);let e=this.population.typeCount.worker?this.population.typeCount.worker:0,t=this.population.typeCount.hauler?this.population.typeCount.hauler:0,r=this.population.typeCount.pioneer?this.population.typeCount.pioneer:0;this._collapsed=e+t+r===0}return this._collapsed}},RCL:{get(){if(this.controller)return Util.get(this.memory,"RCL",this.controller.level)}},skip:{get(){return Util.get(this,"_skip",!!Flag.find(FLAG_COLOR.command.skipRoom,this))}},checkRCL:{value(){this.controller&&this.memory.RCL!==this.controller.level&&(Room.RCLChange.trigger(this),this.memory.RCL=this.controller.level)}},countMySites:{value(){const e=_.size(this.myConstructionSites);_.isUndefined(this.memory.myTotalSites)||e===this.memory.myTotalSites||Room.costMatrixInvalid.trigger(this),e>0?this.memory.myTotalSites=e:delete this.memory.myTotalSites}},countMyStructures:{value(){const e=_.size(this.structures.my);_.isUndefined(this.memory.myTotalStructures)||e===this.memory.myTotalStructures?delete this.memory.myTotalStructures:(Room.costMatrixInvalid.trigger(this),this.saveExtensions(),this.saveSpawns())}},findRoute:{value(e,t=!0,r=!0,o=!0){if(this.name==e)return[];const i={checkOwner:t,preferHighway:r,allowSK:o};return Game.map.findRoute(this,e,{routeCallback:Room.routeCallback(this.name,e,i)})}},getBorder:{value(e){return _.findKey(Game.map.describeExits(this.name),function(e){return this.name===e},{name:e})}},recordMove:{value(e){if(!ROAD_CONSTRUCTION_ENABLE&&(!ROAD_CONSTRUCTION_FORCED_ROOMS[Game.shard.name]||ROAD_CONSTRUCTION_FORCED_ROOMS[Game.shard.name]&&-1==ROAD_CONSTRUCTION_FORCED_ROOMS[Game.shard.name].indexOf(this.name)))return;let t=e.pos.x,r=e.pos.y;if(0==t||0==r||49==t||49==r||0==e.carry.energy||"building"==e.data.actionName)return;let o=`${String.fromCharCode(32+t)}${String.fromCharCode(32+r)}_x${t}-y${r}`;this.roadConstructionTrace[o]?this.roadConstructionTrace[o]++:this.roadConstructionTrace[o]=1}},isWalkable:{value(e,t,r){return 0==(r=r?r[t][e]:this.lookAt(e,t)).filter(e=>e.type==LOOK_TERRAIN&&"wall"==e.terrain||OBSTACLE_OBJECT_TYPES.includes(e[e.type].structureType)).length}},exits:{value(e,t){let r,o,i;!0===t&&(t=.5),r=0===e?_.chain(this.find(FIND_STRUCTURES)).filter(function(e){return e.structureType===STRUCTURE_PORTAL}).map("pos").value():this.find(e);let a={},s=-1;const n=[];for(let e=0;e<r.length;e++){const l=r[e];_.get(a,[l.x-1,l.y])||_.get(a,[l.x,l.y-1])||(t&&-1!==s&&(n[s].x+=Math.ceil(t*(o-n[s].x)),n[s].y+=Math.ceil(t*(i-n[s].y))),n[++s]=_.pick(l,["x","y"]),o=l.x,i=l.y,a={}),_.set(a,[l.x,l.y],!0),o=Math.max(o,l.x),i=Math.max(i,l.y)}return t&&-1!==s&&(n[s].x+=Math.ceil(t*(o-n[s].x)),n[s].y+=Math.ceil(t*(i-n[s].y))),n}},showCostMatrix:{value(e=this.structureMatrix,t){const r=new RoomVisual(this.name);let o=0,i=50,a=0,s=50;t&&(o=Math.max(0,t.y-3),i=Math.min(50,t.y+4),a=Math.max(0,t.x-3),s=Math.min(50,t.x+4));const n=_.max(e._bits);for(let t=o;t<i;t++)for(let o=a;o<s;o++){const i=e.get(o,t);i&&r.text(i,o,t),r.rect(o-.5,t-.5,1,1,{fill:(l=i/n,`hsl(${(120*(1-l)).toString(10)}, 100%, 50%)`)})}var l}},getAvoidMatrix:{value(e){const t=this.structureMatrix.clone();for(const r in e){const o=e[r];for(const e of o)for(let r=Math.max(0,e.pos.x-3);r<=Math.min(49,e.pos.x+3);r++){const o=r<e.pos.x?e.pos.x-r:r-e.pos.x;for(let i=Math.max(0,e.pos.y-3);i<=Math.min(49,e.pos.y+3);i++)if(this.isWalkable(r,i)){const a=i<e.pos.y?e.pos.y-i:i-e.pos.y,s=17-2*Math.max(o,a);t.set(r,i,s)}}}return t}},getCreepMatrix:{value(e=this.structureMatrix){if(_.isUndefined(this._creepMatrix)){const t=e.clone();this.allCreeps.forEach(function(e){t.set(e.pos.x,e.pos.y,255)}),this._creepMatrix=t}return this._creepMatrix}},invalidateCostMatrix:{value(){Room.costMatrixInvalid.trigger(this.name)}},highwayHasWalls:{value(){return!!Room.isHighwayRoom(this.name)&&!!_.find(this.getPositionAt(25,25).lookFor(LOOK_STRUCTURES),e=>e instanceof StructureWall)}},isTargetAccessible:{value(e,t){if(!e||!t)return;e instanceof RoomObject&&(e=e.pos),t instanceof RoomObject&&(t=t.pos);for(const r of["x","y","roomName"])if(!Reflect.has(e,r)||!Reflect.has(t,r))return;if(!Room.isHighwayRoom(this.name))return;if(!this.highwayHasWalls())return!0;const[r,o]=Room.calcCoordinates(this.name,(e,t)=>[e,t]),i=e=>0===Math.floor(e.x/25)?LEFT:RIGHT,a=e=>0===Math.floor(e.y/25)?TOP:BOTTOM,s=e=>{const t=i(e),r=a(e);return t===LEFT?r===TOP?TOP_LEFT:BOTTOM_LEFT:r===TOP?TOP_RIGHT:BOTTOM_RIGHT};if(r%10==0){if(o%10==0){const r=!!_.find(this.getPositionAt(25,24).lookFor(LOOK_STRUCTURES),e=>e instanceof StructureWall),o=!!_.find(this.getPositionAt(24,25).lookFor(LOOK_STRUCTURES,e=>e instanceof StructureWall)),n=!!_.find(this.getPositionAt(25,26).lookFor(LOOK_STRUCTURES,e=>e instanceof StructureWall)),l=!!_.find(this.getPositionAt(26,25).lookFor(LOOK_STRUCTURES,e=>e instanceof StructureWall));if(s(e)===s(t))return!0;if(r&&o&&n&&l)return s(e)===s(t);if(r){if(n)return o?Util.areEqual(RIGHT,i(e),i(t)):Util.areEqual(LEFT,i(e),i(t));if(o&&l)return a(e)===a(t)&&Util.areEqual(BOTTOM,a(e),a(t));if(Util.areEqual(BOTTOM,a(e),a(t)))return!0;if(o){if(Util.areEqual(RIGHT,i(e),i(t)))return!0;if(s(e)===TOP_LEFT&&s(t)!==TOP_LEFT)return!1}else{if(Util.areEqual(LEFT,i(e),i(t)))return!0;if(s(e)===TOP_RIGHT&&s(t)!==TOP_RIGHT)return!1}}else{if(o&&l)return a(e)===a(t)&&Util.areEqual(TOP,a(e),a(t));if(Util.areEqual(TOP,a(e),a(t)))return!0;if(o){if(Util.areEqual(RIGHT,i(e),i(t)))return!0;if(s(e)===BOTTOM_LEFT&&s(t)!==BOTTOM_LEFT)return!1}else{if(Util.areEqual(LEFT,i(e),i(t)))return!0;if(s(e)===BOTTOM_RIGHT&&s(t)!==BOTTOM_RIGHT)return!1}}return!0}if(i(e)===i(t))return!0}return o%10==0&&(a(e),a(t)),!0}},targetAccessible:{value(e){if(!e)return;e instanceof RoomObject&&(e=e.pos);for(const t of["x","y","roomName"])if(!Reflect.has(e,t))return;if(!Room.isHighwayRoom(this.name))return;if(!this.highwayHasWalls())return!0;const t=_(Game.rooms).filter("my").min(e=>Game.map.getRoomLinearDistance(e.name,this.name));if(t===1/0)return;const[r,o]=Room.calcGlobalCoordinates(this.name,(e,t)=>[e,t]),[i,a]=Room.calcGlobalCoordinates(t,(e,t)=>[e,t]);let s="";if(o-a<0?s+="south":o-a>0&&(s+="north"),r-i<0?s+="east":r-i>0&&(s+="west"),r%10==0){if(o%10==0){if(s.includes("south")&&s.includes("east"))return this.isTargetAccessible(this.getPositionAt(49,49),e);if(s.includes("south")&&s.includes("west"))return this.isTargetAccessible(this.getPositionAt(0,49),e);if(s.includes("north")&&s.includes("east"))return this.isTargetAccessible(this.getPositionAt(49,0),e);if(s.includes("north")&&s.includes("west"))return this.isTargetAccessible(this.getPositionAt(0,0),e)}if(s.includes("east"))return this.isTargetAccessible(this.getPositionAt(49,25),e);if(s.includes("west"))return this.isTargetAccessible(this.getPositionAt(0,25),e)}if(o%10==0){if(s.includes("south"))return this.isTargetAccessible(this.getPositionAt(25,49),e);if(s.includes("north"))return this.isTargetAccessible(this.getPositionAt(25,0),e)}return!0}},GCOrders:{value(){let e=this.memory.resources,t=_.filter(Game.rooms,{my:!0});if(_.isUndefined(e))return void(DEBUG&&Util.logSystem(this.name,`there is no ${this.name}.memory.resources.`));if(0===e.orders.length)return;DEBUG&&Util.logSystem(this.name,`garbage collecting ${this.name} roomOrders`);let r=e.reactions;if(r.orders.length>0&&r.orders[0].amount>0){let t=r.orders[0],o=global.LAB_REACTIONS[t.type][0],i=global.LAB_REACTIONS[t.type][1];e.orders=_.filter(e.orders,e=>e.amount>0&&(e.type===o||e.type===i||!_.isUndefined(global.COMPOUNDS_TO_ALLOCATE[e.type])&&global.COMPOUNDS_TO_ALLOCATE[e.type].allocate))}else e.orders=_.filter(e.orders,e=>e.amount>0&&!_.isUndefined(global.COMPOUNDS_TO_ALLOCATE[e.type])&&global.COMPOUNDS_TO_ALLOCATE[e.type].allocate);if(this.ordersWithOffers())return e.boostTiming.checkRoomAt=Game.time+global.CHECK_ORDERS_INTERVAL,!1;DEBUG&&Util.logSystem(this.name,`not enough or no offers found. Updating room orders in room ${this.name}`),_.isUndefined(e.boostTiming.getOfferAttempts)?e.boostTiming.getOfferAttempts=0:e.boostTiming.getOfferAttempts++,Util.logSystem(this.name,`${this.name} running GCAllRoomOffers`);for(let e of t){if(!e.memory.resources)continue;let t,r=e.memory.resources.offers;for(let o=0;o<r.length;o++){let i=r[o],a=Game.rooms[i.room];if(!(a&&a.memory&&a.memory.resources&&a.memory.resources.orders))continue;let s=a.memory.resources.orders.find(e=>e.id===i.id&&e.type===i.type);s&&(t=s.offers.findIndex(t=>t.room===e.name)),s&&-1!==t||(Util.logSystem(e.name,`Orphaned offer found and deleted in ${e.name}`),r.splice(o,1),o--)}}if(e.boostTiming.getOfferAttempts<3)return this.updateRoomOrders(),e.boostTiming.ordersPlaced=Game.time,e.boostTiming.checkRoomAt=Game.time+1,!0;e.orders=[],e.reactions.orders[0].amount=0,delete e.boostTiming.getOfferAttempts,Util.logSystem(this.name,`${this.name} no offers found. Reaction and orders DELETED`)}},GCOffers:{value(){let e=this.memory.resources,t=!1,r=0;if(_.isUndefined(e))return DEBUG&&Util.logSystem(this.name,`there is no ${this.name}.memory.resources.`),{readyOffersFound:r,terminalOrderPlaced:t};if(0===e.offers.length)return{readyOffersFound:r,terminalOrderPlaced:t};if(DEBUG&&Util.logSystem(this.name,`garbage collecting ${this.name} roomOffers`),e.offers=_.filter(e.offers,e=>{let t=Game.rooms[e.room],r=t.memory.resources.orders,o=this.resourcesAll[e.type];for(let i=0;i<r.length;i++){let a=r[i];if(e.id===a.id&&!_.isUndefined(o)&&o>=0)return!0;if(e.id===a.id)return t.memory.resources.orders[i].offers=[],!1}return!1}),e.offers.length>0)for(let o of e.offers){let i=this.terminal.store[o.type]||0;if(Util.logSystem(this.name,`${i} / ${o.amount} ${o.type} are in ${this.name} terminal`),i>=.5*o.amount&&i<o.amount-global.MIN_OFFER_AMOUNT||i>=o.amount)DEBUG&&Util.logSystem(o.room,`${Math.min(i,o.amount)} ${o.type} are ready to send from ${this.name}`),r++;else{0===this.memory.resources.terminal.length&&this.memory.resources.terminal.push({id:this.terminal.id,orders:[]});let r=this.memory.resources.terminal[0],o=this.memory.resources.terminal[0].id,i=this.terminal;r.orders.length>0&&(r.orders=_.filter(r.orders,t=>(t.orderRemaining>0||t.storeAmount>0)&&_.some(e.offers,e=>e.type===t.type&&e.amount===t.orderRemaining+(i.store[e.type]||0))));for(let a of e.offers){let e=Util.sumCompoundType(r.orders,"orderRemaining"),s=(e[a.type]||0)+(i.store[a.type]||0);a.amount>s?(DEBUG&&(Util.logSystem(this.name,`no / not enough terminal order found in ${this.name} for ${a.amount} ${a.type}`),Util.logSystem(this.name,`terminal stores: ${i.store[a.type]||0} ordered: ${e[a.type]||0}`),Util.logSystem(this.name,`terminal order placed for ${Math.max(a.amount,global.MIN_OFFER_AMOUNT)} ${a.type}`)),this.placeOrder(o,a.type,Math.max(a.amount,global.MIN_OFFER_AMOUNT)),t=!0):Util.logSystem(this.name,`${this.name} terminal orders for ${a.amount} ${a.type} is OK.`)}}}return{readyOffersFound:r,terminalOrderPlaced:t}}},GCLabs:{value(){DEBUG&&Util.logSystem(this.name,`garbage collecting labOrders in ${this.name}`);let e=this.memory.resources,t=e.lab,r=e.reactions.orders[0];for(let o=0;o<t.length;o++){let i,a=t[o];if(a.orders.length>0){if(e.reactions.orders.length>0){let e=global.LAB_REACTIONS[r.type][0],t=global.LAB_REACTIONS[r.type][1];i=_.filter(a.orders,r=>{if((r.orderAmount>0||r.orderRemaining>0||r.storeAmount>0)&&(r.type===e||r.type===t||"energy"===r.type||"Storage"===a.reactionState))return r})}else i=_.filter(a.orders,e=>{if("energy"===e.type||"Storage"===a.reactionState)return e});a.orders.length>i.length&&(this.memory.resources.lab[o].orders=i,DEBUG&&Util.logSystem(this.name,`lab orders fixed in ${this.name}, ${a.id}`))}}}},checkOffers:{value(){if(Memory.boostTiming.multiOrderingRoomName===this)return Util.logSystem(this.name,`${this.name} early roomCheck, multiOrdering in progress`),!0;let e,t=this.memory.resources,r=t.orders,o=[],i=!1;for(let t of r)if(t.offers.length>0)for(let r of t.offers){if(!_.some(o,e=>e.room===r.room)){(e=Game.rooms[r.room].GCOffers()).terminalOrderPlaced&&(i=!0),e.readyOffersFound>0&&o.push({room:r.room,readyOffers:e.readyOffersFound})}}if(1!==o.length||1!==o[0].readyOffers||!_.isUndefined(t.boostTiming.ordersReady))return(o.length>=1||1===o.length&&o[0].readyOffers>1)&&_.isUndefined(t.boostTiming.ordersReady)?(Util.logSystem(this.name,`${this.name} has more than one offers ready, boostTiming.ordersReady created`),Util.logStringify(o),t.boostTiming.ordersReady={time:Game.time,orderCandidates:o},Memory.boostTiming||(Memory.boostTiming={}),Memory.boostTiming.multiOrderingRoomName=this.name,t.boostTiming.checkRoomAt=Game.time+_.sum(o,"readyOffers")+1,!0):e.terminalOrderPlaced?(Util.logSystem(this.name,`terminal orders placed for room ${this.name}`),t.boostTiming.checkRoomAt=Game.time+global.CHECK_ORDERS_INTERVAL,!1):(Util.logSystem(this.name,`${this.name} no readyOffers found`),t.boostTiming.checkRoomAt=Game.time+global.CHECK_ORDERS_INTERVAL,!1);{let e=Game.rooms[o[0].room];Util.logSystem(this.name,`${o[0].room} there is only one offersReady for ${this.name}, running fillARoomOrder()`);let r=!1;if(0!==e.terminal.cooldown)return t.boostTiming.checkRoomAt=Game.time+e.terminal.cooldown+1,Util.logSystem(e.name,`${e.name} terminal cooldown is: ${e.terminal.cooldown}`),Util.logSystem(this.name,`${this.name} time: ${Game.time}, boosTiming:`),Util.logStringify(t.boostTiming),!1;if(!0===(r=e.fillARoomOrder())&&0===t.orders.length||0===_.sum(t.orders,"amount"))return t.boostTiming.checkRoomAt=Game.time+1,Util.logSystem(e.name,`${e.name} terminal send was successful. And there are no more orders`),Util.logSystem(this.name,`${this.name} time: ${Game.time} boostTiming:`),Util.logStringify(t.boostTiming),!0;if(!0===r)return t.boostTiming.checkRoomAt=Game.time+global.CHECK_ORDERS_INTERVAL,Util.logSystem(e.name,`${e.name} terminal send was successful. BTW, there are orders remained to fulfill`),Util.logSystem(this.name,`${this.name} time: ${Game.time}, boostTiming:`),Util.logStringify(t.boostTiming),!0}}},ordersWithOffers:{value(){let e=this.memory.resources.orders;return 0!==e.length&&_.some(e,e=>{return(_.sum(e.offers,"amount")||0)>=e.amount&&e.amount>0})}},makeReaction:{value(){let e,t={},r=function(e,t,r){let o=Game.rooms[e];if(!o.memory.labs)return!1;if(o.memory.labs.length<3)return!1;if(3===o.memory.labs.length&&!global.MAKE_REACTIONS_WITH_3LABS)return!1;if(_.isUndefined(o.memory.resources))return!1;if(_.isUndefined(o.memory.resources.reactions))return!1;let i,a=o.memory.resources.reactions,s=function(e,t){if(1===e.length&&"G"!==e)return;let r=function(e,t){let r,i=function(e){let t=_.filter(Game.rooms,{my:!0}),r=0;for(let o of t){let t=o.resourcesAll[e]||0;t>=global.MIN_OFFER_AMOUNT&&(r+=t)}return r}(e),a=o.resourcesAll[e]||0;return i-a<global.TRADE_THRESHOLD?(r=t-a)<0?r=0:r<global.MIN_COMPOUND_AMOUNT_TO_MAKE&&(r=global.MIN_COMPOUND_AMOUNT_TO_MAKE):(r=t-i)<0?r=0:r<global.MIN_COMPOUND_AMOUNT_TO_MAKE&&(r=global.MIN_COMPOUND_AMOUNT_TO_MAKE),Util.roundUpTo(r,global.MIN_OFFER_AMOUNT)},i=function(e,t){let o={},i={};return o[e]=function(e,t){let o=global.LAB_REACTIONS[e][0],i=global.LAB_REACTIONS[e][1];return{[o]:r(o,t),[i]:r(i,t)}}(e,t),Object.keys(o).forEach(e=>{Object.keys(o[e]).forEach(t=>{(t.length>1||"G"===t)&&(i[t]=o[e][t])})}),{product:o,slice:(a=i,0!==Object.keys(a).length&&a)};var a},a=i(e,t),s=a.product,n=a.slice;do{let e=[];Object.keys(n).forEach(t=>{a=i(t,n[t]),s[t]=a.product[t],e.push(a.slice)}),n={};for(let t of e)n=Object.assign(n,t)}while(_.some(n,Object));return s}(t,r),n=!1,l=!1,m=[];return o.storage&&o.terminal?_.isUndefined(o.memory.labs)||0===o.memory.labs.length?(DEBUG&&console.log(`there are no labs in ${o.name}`),!1):!1!==o.terminal.isActive()&&!1!==o.storage.isActive()&&!1!==Game.getObjectById(o.memory.labs[0].id).isActive()&&(Object.keys(s).forEach(t=>{Object.keys(s[t]).forEach(r=>{let i=s[t][r];if(i>0&&!n){if(1===r.length&&"G"!==r&&(o.resourcesAll[r]||0)<i&&!n&&!(n=function(e,t,r){if(!global.PURCHASE_MINERALS)return DEBUG&&console.log(`${e} needs to buy ${r} ${t} but PURCHASE_MINERALS is false`),!1;if(o.storage.charge<global.STORE_CHARGE_PURCHASE)return DEBUG&&console.log(`storage.charge in ${e} is ${o.storage.charge}, purchase for ${t} is delayed`),!1;if(o.terminal.cooldown>0)return DEBUG&&console.log(`terminal.coolDown in ${e} is ${o.terminal.cooldown}, purchase for ${t} is delayed`),!1;if("idle"!==a.reactorMode)return!1;let i;DEBUG&&console.log(`buying ${r} ${t} in ${e}`),global.AUTOMATED_RATIO_COUNT?(i=Util.countPrices("sell",t,e),DEBUG&&console.log(`average sellRatio: ${e} ${t} ${i}`)):i=global.MAX_BUY_RATIO[t];let s,n,l=Game.market.getAllOrders(o=>{let a,s,n=Game.rooms[e];return"sell"===o.type&&o.resourceType===t&&(o.transactionAmount=Math.min(o.amount,r),!((a=Game.market.calcTransactionCost(o.transactionAmount,o.roomName,e))>n.terminal.store[RESOURCE_ENERGY]||(s=o.transactionAmount*o.price,Game.market.credits<s&&(o.transactionAmount=Game.market.credits/o.price,0===o.transactionAmount)||(o.ratio=(s-a*global.ENERGY_VALUE_CREDITS)/o.transactionAmount,o.ratio>i||o.amount<100))))});return l.length>0?(s=_.min(l,"ratio"),console.log("selected order: "),Util.logStringify(s),DEBUG&&s&&console.log(`Game.market.deal("${s.id}", ${s.transactionAmount}, "${e}");`),(n=Game.market.deal(s.id,s.transactionAmount,e))===OK?(console.log(`Purchased ${s.transactionAmount} ${t} at price: ${s.price} it costs: ${s.transactionAmount*s.price}`),!0):(console.log(`purchase was FAILED error code: ${Util.translateErrorCode(n)}`),console.log(n),!1)):(DEBUG&&(0===i?console.log(`There are no sellOrders for ${t}`):(console.log(`No sell order found for ${r} ${t} at ratio ${global.MAX_BUY_RATIO[t]} in room ${e}`),console.log(`You need to adjust MAX_BUY_RATIO or use AUTOMATED_RATIO_COUNT: true in parameters, current is: ${global.MAX_BUY_RATIO[t]}, recommended: ${i}`))),!1)}(e,r,i)))return{ingredientMade:l,mineralPurchased:n};n||(r.length>1||"G"===r)&&m.push({compound:r,amount:i})}})}),0===m.length&&m.push({compound:t,amount:r}),n||(i=m[m.length-1],l=function(e,t,r){if(_.isUndefined(a))return DEBUG&&console.log(`labs in room ${e} are not registered as flower`),!1;if("flower"!==a.reactorType)return DEBUG&&console.log(`labs in room ${e} are not registered as flower`),!1;let o=Game.rooms[e],i=!1;"idle"===a.reactorMode&&(DEBUG&&Util.logSystem(e,`${o.name} - placeReactionOrder(${t}, ${t}, ${r})`),o.GCLabs(),o.placeReactionOrder(t,t,r),Memory.boostTiming.roomTrading.boostProduction=!0,Memory.boostTiming.timeStamp=Game.time,Util.logSystem(o,`${o.name}, placeReaction ${r} ${t} at time: ${Game.time}`),o.memory.resources.boostTiming.roomState="reactionPlaced",i=!0);return i}(e,i.compound,i.amount)),{ingredientMade:l,mineralPurchased:n}):(DEBUG&&console.log(`there are no storage/terminal in ${o.name}`),!1)};return Object.keys(global.COMPOUNDS_TO_MAKE).forEach(o=>{if(global.COMPOUNDS_TO_MAKE[o].make&&!t.ingredientMade&&(this.name.indexOf(global.COMPOUNDS_TO_MAKE[o].rooms)>-1||0===global.COMPOUNDS_TO_MAKE[o].rooms.length)){let i=this.resourcesAll[o]||0;0===i?(e=Util.roundUpTo(global.COMPOUNDS_TO_MAKE[o].amount+global.COMPOUNDS_TO_MAKE[o].threshold,global.MIN_OFFER_AMOUNT),(t=r(this.name,o,e)).ingredientMade&&DEBUG&&Util.logSystem(this.name,`there is no ${o}, so start to make the compounds for ${global.COMPOUNDS_TO_MAKE[o].amount} ${o} in ${this.name}`)):i<=global.COMPOUNDS_TO_MAKE[o].threshold&&(e=Util.roundUpTo(global.COMPOUNDS_TO_MAKE[o].amount+global.COMPOUNDS_TO_MAKE[o].threshold-i,global.MIN_OFFER_AMOUNT),(t=r(this.name,o,e)).ingredientMade&&DEBUG&&Util.logSystem(this.name,`it is below the threshold, so start to make the compounds for ${e} ${o} in ${this.name}`))}}),t.ingredientMade||t.mineralPurchased}},storedMinerals:{value(e){let t=(this.resourcesStorage[e]||0)+(this.resourcesTerminal[e]||0)-(this.resourcesOffers[e]||0)-(this.resourcesReactions[e]||0);return t<0&&(t=0),t}},countCheckRoomAt:{value(){let e=this.memory.resources,t=e.boostTiming,r=e.lab.length,o=REACTION_TIME[e.reactions.orders[0].type],i=LAB_REACTION_AMOUNT*(r-_.filter(e.lab,e=>"Storage"===e.reactionState).length-2)/o,a=e.reactions.orders[0].amount;t.checkRoomAt=t.reactionMaking+Util.roundUpTo(a/i,o)+o}},getSeedLabOrders:{value(){let e=this.memory.resources;if(_.isUndefined(e)||_.isUndefined(e.reactions)||0===e.reactions.orders.length)return;let t=e.reactions.orders[0].type,r=global.LAB_REACTIONS[t][0],o=global.LAB_REACTIONS[t][1],i=e.lab.findIndex(t=>t.id===e.reactions.seed_a),a=e.lab.findIndex(t=>t.id===e.reactions.seed_b),s=_.filter(e.lab[i].orders,e=>e.type===r),n=_.filter(e.lab[a].orders,e=>e.type===o);return{labOrderAmountA:s[0].orderRemaining,labOrderAmountB:n[0].orderRemaining}}},newFlag:{value:(e,t,r)=>(t||(t=this.getPositionAt(25,25)),t.newFlag(e,r))}})},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});t.RoomStructures=class{constructor(e){this.room=e,Object.defineProperties(this,{all:{configurable:!0,get:function(){return _.isUndefined(this._all)&&(this._all=this.room.find(FIND_STRUCTURES)),this._all}},my:{configurable:!0,get:function(){return _.isUndefined(this._my)&&(this._my=this.room.find(FIND_MY_STRUCTURES)),this._my}},towers:{configurable:!0,get:function(){if(_.isUndefined(this._towers)){this._towers=[];let e=e=>{Util.addById(this._towers,e)};_.forEach(this.room.memory.towers,e)}return this._towers}},repairable:{configurable:!0,get:function(){if(_.isUndefined(this._repairable)){let e=this;this._repairable=_.sortBy(e.all.filter(t=>Room.shouldRepair(e.room,t)),"hits")}return this._repairable}},urgentRepairable:{configurable:!0,get:function(){if(_.isUndefined(this._urgentRepairableSites)){let e=e=>e.hits<LIMIT_URGENT_REPAIRING+(DECAY_AMOUNT[e.structureType]||0);this._urgentRepairableSites=_.filter(this.repairable,e)}return this._urgentRepairableSites}},feedable:{configurable:!0,get:function(){return _.isUndefined(this._feedable)&&(this._feedable=this.extensions.concat(this.spawns)),this._feedable}},fortifyable:{configurable:!0,get:function(){if(_.isUndefined(this._fortifyableSites)){let e=this;this._fortifyableSites=_.sortBy(e.all.filter(t=>e.room.my&&t.hits<t.hitsMax&&t.hits<MAX_FORTIFY_LIMIT[e.room.controller.level]&&(t.structureType!=STRUCTURE_CONTAINER||t.hits<MAX_FORTIFY_CONTAINER)&&(!DECAYABLES.includes(t.structureType)||t.hitsMax-t.hits>3*GAP_REPAIR_DECAYABLE)&&(void 0===Memory.pavementArt[e.room.name]||Memory.pavementArt[e.room.name].indexOf("x"+t.pos.x+"y"+t.pos.y+"x")<0)&&!Flag.list.some(e=>e.roomName==t.pos.roomName&&e.color==COLOR_ORANGE&&e.x==t.pos.x&&e.y==t.pos.y)),"hits")}return this._fortifyableSites}},fuelable:{configurable:!0,get:function(){if(_.isUndefined(this._fuelables)){let e=this.room.situation.invasion?1:.82,t=t=>t.energy<t.energyCapacity*e;this._fuelables=_.sortBy(_.filter(this.towers,t),"energy")}return this._fuelables}},container:{configurable:!0,get:function(){return _.isUndefined(this._container)&&(this._container=new Room.Containers(this.room)),this._container}},links:{configurable:!0,get:function(){return _.isUndefined(this._links)&&(this._links=new Room.Links(this.room)),this._links}},labs:{configurable:!0,get:function(){return _.isUndefined(this._labs)&&(this._labs=new Room.Labs(this.room)),this._labs}},virtual:{configurable:!0,get:function(){return _.isUndefined(this._virtual)&&(this._virtual=_(this.all).concat(this.piles)),this._virtual}},piles:{configurable:!0,get:function(){if(_.isUndefined(this._piles)){const e=this.room;this._piles=Flag.filter(FLAG_COLOR.command.drop,e.getPositionAt(25,25),!0).map(function(t){const r=Game.flags[t.name],o=e.lookForAt(LOOK_ENERGY,r.pos.x,r.pos.y);return o.length&&o[0]||r})}return this._piles}},observer:{configurable:!0,get:function(){return _.isUndefined(this._observer)&&this.room.memory.observer&&(this._observer=Game.getObjectById(this.room.memory.observer.id)),this._observer}},nuker:{configurable:!0,get:function(){return _.isUndefined(this._nuker)&&this.room.memory.nukers&&this.room.memory.nukers.length>0&&(this._nuker=Game.getObjectById(this.room.memory.nukers[0].id)),this._nuker}},nukers:{configurable:!0,get:function(){return _.isUndefined(this._nukers)&&(this._nukers=new Room.Nuker(this.room)),this._nukers}},powerSpawn:{configurable:!0,get:function(){return _.isUndefined(this._powerSpawn)&&this.room.memory.powerSpawns&&this.room.memory.powerSpawns.length>0&&(this._powerSpawn=Game.getObjectById(this.room.memory.powerSpawns[0].id)),this._powerSpawn}},powerSpawns:{configurable:!0,get:function(){return _.isUndefined(this._powerSpawns)&&(this._powerSpawns=new Room.PowerSpawn(this.room)),this._powerSpawns}},extensions:{configurable:!0,get:function(){return _.isUndefined(this.room.memory.extensions)&&this.room.saveExtensions(),_.isUndefined(this._extensions)&&(this._extensions=_.map(this.room.memory.extensions,e=>Game.getObjectById(e))),this._extensions}},spawns:{configurable:!0,get:function(){if(_.isUndefined(this._spawns)){this._spawns=[];let e=e=>{Util.addById(this._spawns,e)};_.forEach(this.room.memory.spawns,e)}return this._spawns}}})}}},function(e,t){Object.defineProperties(RoomPosition.prototype,{adjacent:{get(){if(_.isUndefined(this._adjacent)){this._adjacent=[];for(let e=this.x-1;e<this.x+2;e++)for(let t=this.y-1;t<this.y+2;t++)e>0&&e<49&&t>0&&t<49&&this._adjacent.push(new RoomPosition(e,t,this.roomName))}return this._adjacent}},radius:{value(e=1){if(1===e)return this.adjacent;if(e<1)return[this];const t=[];for(let r=this.x-e;r<=this.x+e;r++)for(let o=this.y-e;o<=this.y+e;o++){const e=new RoomPosition(r,o,this.roomName);r<50&&r>0&&o>0&&o<50&&!_.isEqual(this,e)&&t.push(e)}return t}},findClosestByPathFinder:{value(e,t=_.identity){let r=_.map(e,t);if(_.isEmpty(r))return{goal:null};let o=PathFinder.search(this,r,{maxOps:16e3,roomCallback:e=>{let t=Game.rooms[e];if(t)return t.structureMatrix}}),i=_.last(o.path);void 0==i&&(i=this);let a=_.min(e,e=>i.getRangeTo(e.pos));return{goal:Math.abs(a)!==1/0?a:null,cost:o.cost,ops:o.ops,incomplete:o.incomplete}}},findClosestSpawn:{value(){return this.findClosestByPathFinder(Game.spawns,e=>({pos:e.pos,range:1})).goal}},newFlag:{value(e,t){if(e||(e=_.get(FLAG_COLOR,e)),e)return this.createFlag(t,e.color,e.secondaryColor)}}})},function(e,t){Object.defineProperties(RoomObject.prototype,{accessibleFields:{get(){if(this.memory&&!_.isUndefined(this.memory.accessibleFields))return this.memory.accessibleFields;{let e=this.room.lookForAtArea(LOOK_TERRAIN,this.pos.y-1,this.pos.x-1,this.pos.y+1,this.pos.x+1,!0),t=_.countBy(e,"terrain").wall,r=void 0===t?9:9-t;return this.memory?this.memory.accessibleFields=r:r}}},cloak:{get(){const e=Memory.cloaked[this.id];return!!e&&(_.isNumber(e)&&Game.time>e?(delete Memory.cloaked[this.id],!1):e)},set(e){if(e)return _.isNumber(e)?e<Game.time&&(e=Game.time+e):e=!0,Memory.cloaked[this.id]=e;delete Memory.cloaked[this.id]}}})},function(e,t){Object.defineProperties(Source.prototype,{memory:{get(){if(_.isUndefined(Memory.sources)&&(Memory.sources={}),_.isObject(Memory.sources))return Memory.sources[this.id]=Memory.sources[this.id]||{}},set(e){if(_.isUndefined(Memory.sources)&&(Memory.sources={}),!_.isObject(Memory.sources))throw new Error("Could not set memory extension for sources");Memory.sources[this.id]=e}},container:{get(){return _.isUndefined(this.memory.container)&&this.room.saveContainers(),_.isUndefined(this._container)&&(this.memory.storage?(this._container=Game.getObjectById(this.memory.storage),this._container||delete this.memory.storage):this.memory.terminal?(this._container=Game.getObjectById(this.memory.terminal),this._container||delete this.memory.terminal):this.memory.container?(this._container=Game.getObjectById(this.memory.container),this._container||delete this.memory.container):this._container=null),this._container}},link:{get(){return _.isUndefined(this._link)&&(this.memory.link?(this._link=Game.getObjectById(this.memory.link),this._link||delete this.memory.link):this._link=null),this._link}}}),Object.defineProperties(Mineral.prototype,{memory:{get(){if(_.isUndefined(Memory.minerals)&&(Memory.minerals={}),_.isObject(Memory.minerals))return Memory.minerals[this.id]=Memory.minerals[this.id]||{}},set(e){if(_.isUndefined(Memory.minerals)&&(Memory.minerals={}),!_.isObject(Memory.minerals))throw new Error("Could not set memory extension for minerals");Memory.minerals[this.id]=e}},container:{get(){return _.isUndefined(this.memory.container)&&this.room.saveContainers(),_.isUndefined(this._container)&&(this.memory.terminal?(this._container=Game.getObjectById(this.memory.terminal),this._container||delete this.memory.terminal):this.memory.storage?(this._container=Game.getObjectById(this.memory.storage),this._container||delete this.memory.storage):this.memory.container?(this._container=Game.getObjectById(this.memory.container),this._container||delete this.memory.container):this._container=null),this._container}}})},function(e,t){Object.defineProperties(Structure.prototype,{towers:{get(){return(_.isUndefined(this._towers)||this._towersSet!==Game.time)&&(this._towersSet=Game.time,this._towers=[]),this._towers},set(e){this._towers=e}},active:{get(){return this.room.controller?!!this.room.owner&&(this.room.owner===this.owner.username&&_.get(this.room.memory,["structures",this.id,"active"],!0)):_.get(this.room.memory,["structures",this.id,"active"],!0)}}})},function(e,t){Object.defineProperties(StructureContainer.prototype,{active:{value:!0},sum:{get(){return(_.isUndefined(this._sum)||this._sumSet!=Game.time)&&(this._sumSet=Game.time,this._sum=_.sum(this.store)),this._sum}},getNeeds:{value(e){if(!this.room.memory.resources)return 0;let t=this.room.memory.resources.container.find(e=>e.id==this.id);if(t){let r=t.orders.find(t=>t.type==e);if(r){let t=Math.max(r.orderRemaining+(this.store[e]||0),r.storeAmount),o=r.orderAmount+r.storeAmount;o<0&&(o=0);let i=this.store[e]||0;if(i<t)return Math.min(t-i,this.storeCapacity-this.sum);if(i>1.05*o)return o-i}}return 0}}})},function(e,t){Object.defineProperties(StructureController.prototype,{memory:{get(){if(_.isUndefined(Memory.controllers)&&(Memory.controllers={}),_.isObject(Memory.controllers))return Memory.controllers[this.id]=Memory.controllers[this.id]||{}},set(e){if(_.isUndefined(Memory.controllers)&&(Memory.controllers={}),!_.isObject(Memory.controllers))throw new Error("Could not set memory extension for controller");Memory.controllers[this.id]=e}}})},function(e,t){Object.defineProperties(StructureLab.prototype,{active:{get(){return!!this.room.owner&&(this.room.owner===this.owner.username&&(!(this.room.RCL<6)&&_.get(this.room.memory,["structures",this.id,"active"],!0)))}},getNeeds:{value(e){if(!this.room.memory.resources)return 0;let t=0,r=0,o=this.room.memory.resources.reactions,i=this.room.memory.resources.lab.find(e=>e.id===this.id);if(i){let o=i.orders.find(t=>t.type===e);if(o){let i=0;e===RESOURCE_ENERGY?i=this.energy:e===this.mineralType&&(i=this.mineralAmount),t=Math.max(o.orderRemaining+i,o.storeAmount),(r=o.orderAmount+o.storeAmount)<0&&(r=0)}}let a=0,s=0,n=0;if(e===RESOURCE_ENERGY?(a=this.energy,s=this.energyCapacity-this.energy,n=this.energyCapacity):(this.mineralType===e&&(a=this.mineralAmount),s=this.mineralCapacity-this.mineralAmount,n=this.mineralCapacity),i&&o&&o.orders.length>0&&(this.id===o.seed_a||this.id===o.seed_b)&&(e!==LAB_REACTIONS[o.orders[0].type][0]||e!==LAB_REACTIONS[o.orders[0].type][1])&&a>r)return r-a;if(a<Math.min(t,n)/2)return Math.min(t-a,s);if(i&&i.reactionType===this.mineralType){if(a>r+(n-Math.min(r,n))/2)return r-a}else if(a>r)return r-a;return 0}}})},function(e,t){Object.defineProperties(StructurePowerSpawn.prototype,{getNeeds:{value(e){if(FILL_POWERSPAWN&&!this.room.isCriticallyFortifyable)return e===RESOURCE_ENERGY&&this.energy<.75*this.energyCapacity?this.energyCapacity-this.energy:e===RESOURCE_POWER&&this.power<.25*this.powerCapacity?this.powerCapacity-this.power:0;if(!this.room.memory.resources||!this.room.memory.resources.powerSpawn)return 0;let t=0,r=0,o=this.room.memory.resources.powerSpawn.find(e=>e.id===this.id);if(o){let i=o.orders.find(t=>t.type===e);if(i){let o=0;e===RESOURCE_ENERGY?o=this.energy:e===RESOURCE_POWER&&(o=this.power),t=Math.max(i.orderRemaining+o,i.storeAmount),(r=i.orderAmount+i.storeAmount)<0&&(r=0)}}let i=0,a=0;return e===RESOURCE_ENERGY?(i=this.energy,a=this.energyCapacity-this.energy):e===RESOURCE_POWER&&(i=this.power,a=this.powerCapacity-this.power),i<t?Math.min(t-i,a):i>1.05*r?r-i:0}}})},function(e,t){Object.defineProperties(StructureRampart.prototype,{active:{get(){return this.room.RCL>1}},isCriticallyFortifyable:{get(){return this.hits<=MIN_FORTIFY_LIMIT[this.room.controller.level]}}})},function(e,t){Object.defineProperties(StructureRoad.prototype,{active:{value:!0}})},function(e,t){Object.defineProperties(StructureSpawn.prototype,{run:{value(){if(this.spawning)return;let e=this.room,t=t=>t.isValidSetup(e)&&this.createCreepBySetup(t);const r=Util.get(this.room.memory,"spawnDelay",{});let o=this.createCreepByQueue(e.spawnQueueHigh,"High");return o||0!==e.spawnQueueHigh.length&&e.spawnQueueHigh.length!==r.High||Game.time%SPAWN_INTERVAL!=0||((o=_.some(StructureSpawn.priorityHigh,t))||(o=this.createCreepByQueue(e.spawnQueueMedium,"Medium")),o||0!==e.spawnQueueMedium.length&&e.spawnQueueMedium.length!==r.Medium||(o=_.some(StructureSpawn.priorityLow,t))||(o=this.createCreepByQueue(e.spawnQueueLow,"Low"))),o}},createCreepBySetup:{value(e){DEBUG&&TRACE&&Util.trace("Spawn",{setupType:this.type,rcl:this.room.controller.level,energy:this.room.energyAvailable,maxEnergy:this.room.energyCapacityAvailable,Spawn:"createCreepBySetup"},"creating creep");let t=e.buildParams(this);return this.create(t.parts,t.name,t.setup)?t:null}},createCreepByQueue:{value(e,t){const r=Util.get(this.room.memory,"spawnDelay",{});if(!e)return null;if(Memory.CPU_CRITICAL&&r[t]===e.length)return null;let o;for(const t in e){const r=e[t];Memory.CPU_CRITICAL&&!CRITICAL_ROLES.includes(r.behaviour)||(o=e.splice(t,1)[0])}if(!o)return e.length&&DEBUG&&Util.logSystem(this.pos.roomName,"No non-CRITICAL creeps to spawn, delaying spawn until CPU is not CRITICAL, or new entries are added."),r[t]=e.length,null;delete r[t];let i,a=0;if(o.parts.forEach(function(e){a+=BODYPART_COST[e]}),0===a)return Util.logSystem(this.pos.roomName,Util.dye(CRAYON.error,"Zero parts body creep queued. Removed.")),!1;if(a>this.room.remainingEnergyAvailable)return a>this.room.energyCapacityAvailable||a>300&&!this.room.creeps.length?(Util.logSystem(this.pos.roomName,Util.dye(CRAYON.error,"Queued creep too big for room: "+JSON.stringify(o))),!1):(e.unshift(o),!0);let s=o.name;for(let e=1;null==i||Game.creeps[i]||Memory.population[i];e++)i=o.name+"-"+e;o.name=i;let n=this.create(o.parts,o.name,o.behaviour||o.setup,o.destiny);return n||(o.name=s,e.unshift(o)),n}},create:{value(e,t,r,o){if(0==e.length)return!1;let i=this.createCreep(e,t,null);if(t==i||void 0===Util.translateErrorCode(i)){let t=0;return e.forEach(function(e){t+=BODYPART_COST[e]}),this.room.reservedSpawnEnergy+=t,Population.registerCreep(i,r,t,this.room,this.name,e,o),this.newSpawn={name:i},Creep.spawningStarted.trigger({spawn:this.name,name:i,body:e,destiny:o,spawnTime:e.length*CREEP_SPAWN_TIME}),CENSUS_ANNOUNCEMENTS&&Util.logSystem(this.pos.roomName,Util.dye(CRAYON.birth,"Good morning "+i+"!")),!0}return(DEBUG||CENSUS_ANNOUNCEMENTS)&&Util.logSystem(this.pos.roomName,Util.dye(CRAYON.error,"Offspring failed: "+Util.translateErrorCode(i)+"<br/> - body: "+JSON.stringify(_.countBy(e))+"<br/> - name: "+t+"<br/> - behaviour: "+r+"<br/> - destiny: "+o)),!1}}})},function(e,t){Object.defineProperties(StructureStorage.prototype,{sum:{get(){return(_.isUndefined(this._sum)||this._sumSet!==Game.time)&&(this._sumSet=Game.time,this._sum=_.sum(this.store)),this._sum}},charge:{get(){return Util.chargeScale(this.store.energy,MIN_STORAGE_ENERGY[this.room.controller.level],MAX_STORAGE_ENERGY[this.room.controller.level])}},getNeeds:{value(e){let t=0;if(!this.room.memory.resources)return 0;let r=this.room.memory.resources.storage[0],o=null;r&&(o=r.orders.find(t=>t.type===e)),o||(o={orderAmount:0,orderRemaining:0,storeAmount:0});let i=this.room.controller.level,a=Math.max(o.orderRemaining+(this.store[e]||0),o.storeAmount+(e===RESOURCE_ENERGY?MIN_STORAGE_ENERGY[i]:MAX_STORAGE_MINERAL)),s=e===RESOURCE_ENERGY?this.storeCapacity-this.sum+this.store.energy:o.orderAmount+o.storeAmount+MAX_STORAGE_MINERAL;s<0&&(s=0);let n=this.store[e]||0;return n<a?t=Math.min(a-n,this.storeCapacity-this.sum):n>1.05*s&&(t=s-n),t}}})},function(e,t){Object.defineProperties(StructureTerminal.prototype,{sum:{get(){return(_.isUndefined(this._sum)||this._sumSet!==Game.time)&&(this._sumSet=Game.time,this._sum=_.sum(this.store)),this._sum}},charge:{get(){const e=this.getNeeds(RESOURCE_ENERGY),t=e?this.store[RESOURCE_ENERGY]+e:TERMINAL_ENERGY;return Util.chargeScale(this.store.energy,t,2*t)}},getNeeds:{value(e){let t=0;if(!this.room.memory.resources)return 0;let r=this.room.memory.resources.terminal[0],o=null;r&&(o=r.orders.find(t=>t.type===e)),o||(o={orderAmount:0,orderRemaining:0,storeAmount:0});let i=Math.max(o.orderRemaining+(this.store[e]||0),o.storeAmount+(e===RESOURCE_ENERGY?TERMINAL_ENERGY:0)),a=o.orderAmount+o.storeAmount+(e===RESOURCE_ENERGY?TERMINAL_ENERGY:0);a<0&&(a=0);let s=this.store[e]||0;return s<i?t=Math.min(i-s,this.storeCapacity-this.sum):s>1.05*a&&(t=a-s),t}}})},function(e,t){Object.defineProperties(StructureTower.prototype,{active:{get(){return!!this.room.owner&&(this.room.owner===this.owner.username&&(!(this.room.RCL<3)&&_.get(this.room.memory,["structures",this.id,"active"],!0)))}}})},function(e,t){Object.defineProperties(StructureWall.prototype,{active:{get(){return this.room.RCL>1}},isCriticallyFortifyable:{get(){return this.hits<=MIN_FORTIFY_LIMIT[this.room.controller.level]}}})},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(47);class i{constructor(){this.opts={maxOps:2e4,defaultStuckValue:3,reportThreshold:50,roomRange:22},this.findAllowedRooms=((e,t,r={})=>{if(_.defaults(r,{restrictDistance:16}),Game.map.getRoomLinearDistance(e,t)>r.restrictDistance)return;let o={[e]:!0,[t]:!0},i=Game.map.findRoute(e,t,{routeCallback:o=>{if(r.routeCallback){let e=r.routeCallback(o);if(void 0!==e)return e}if(Game.map.getRoomLinearDistance(e,o)>r.restrictDistance)return!1;let i;if(r.preferHighway){if((i=/^[WE]([0-9]+)[NS]([0-9]+)$/.exec(o))[1]%10==0||i[2]%10==0)return 1}if(!r.allowSK&&!Game.rooms[o]){i||(i=/^[WE]([0-9]+)[NS]([0-9]+)$/.exec(o));let e=i[1]%10,t=i[2]%10;if(!(5===e&&5===t)&&e>=4&&e<=6&&t>=4&&t<=6)return 10}return!r.allowHostile&&this.getHostileRoom(o)&&o!==t&&o!==e?Number.POSITIVE_INFINITY:2.5}});if(!r.debug||_.isArray(i)){for(let e of i)o[e.room]=!0;return o.route=i,o}console.log(`couldn't findRoute to ${t}`)}),this.findTravelPath=((e,t,r={})=>{_.defaults(r,{ignoreCreeps:!0,range:1,maxOps:this.opts.maxOps,obstacles:[]});let o,a=e.pos||e,s=t.pos||t;(r.useFindRoute||void 0===r.useFindRoute&&Game.map.getRoomLinearDistance(a.roomName,s.roomName)>2)&&(o=this.findAllowedRooms(a.roomName,s.roomName,r));const n=PathFinder.search(a,{pos:s,range:r.range},{maxOps:r.maxOps,plainCost:r.ignoreRoads?1:2,roomCallback:t=>{if(r.roomCallback){let e=r.roomCallback(t,r.ignoreCreeps);if(void 0!==e)return e}if(o){if(!o[t])return!1}else if(this.getHostileRoom(t)&&!r.allowHostile&&t!==a.roomName&&t!==s.roomName)return!1;let n,l=Game.rooms[t];l?r.ignoreStructures?(n=new PathFinder.CostMatrix,r.ignoreCreeps||i.addCreepsToMatrix(l,n)):n=r.ignoreCreeps||t!==e.pos.roomName?this.getStructureMatrix(l,r):this.getCreepMatrix(l,r):n=this.getStructureMatrix(t,r);for(let e of r.obstacles)n.set(e.pos.x,e.pos.y,255);return n},swampCost:r.ignoreRoads?5:10});if(r.respectRamparts){const e=Game.rooms[a.roomName];if(e&&e.find(FIND_MY_STRUCTURES,{filter:{structureType:STRUCTURE_RAMPART}}).length)for(let e=0;e<n.path.length;e++)if(_.filter(n.path[e].lookFor(LOOK_STRUCTURES),{structureType:STRUCTURE_RAMPART}).length){n.path=n.path.slice(0,e+1);break}}return n.route=o&&o.route,n}),this.travelTo=((e,t,r={})=>{let o=e.pos,a=t.pos||t;this.registerHostileRoom(e.room),e.memory._travel||(e.memory._travel={stuck:0,tick:Game.time,cpu:0,count:0});let s=e.memory._travel;if(e.fatigue>0)return s.tick=Game.time,ERR_BUSY;if(!t)return ERR_INVALID_ARGS;let n=e.pos.getRangeTo(a);if(n<=r.range)return OK;if(n<=1)return 1!==n||r.range?OK:(r.returnData&&(r.returnData.nextPos=t.pos),e.move(e.pos.getDirectionTo(t)));let l=!0;if(s.prev){const t=e=>0===e.x||49===e.x||0===e.y||49===e.y,r=(e,r)=>t(e)&&t(r)&&e.roomName!==r.roomName&&(e.x===r.x||e.y===r.y);s.prev=i.initPosition(s.prev),o.inRangeTo(s.prev,0)||r(e.pos,s.prev)?(l=!1,s.stuck++):(e.room.recordMove(e),s.stuck=0)}if(s.stuck>=this.opts.defaultStuckValue&&!r.ignoreStuck&&(r.ignoreCreeps=!1,delete s.path),s.tick=Game.time,s.dest&&s.dest.x===a.x&&s.dest.y===a.y&&s.dest.roomName===a.roomName||delete s.path,!s.path){if(e.spawning)return ERR_BUSY;s.dest=a,s.prev=void 0;let t=Game.cpu.getUsed(),o=this.findTravelPath(e,a,r);if(s.cpu+=Game.cpu.getUsed()-t,s.count++,s.avg=_.round(s.cpu/s.count,2),s.count>25&&s.avg>r.reportThreshold&&r.debug&&console.log(`TRAVELER: heavy cpu use: ${e.name}, avg: ${s.cpu/s.count}, total: ${_.round(s.cpu,2)},`+`origin: ${e.pos}, dest: ${a}`),o.incomplete){const t=o.route&&o.route.length;r.debug&&(0===r.range?console.log(`TRAVELER: incomplete path for ${e.name} from ${e.pos} to ${a}, destination may be blocked.`):console.log(`TRAVELER: incomplete path for ${e.name} from ${e.pos} to ${a}, range ${r.range}. Route length ${t}.`)),t>1&&(o=this.findTravelPath(e,new RoomPosition(25,25,o.route[1].room),_.create(r,{range:this.opts.roomRange,useFindRoute:!1})),r.debug&&console.log(`attempting path through next room using known route was ${o.incomplete?"not":""} successful`)),o.incomplete&&o.ops<2e3&&s.stuck<this.opts.defaultStuckValue&&(r.useFindRoute=!1,o=this.findTravelPath(e,a,r),r.debug&&console.log(`attempting path without findRoute was ${o.incomplete?"not ":""}successful`))}s.path=i.serializePath(e.pos,o.path),s.stuck=0}if(!s.path||0===s.path.length)return ERR_NO_PATH;s.prev&&0===s.stuck&&(s.path=s.path.substr(1)),s.prev=e.pos;let m=parseInt(s.path[0],10);return r.returnData&&(r.returnData.nextPos=i.positionAtDirection(e.pos,m)),e.move(m)}),this.getStructureMatrix=((e,t)=>{if(t.getStructureMatrix)return t.getStructureMatrix(e);if(this.refreshMatrices(),!this.structureMatrixCache[e.name]){let t=new PathFinder.CostMatrix;this.structureMatrixCache[e.name]=i.addStructuresToMatrix(e,t,1)}return this.structureMatrixCache[e.name]}),this.getCreepMatrix=((e,t)=>t.getCreepMatrix?t.getCreepMatrix(e):(this.refreshMatrices(),this.creepMatrixCache[e.name]||(this.creepMatrixCache[e.name]=i.addCreepsToMatrix(e,this.getStructureMatrix(e,t).clone())),this.creepMatrixCache[e.name])),this.refreshMatrices=(()=>{Game.time!==this.currentTick&&(this.currentTick=Game.time,this.structureMatrixCache={},this.creepMatrixCache={})}),this.opts=_.defaults({defaultStuckValue:TRAVELER_STUCK_TICKS,reportThreshold:TRAVELER_THRESHOLD},this.opts),this.getHostileRoom=(e=>_.get(Memory,["rooms",e,"hostile"])),this.registerHostileRoom=(e=>e.registerIsHostile())}}i.initPosition=(e=>new RoomPosition(e.x,e.y,e.roomName)),i.addStructuresToMatrix=((e,t,r)=>{for(let o of e.find(FIND_STRUCTURES))o instanceof StructureRampart?o.my||o.isPublic||t.set(o.pos.x,o.pos.y,255):o instanceof StructureRoad?t.set(o.pos.x,o.pos.y,r):o.structureType!==STRUCTURE_CONTAINER&&t.set(o.pos.x,o.pos.y,255);for(let r of e.find(FIND_CONSTRUCTION_SITES))r.structureType!==STRUCTURE_CONTAINER&&r.structureType!==STRUCTURE_ROAD&&r.structureType!==STRUCTURE_RAMPART&&t.set(r.pos.x,r.pos.y,255);return t}),i.addCreepsToMatrix=((e,t)=>(e.find(FIND_CREEPS).forEach(e=>t.set(e.pos.x,e.pos.y,255)),t)),i.serializePath=((e,t)=>{let r="",o=e;for(let e of t)e.roomName===o.roomName&&(r+=o.getDirectionTo(e)),o=e;return r}),i.positionAtDirection=((e,t)=>{return new RoomPosition(e.x+[0,0,1,1,1,0,-1,-1,-1][t],e.y+[0,-1,-1,0,1,1,1,0,-1][t],e.roomName)}),t.TravelerInstall=(()=>{_.assign(global,{CompressedMatrix:new o.CompressedMatrix,Traveler:i,traveler:new i,travelerTick:Game.time})})},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});t.CompressedMatrix=class{constructor(){this.state={nSize:0,cSize:0},this.serialize=(e=>{let t=`${e._bits[0]}x`,r=1;for(let o=1;o<e._bits.length;o++){let i=e._bits[o];i!==e._bits[o-1]?(t+=`${r},${i}x`,r=1):r++}return t+=`${r}`}),this.deserialize=(e=>{const t=new PathFinder.CostMatrix;let r,o,i,a=0;return e.split(",").forEach(e=>{r=e.split("x"),o=r[0],i=r[1],o?_.times(i,e=>{t._bits[a]=o,a++}):a+=i}),t}),this.compareEfficiency=((e,t=new PathFinder.CostMatrix,r=!0)=>{let o,i,a,s;for(let n=0;n<e;n++)o=t.serialize(),r&&console.log("normal",o),a=i=JSON.stringify(o),r&&console.log("normal-deserialize",PathFinder.CostMatrix.deserialize(JSON.parse(i)).serialize()),o=this.serialize(t),r&&console.log("comp-serialize",o),s=i=JSON.stringify(o),r&&console.log("comp-deserialize",this.deserialize(JSON.parse(i)).serialize());this.state.nSize=a.length/1024,this.state.cSize=s.length/1024,console.log("normal size:",_.round(this.state.nSize,2),"compressed size:",_.round(this.state.cSize,2),"reduction(% of original size):",_.round(this.state.cSize/this.state.nSize,2))})}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.dateUtils={toLocalDate(e){e||(e=new Date);let t=TIME_ZONE;return USE_SUMMERTIME&&Util.isSummerTime(e)&&t++,new Date(e.getTime()+36e5*t)},toDateTimeString(e){const t=Util.pad;return t(e.getFullYear(),0,4)+"-"+t(e.getMonth()+1)+"-"+t(e.getDate())+" "+Util.toTimeString(e)},toTimeString(e){const t=Util.pad;return t(e.getHours())+":"+t(e.getMinutes())+":"+t(e.getSeconds())},isSummerTime:e=>(Reflect.has(Date.prototype,"stdTimezoneOffset")||Object.defineProperty(Date.prototype,"stdTimezoneOffset",{value(){const e=new Date(this.getFullYear(),0,1),t=new Date(this.getFullYear(),6,1);return Math.max(e.getTimezoneOffset(),t.getTimezoneOffset())}}),Reflect.has(Date.prototype,"dst")||Object.defineProperty(Date.prototype,"dst",{get(){return this.getTimezoneOffset()<this.stdTimezoneOffset()},configurable:!0}),e.dst)}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.logUtils={translateErrorCode:e=>({0:"OK",1:"ERR_NOT_OWNER",2:"ERR_NO_PATH",3:"ERR_NAME_EXISTS",4:"ERR_BUSY",5:"ERR_NOT_FOUND",6:"ERR_NOT_ENOUGH_RESOURCES",7:"ERR_INVALID_TARGET",8:"ERR_FULL",9:"ERR_NOT_IN_RANGE",10:"ERR_INVALID_ARGS",11:"ERR_TIRED",12:"ERR_NO_BODYPART",14:"ERR_RCL_NOT_ENOUGH",15:"ERR_GCL_NOT_ENOUGH"})[-1*e],dye(e,...t){const r=t.join(" ");if(_.isObject(e)){let t="";const o=r=>t+=`${_.kebabCase(r)}: ${e[r]};`;return _.forEach(Object.keys(e),o),`<span style="${t}">${r}</span>`}return e?`<span style="color: ${e}">${r}</span>`:r},logError(e,t){const r=Util.dye(CRAYON.error,e);t?Util.trace("error",t,r):console.log(r,Util.stack())},logErrorCode(e,t){if(t){let r=Util.translateErrorCode(t);e&&(r?e.say(r):e.say(t));let o=r+"\nroom: "+e.pos.roomName+"\ncreep: "+e.name+"\naction: "+e.data.actionName+"\ntarget: "+e.data.targetId;console.log(Util.dye(CRAYON.error,o),Util.stack()),Game.notify(o,120)}else{let t="unknown error code\nroom: "+e.pos.roomName+"\ncreep: "+e.name+"\naction: "+e.data.actionName+"\ntarget: "+e.data.targetId;console.log(Util.dye(CRAYON.error,t),Util.stack())}},logSystem(e,...t){const r=Util.dye(CRAYON.system,e);console.log(Util.dye(CRAYON.system,`<a href="/a/#!/room/${Game.shard.name}/${e}">${r}</a> &gt;`),...t,Util.stack())},logStringify(e){console.log(JSON.stringify(e,null,2))},stack:(e=!1,t=" ")=>DEBUG_STACKS||e?new Error(`\nSTACK; param:${DEBUG_STACKS}, force:${e}`).stack:t,trace(e,t,...r){let o,i=r;if(0===r.length&&e){let r=e;do{o=r,r=t[r]}while(t[r]&&r!==e);r&&r!==e&&(i="string"==typeof r?[r]:[o,"=",r])}console.log(Game.time,Util.dye(CRAYON.error,e),...i,"<br/>",Util.dye(CRAYON.birth,JSON.stringify(t,null,2)),Util.stack())}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.roomUtils={getVisibleRooms(e){const t=Game.time-(e||5),r=[];for(const e in Memory.rooms){const o=Memory.rooms[e];o.lastViewed&&o.lastViewed>t&&r.push(e)}return r},getDistance:(e,t)=>Math.sqrt(Math.pow(t.x-e.x,2)+Math.pow(t.y-e.y,2)),routeRange:(e,t)=>e===t?0:Util.get(Memory,`routeRange.${e}.${t}`,()=>{const r=e instanceof Room?e:Game.rooms[e];if(!r)return Room.roomDistance(e,t,!1);const o=r.findRoute(t,!1,!1);return o?o===ERR_NO_PATH?1/0:o.length:Room.roomDistance(e,t,!1)}),pave(e){const t=_.values(Game.flags).filter(t=>t.pos.roomName===e&&t.compareTo(FLAG_COLOR.pavementArt)),r=void 0===Memory.pavementArt[e]?"":Memory.pavementArt[e];Memory.pavementArt[e]=r+t.map(e=>`x${e.pos.x}y${e.pos.y}`).join("")+"x";t.forEach(e=>e.pos.createConstructionSite(STRUCTURE_WALL));t.forEach(e=>e.remove())},unpave(e){if(!Memory.pavementArt||!Memory.pavementArt[e])return!1;const t=Game.rooms[e];if(!t)return!1;const r=t.structures.all.filter(t=>Memory.pavementArt[e].indexOf(`x${t.pos.x}y${t.pos.y}x`)>=0);return r&&r.forEach(e=>e.destroy()),delete Memory.pavementArt[e],!0},getRoomLayout(e,t){const r=[],o=Game.rooms[e.roomName];if(!o)return;const i=e.x,a=e.y;_(o.find(FIND_STRUCTURES)).reject(e=>e instanceof StructureController).filter(e=>e.pos.x>=i&&e.pos.y>=a).filter(e=>!t||t(e)).value().forEach(e=>_.set(r,[e.pos.x-i,e.pos.y-a],e.structureType));const s={null:"",'"extension"':"STRUCTURE_EXTENSION",'"road"':"STRUCTURE_ROAD",'"tower"':"STRUCTURE_TOWER",'"spawn"':"STRUCTURE_SPAWN",'"link"':"STRUCTURE_LINK",'"storage"':"STRUCTURE_STORAGE",'"terminal"':"STRUCTURE_TERMINAL",'"nuker"':"STRUCTURE_NUKER",'"powerSpawn"':"STRUCTURE_POWER_SPAWN",'"observer"':"STRUCTURE_OBSERVER",'"rampart"':"STRUCTURE_RAMPART",'"lab"':"STRUCTURE_LAB"},n=new RegExp(Object.keys(s).join("|"),"g");return JSON.stringify(r).replace(n,e=>s[e])}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.marketUtils={countPrices(e,t,r){let o=(e,t,r,o)=>Game.market.getAllOrders(i=>{let a,s;return!(i.type!==e||i.resourceType!==t||i.amount<r)&&(!((a=Game.market.calcTransactionCost(r,i.roomName,o))>Game.rooms[o].terminal.store[RESOURCE_ENERGY])&&(s=r*i.price,i.transactionAmount=Math.min(i.amount,r),i.ratio=(s-a*ENERGY_VALUE_CREDITS)/i.transactionAmount,!0))});switch(Array.prototype.sum=function(){return this.reduce((e,t)=>e+Number(t),0)},Array.prototype.average=function(){return this.sum()/(this.length||1)},e){case ORDER_BUY:let i,a=o(ORDER_BUY,t,MIN_MINERAL_SELL_AMOUNT,r),s=_.min(a,"ratio"),n=_.filter(a,e=>e.id!==s.id),l=[];for(let e of n)l.push(e.ratio);return i=Util.roundUp(l.average(),4);case ORDER_SELL:let m,c=o(ORDER_SELL,t,TRADE_THRESHOLD,r),u=_.max(c,"ratio"),d=_.filter(c,e=>e.id!==u.id),h=[];for(let e of d)h.push(e.ratio);return m=Util.roundUp(h.average(),4)}},sumCompoundType:(e,t="amount")=>_(e).flatten().groupBy("type").transform((e,r,o)=>e[o]=_.sum(r,t)).value(),roundUp:(e,t=0)=>(t=Math.pow(10,t),Math.ceil(e*t)/t),roundUpTo:(e,t)=>(e%t!=0&&(e=e+t-e%t),e),orderingRoom(){let e=_.filter(Game.rooms,{my:!0});return _.filter(e,e=>{let t=e.memory.resources;return!_.isUndefined(t)&&!_.isUndefined(t.orders)&&(_.isUndefined(t.boostTiming)&&(t.boostTiming={}),t.orders.length>0&&_.sum(t.orders,"amount")>0)})}}},function(e,t){e.exports=require("config")},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});class o{constructor(e,t){if(this.next=(()=>{const e=this._stepA,t=this._stepB,r={done:!1,value:{}};switch(this._dir){case TOP_RIGHT:r.value.x=Math.round(this.x-e),r.value.y=Math.round(this.y+t);break;case BOTTOM_RIGHT:r.value.x=Math.round(this.x-t),r.value.y=Math.round(this.y-e);break;case BOTTOM_LEFT:r.value.x=Math.round(this.x+e),r.value.y=Math.round(this.y-t);break;case TOP_LEFT:r.value.x=Math.round(this.x+e),r.value.y=Math.round(this.y+t);break;default:return{done:!0,value:!1}}return this._stepA=e-.5,this._stepB=t+.5,this._stepA<1&&(this._dir=this._dir+2,this._stepA=this._radius-.25,this._stepB=.25),r}),!_.isFinite(t))throw new Error("not finite: "+JSON.stringify([e,t]));this._radius=t,this.x=e.x,this.y=e.y,this._dir=TOP_RIGHT,this._stepA=t-.25,this._stepB=.25}}o.loop=((e,t)=>{const r=e,i=t;if(!_.isFinite(t))throw new Error("not finite: "+JSON.stringify([e,t]));return{[Symbol.iterator]:()=>new o(r,i)}}),o.inside=((e,t,r)=>Math.abs(t.x-e.x)+Math.abs(t.y-e.y)<r),t.default=o},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});class o{constructor(e,t,r){this.next=(()=>{if(o.dirTransform(this,this._dir),--this._step,this._step<=0)switch(this._step=2*this._ring,this._dir){case TOP:this._ring++,this._step++,this._dir=RIGHT;break;case RIGHT:this._dir=BOTTOM;break;case BOTTOM:this._dir=LEFT;break;case LEFT:this._step++,this._dir=TOP;break;default:throw new Error("illegal _dir="+this._dir)}return{done:this._ring>=this._ringLimit,value:{x:this.x,y:this.y}}}),this._dir=TOP,this.x=e.x,void 0===t?(this._ring=0,this._step=2,this.y=e.y+1):(this._ring=t-1,this._step=1,this.y=e.y),void 0===r?this._ringLimit=Math.min(2,this._ring+1):Number.isFinite(r)&&(this._ringLimit=r)}depth(){return this._ring}}o.dirTransform=((e,t)=>{switch(t){case TOP_RIGHT:e.x++;case TOP:e.y--;break;case BOTTOM_RIGHT:e.y++;case RIGHT:e.x++;break;case BOTTOM_LEFT:e.x--;case BOTTOM:e.y++;break;case TOP_LEFT:e.y--;case LEFT:e.x--}return e}),t.default=o},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});t.default=new class{constructor(){this.LAB_REACTIONS={},this.LAB_IDLE="idle",this.LAB_BOOST="boost",this.LAB_SEED="seed",this.LAB_MASTER="master",this.LAB_SLAVE_1="slave_1",this.LAB_SLAVE_2="slave_2",this.LAB_SLAVE_3="slave_3",this.REACTOR_TYPE_FLOWER="flower",this.REACTOR_MODE_IDLE="idle",this.REACTOR_MODE_BURST="burst",this.CREEP_PART_THREAT={move:{common:0,boosted:0},work:{common:1,boosted:3},carry:{common:0,boosted:0},attack:{common:2,boosted:5},ranged_attack:{common:2,boosted:5},heal:{common:4,boosted:10},claim:{common:1,boosted:3},tough:{common:1,boosted:3},tower:25},this.FLAG_COLOR={invade:{color:COLOR_RED,secondaryColor:COLOR_RED,exploit:{color:COLOR_RED,secondaryColor:COLOR_GREEN},robbing:{color:COLOR_RED,secondaryColor:COLOR_YELLOW},attackController:{color:COLOR_RED,secondaryColor:COLOR_CYAN}},labs:{color:COLOR_PURPLE,secondaryColor:COLOR_PURPLE,filter:{color:COLOR_PURPLE,secondaryColor:COLOR_PURPLE},labTech:{color:COLOR_PURPLE,secondaryColor:COLOR_WHITE,filter:{color:COLOR_PURPLE,secondaryColor:COLOR_WHITE}}},construct:{color:COLOR_CYAN,secondaryColor:COLOR_CYAN,spawn:{color:COLOR_CYAN,secondaryColor:COLOR_RED},tower:{color:COLOR_CYAN,secondaryColor:COLOR_PURPLE},link:{color:COLOR_CYAN,secondaryColor:COLOR_BLUE},lab:{color:COLOR_CYAN,secondaryColor:COLOR_GREEN},storage:{color:COLOR_CYAN,secondaryColor:COLOR_YELLOW},terminal:{color:COLOR_CYAN,secondaryColor:COLOR_ORANGE},observer:{color:COLOR_CYAN,secondaryColor:COLOR_BROWN},nuker:{color:COLOR_CYAN,secondaryColor:COLOR_GREY},powerSpawn:{color:COLOR_CYAN,secondaryColor:COLOR_WHITE}},claim:{color:COLOR_GREEN,secondaryColor:COLOR_GREEN,spawn:{color:COLOR_GREEN,secondaryColor:COLOR_WHITE},pioneer:{color:COLOR_GREEN,secondaryColor:COLOR_RED},reserve:{color:COLOR_GREEN,secondaryColor:COLOR_GREY},mining:{color:COLOR_GREEN,secondaryColor:COLOR_BROWN},delivery:{color:COLOR_GREEN,secondaryColor:COLOR_YELLOW}},defense:{color:COLOR_YELLOW,secondaryColor:COLOR_YELLOW},destroy:{color:COLOR_ORANGE,secondaryColor:COLOR_ORANGE,dismantle:{color:COLOR_ORANGE,secondaryColor:COLOR_YELLOW}},pavementArt:{color:COLOR_BROWN,secondaryColor:COLOR_BROWN},command:{color:COLOR_WHITE,drop:{color:COLOR_WHITE,secondaryColor:COLOR_YELLOW},_OCS:{color:COLOR_WHITE,secondaryColor:COLOR_PURPLE},roomLayout:{color:COLOR_WHITE,secondaryColor:COLOR_CYAN},invalidPosition:{color:COLOR_WHITE,secondaryColor:COLOR_RED},skipRoom:{color:COLOR_WHITE,secondaryColor:COLOR_GREEN},idle:{color:COLOR_WHITE,secondaryColor:COLOR_BROWN},safeGen:{color:COLOR_WHITE,secondaryColor:COLOR_BLUE}}},this.DECAY_AMOUNT={rampart:RAMPART_DECAY_AMOUNT,road:ROAD_DECAY_AMOUNT,container:CONTAINER_DECAY},this.DECAYABLES=[STRUCTURE_ROAD,STRUCTURE_CONTAINER,STRUCTURE_RAMPART],this.MEM_SEGMENTS={COSTMATRIX_CACHE:{start:99,end:95}},this.CRAYON={death:{color:"black","font-weight":"bold"},birth:"#e6de99",error:"#e79da7",system:{color:"#999","font-size":"10px"}};for(let e in REACTIONS)for(let t in REACTIONS[e])this.LAB_REACTIONS[REACTIONS[e][t]]=[e,t]}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(0);t.default=new class extends o.Component{constructor(){super(...arguments),this.numSaved=0,this.toActivate={},this.extend=(()=>{this.activateSegment(MEM_SEGMENTS.COSTMATRIX_CACHE,!0),_.defaults(Memory,{cloaked:{},debugTrace:{error:!0,no:{}},pavementArt:{}})}),this.fresh=(()=>{Memory.CPU_CRITICAL=Memory.CPU_CRITICAL?Game.cpu.bucket<CRITICAL_BUCKET_LEVEL+CRITICAL_BUCKET_OVERFILL:Game.cpu.bucket<CRITICAL_BUCKET_LEVEL,this.processSegments()}),this.cleanup=(()=>{_.size(this.toActivate)>0&&RawMemory.setActiveSegments(Object.keys(this.toActivate)),this.toActivate={},this.numSaved=0}),this.activateSegment=((e,t=!1)=>{if(e.start&&e.end){for(let r=e.start;r>=e.end;r--)this.activateSegment(r,t);return}if(e<0||e>99)return Util.logError("RawMemory","cannot activate invalid segment "+e);const r=_.size(RawMemory.segments);if(this.numSaved>=10)return Util.logError("RawMemory","10 segments saved, cannot activate segment "+e);if(!t){if(r>=10)return Util.logError("RawMemory","10 segments loaded, cannot activate segment "+e);if(r+this.numSaved>=10)return Util.logError("RawMemory","combined loaded and saved exceeds limit(10), cannot activate segment "+e)}this.toActivate[e]=!0}),this.deactivateSegment=(e=>{if(e<0||e>99)return Util.logError("RawMemory","cannot deactivate invalid segment "+e);0===_.size(this.toActivate)&&Object.keys(RawMemory.segments).forEach(e=>this.toActivate[e]=!0),delete this.toActivate[e]}),this.cacheValid=(e=>global.cacheValid[e]===Memory.cacheValid[e]),this.processSegment=((e,t)=>{_.isUndefined(Memory.cacheValid[e])&&(Memory.cacheValid[e]=!1);const r=RawMemory.segments[e];if(!this.cacheValid(e))try{t(r?JSON.parse(r):{}),global.cacheValid[e]=Memory.cacheValid[e]}catch(t){console.log('<font style="color:FireBrick">Error loading segment'+e+" caused by "+(t.stack||t.toString())+"</font>"),RawMemory.segments[e]="",delete global.cacheValid[e],delete Memory.cacheValid[e]}}),this.processSegments=(()=>{_.isUndefined(global.cacheValid)&&(global.cacheValid={}),_.isUndefined(Memory.cacheValid)&&(Memory.cacheValid={});for(let e=MEM_SEGMENTS.COSTMATRIX_CACHE.start;e>=MEM_SEGMENTS.COSTMATRIX_CACHE.end;e--)this.processSegment(e,Room.loadCostMatrixCache)}),this.saveSegment=((e,t)=>{const r=_.size(RawMemory.segments),o=Object.keys(t);let i,a=0;for(let s=e.start;s>=e.end;s--)if(o&&a<o.length||i&&i.length>1)if(!_.isUndefined(RawMemory.segments[s])||r+this.numSaved<10){let e,r=!1;for(;a<o.length;){const s=o[a];if(a++,e=`"${s}":${JSON.stringify(t[s])}`,r=(_.get(i,"length",0)+_.get(e,"length",0)+2)/1024>100)break;i=i?i+","+e:"{"+e}if(!i&&e&&e.length>0){const t=_.round((e.length+2)/1024,2);return Util.logError("RawMemory",`Cannot save data at key ${a}, exceeds 100kb limit ${t}kb`)}DEBUG&&Util.logSystem("this.saveSegment","Saving "+_.round(i.length/1024,2)+"kb of data to segment "+s),RawMemory.segments[s]=i+"}",Memory.cacheValid[s]=Game.time,i=r&&e?"{"+e:"{",_.isUndefined(RawMemory.segments[s])&&this.numSaved++}else{if(r>10)return Util.logError("RawMemory","cannot save segment "+s+" too many active segments.");if(r+this.numSaved>10)return Util.logError("RawMemory","cannot save segment "+s+" loaded + saved exceeds limit(10).");Util.logError("RawMemory","should not be here.")}else Memory.cacheValid[s]&&(DEBUG&&Util.logSystem("this.saveSegment","clearing unused segment "+s),RawMemory.segments[s]="",delete Memory.cacheValid[s])})}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});t.EventClass=class{constructor(){this.handlers=[],this.on=(e=>{this.handlers.push(e)}),this.off=(e=>{this.handlers=this.handlers.filter(t=>t!==e)}),this.trigger=(e=>{try{this.handlers.slice(0).forEach(t=>t(e))}catch(e){Util.logError("Error in LiteEvent.trigger: "+(e.stack||e))}})}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});t.CreepSetup=class{constructor(e){this.minControllerLevel=0,this.none={fixedBody:[],multiBody:[],minAbsEnergyAvailable:1/0,minEnergyAvailable:1,maxMulti:0,maxCount:0,maxWeight:0},this.globalMeasurement=!1,this.measureByHome=!1,this.sortedParts=!0,this.mixMoveParts=!1,this._fixedBody=(e=>this.getRCL(e,"fixedBody")),this._multiBody=(e=>this.getRCL(e,"multiBody")),this._minAbsEnergyAvailable=(e=>this.getRCL(e,"minAbsEnergyAvailable")),this._minEnergyAvailable=(e=>this.getRCL(e,"minEnergyAvailable")),this._minMulti=(e=>this.getRCL(e,"minMulti")),this._maxMulti=(e=>this.getRCL(e,"maxMulti")),this._maxCount=(e=>this.getRCL(e,"maxCount")),this._maxWeight=(e=>this.getRCL(e,"maxWeight")),this.buildParams=(e=>{let t={setup:null,name:null,parts:[],cost:0,mother:null,home:null,breeding:1};t.setup=this.type,t.parts=this.parts(e.room),t.cost=Creep.bodyCosts(t.parts),t.mother=e.name,t.home=e.pos.roomName;for(let e=1;null==t.name||Game.creeps[t.name]||Memory.population[t.name];e++)t.name=this.type+"-"+t.cost+"-"+e;return t}),this.isValidSetup=(e=>{if(e.controller.level<this.minControllerLevel)return DEBUG&&TRACE&&Util.trace("Setup",{setupType:this.type,room:e.name,rcl:e.controller.level,Setup:"isValidSetup"},"low RCL"),!1;let t=this._minAbsEnergyAvailable(e),r=this._minEnergyAvailable(e);const o=e.remainingEnergyAvailable,i=e.relativeRemainingEnergyAvailable;if(o<t||i<r)return DEBUG&&TRACE&&Util.trace("Setup",{setupType:this.type,room:e.name,absEnergy:o,energy:i,Setup:"isValidSetup"},"not enough energy"),!1;let a=this._maxCount(e),s=this._maxWeight(e);if(0===a||0===s)return DEBUG&&TRACE&&Util.trace("Setup",{setupType:this.type,room:e.name,maxCount:a,maxWeight:s,Setup:"isValidSetup"},"too many creeps"),!1;null==a&&(a=1/0),null==s&&(s=1/0);let n=0,l=0;if(this.measureByHome){let t=e.name,r=e=>{e.creepType==this.type&&e.homeRoom==t&&Creep.isWorkingAge(e)&&(n++,l+=e.weight)};_.forEach(Memory.population,r)}else{let t=this.globalMeasurement?Population:e.population;if(!t||!t.typeCount[this.type])return!0;n=t.typeCount[this.type]||0,l=t.typeWeight[this.type]||0}const m=n<a&&l<s;return DEBUG&&TRACE&&Util.trace("Setup",{setupType:this.type,room:e.name,returnVal:m,Setup:"isValidSetup"},"count:",n,"<",a,"weight:",l,"<",s),m}),this.existingWeight=(e=>{let t=0;if(this.measureByHome){let r=e.name,o=e=>{e.creepType==this.type&&e.homeRoom==r&&(t+=e.weight)};_.forEach(Memory.population,o)}else{let r=this.globalMeasurement?Population:e.population;t=r&&r.typeWeight[this.type]||0}return t}),this.parts=(e=>{const t=this._fixedBody(e),r=this._multiBody(e),o=this._minMulti(e),i=this._maxMulti(e),a=this._maxWeight(e);let s;return a&&(s=a-this.existingWeight(e)),DEBUG&&TRACE&&Util.trace("Setup",{setupType:this.type,room:e.name,Setup:"parts",maxWeight:a,minMulti:o,maxMulti:i}),Creep.compileBody(e,{fixedBody:t,multiBody:r,minMulti:o,maxMulti:i,maxWeight:s,currentEnergy:!0,sort:this.sortedParts})}),this.mixParts=(e=>{let t=_.countBy(e),r=e.filter(e=>e!=MOVE),o=[];for(let e=r.length-1;e>=0;e--)t[MOVE]-- >0&&o.unshift(MOVE),o.unshift(r[e]);for(;t[MOVE]>0;)o.unshift(MOVE),t[MOVE]--;return o}),this.maxCost=(e=>Creep.bodyCosts(this._multiBody(e))*this._maxMulti(e)+Creep.bodyCosts(this._fixedBody(e))),this.maxPerFlag=((e,t,r)=>{if(!e)throw new Error("undefined flagFilter");return o=>{let i,a,s=0;return Flag.filter(e).forEach(e=>{(i=Util.routeRange(o.name,e.roomName))>t||(a=Game.flags[e.name],_.chain(a.targetOf).filter(e=>!r||e.homeRoom===o.name).every(Creep.isWorkingAge).value()?s++:s+=2)}),s}}),this.getRCL=((e,t)=>{const r=this.RCL[e.controller.level][t];return _.isFunction(r)?r(e):r}),this.type=e}get RCL(){return{1:this.none,2:this.none,3:this.none,4:this.none,5:this.none,6:this.none,7:this.none,8:this.none}}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});t.CreepAction=class{constructor(e){this.maxPerTarget=1/0,this.maxPerAction=1/0,this.targetRange=1,this.reachedRange=1,this.renewTarget=!0,this.default={name:`default-${this.name}`,moveOptions:e=>e||{}},this.setDefault=(e=>{_.assign(this.default,e)}),this.getTargetId=(e=>e.id||e.name),this.getTargetById=(e=>Game.getObjectById(e)||Game.spawns[e]||Game.flags[e]),this.isValidAction=(e=>!0),this.isValidTarget=((e,t)=>null!=e),this.isAddableAction=(e=>this.maxPerAction===1/0||!e.room.population||!e.room.population.actionCount[this.name]||e.room.population.actionCount[this.name]<this.maxPerAction),this.isAddableTarget=((e,t)=>!e.targetOf||this.maxPerTarget===1/0||_.filter(e.targetOf,{actionName:this.name}).length<this.maxPerTarget),this.newTarget=(e=>null),this.unassign=(e=>{delete e.data.actionName,delete e.data.targetId,delete e.action,delete e.target}),this.step=(e=>{CHATTY&&e.say(this.name,SAY_PUBLIC);let t=e.pos.getRangeTo(e.target);if(t<=this.targetRange){let r=this.work(e);if(r!=OK)return e.handleError({errorCode:r,action:this,target:e.target,range:t,creep:e}),this.unassign(e);t=e.pos.getRangeTo(e.target)}if(e.target&&e.hasActiveBodyparts(MOVE))if(t>this.targetRange)e.travelTo(e.target,{range:this.targetRange});else if(t>this.reachedRange){const t=e.pos.getDirectionTo(e.target),r=Traveler.positionAtDirection(e.pos,t);e.room.isWalkable(r.x,r.y)?e.move(t):e.pos.isNearTo(e.target)||e.travelTo(e.target,{range:this.reachedRange})}}),this.work=(e=>ERR_INVALID_ARGS),this.validateActionTarget=((e,t)=>{if(this.isValidAction(e)){if(this.isValidTarget(t,e))return t;if(this.renewTarget)return delete e.data.path,this.newTarget(e)}return null}),this.assign=((e,t)=>(void 0===t&&(t=this.newTarget(e)),!(!t||!this.isAddableTarget(t,e)||(DEBUG&&TRACE&&Util.trace("Action",{creepName:e.name,assign:this.name,target:!t||t.name||t.id,Action:"assign"}),e.action&&e.action.name==this.name&&e.target&&e.target.id===t.id&&e.target.name==t.name||(Population.registerAction(e,this,t),this.onAssignment(e,t)),0)))),this.showAssignment=((e,t)=>{SAY_ASSIGNMENT&&ACTION_SAY[this.name.toUpperCase()]&&e.say(ACTION_SAY[this.name.toUpperCase()],SAY_PUBLIC),(t instanceof RoomObject||t instanceof RoomPosition&&VISUALS.ACTION_ASSIGNMENT)&&Visuals.drawArrow(e,t)}),this.onAssignment=((e,t)=>{this.showAssignment(e,t)}),this.selectstate=(()=>[this.default]),this.isMember=(e=>_.find(e,e=>e.name===this.name,this)),this.getStrategy=((e,t,...r)=>_.isUndefined(r)?t.getStrategyHandler([this.name],e):t.getStrategyHandler([this.name],e,...r)),this.name=e}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});t.CreepBehaviour=class{constructor(e){this.state={default:{name:`default-${this.name}`}},this.setState=(e=>{_.assign(this.state,e)}),this.mergeState=(e=>{_.merge(this.state,e)}),this.actions=(e=>[]),this.inflowActions=(e=>[]),this.outflowActions=(e=>[]),this.assignAction=((e,t,r,o)=>{"string"==typeof t&&(t=Creep.action[t]);const i=t.isValidAction(e);if(DEBUG&&TRACE&&Util.trace("Action",{actionName:t.name,behaviourName:this.name,creepName:e.name,valid:i,Action:"isValidAction"}),!i)return!1;const a=t.isAddableAction(e);if(DEBUG&&TRACE&&Util.trace("Action",{actionName:t.name,behaviourName:this.name,creepName:e.name,addable:a,Action:"isAddableAction"}),!a)return!1;const s=t.assignDebounce?t.assignDebounce(e,o,r):t.assign(e,r);return s?(DEBUG&&TRACE&&Util.trace("Behaviour",{actionName:t.name,behaviourName:this.name,creepName:e.name,assigned:s,Behaviour:"nextAction",Action:"assign",target:e.target.id||e.target.name}),e.data.lastAction=t.name,e.data.lastTarget=e.target.id,!0):(DEBUG&&TRACE&&Util.trace("Action",{actionName:t.name,behaviourName:this.name,creepName:e.name,assigned:s,Behaviour:"assignAction",Action:"assign"}),!1)}),this.selectInflowAction=(e=>{const t={},r=this.outflowActions(e);for(let o of this.inflowActions(e))if(!t[o.name]&&(t[o.name]=!0,this.assignAction(e,o,void 0,r)))return;return Creep.action.idle.assign(e)}),this.selectAction=((e,t)=>{const r={};for(let o of t)if(!r[o.name]&&(r[o.name]=!0,this.assignAction(e,o)))return;return Creep.action.idle.assign(e)}),this.nextAction=(e=>this.selectAction(e,this.actions(e))),this.needEnergy=(e=>e.sum<e.carryCapacity/2),this.nextEnergyAction=(e=>{if(this.needEnergy(e))return this.selectInflowAction(e);if(e.data.nextAction&&e.data.nextTarget){const t=Creep.action[e.data.nextAction],r=Game.getObjectById(e.data.nextTarget);if(delete e.data.nextAction,delete e.data.nextTarget,this.assignAction(e,t,r))return!0}return this.selectAction(e,this.outflowActions(e))}),this.invalidAction=(e=>!e.action),this.run=(e=>{this.invalidAction(e)&&(e.data.destiny&&e.data.destiny.task&&Task[e.data.destiny.task]&&Task[e.data.destiny.task].nextAction?Task[e.data.destiny.task].nextAction(e):this.nextAction(e)),e.action&&e.target?(DEBUG&&TRACE&&Util.trace("Behaviour",{actionName:e.action.name,behaviourName:this.name,creepName:e.name,target:e.target.id||e.target.name,Action:"run"}),e.action.step(e)):Util.logError("Creep without action/activity!\nCreep: "+e.name+"\ndata: "+JSON.stringify(e.data))}),this.assign=(e=>{e.data.creepType=this.name}),this.selectstate=(e=>[this.state.default,this.state[e]]),this.name=e}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});t.RoomManager=class{constructor(e){this.extend=(()=>{this.prototypeExtend(),this.roomExtend()}),this.prototypeExtend=(()=>{}),this.roomExtend=(()=>{}),this.assignRoomPrototype=(e=>{Object.defineProperties(Room.prototype,e)}),this.assignRoom=(e=>{_.assign(Room,e)}),this.name=e}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(0);t.default=new class extends o.Component{constructor(){super(...arguments),this.typeCount={},this.typeWeight={},this.actionCount={},this.actionWeight={},this.died=[],this.predictedRenewal=[],this.spawned=[],this.spawnsToProbe=[],this.stats={creep:{coreParts:{[MOVE]:!0,[HEAL]:!0},boost:{hits:{[RESOURCE_GHODIUM_OXIDE]:143,[RESOURCE_GHODIUM_ALKALIDE]:200,[RESOURCE_CATALYZED_GHODIUM_ALKALIDE]:334}}}},this.fresh=(()=>{this.typeCount={},this.typeWeight={},this.actionCount={},this.actionWeight={},this.died=[],this.predictedRenewal=[],this.spawned=[],this.spawnsToProbe=[],_.isUndefined(Memory.population)&&(Memory.population={})}),this.analyze=(()=>{let e=e=>{let t=Game.creeps[e.creepName];if(t){if(t.data=e,delete t.action,delete t.target,delete t.flag,t.spawning?e.spawningTime++:t.ticksToLive>0&&!t.data.spawned?(t.data.spawned=!0,this.spawned.push(e.creepName),Game.spawns[e.motherSpawn]&&this.spawnsToProbe.push(e.motherSpawn)):t.ticksToLive<=(e.predictedRenewal?e.predictedRenewal:e.spawningTime)&&!t.data.nearDeath&&(t.data.nearDeath=!0,CENSUS_ANNOUNCEMENTS&&console.log(Util.dye(CRAYON.system,e.creepName+" &gt; ")+Util.dye(CRAYON.death,"Farewell!"),Util.stack()),this.predictedRenewal.push(t.name),!this.spawnsToProbe.includes(e.motherSpawn)&&"unknown"!=e.motherSpawn&&Game.spawns[e.motherSpawn]&&this.spawnsToProbe.push(e.motherSpawn)),e.ttl=t.ticksToLive,e.creepType&&(void 0===t.ticksToLive||Creep.isWorkingAge(e))&&this.countCreep(t.room,e),e.flagName){let r=Game.flags[e.flagName];r?(void 0===r.targetOf?r.targetOf=[e]:r.targetOf.push(e),t.flag=r):delete e.flagName}let r=e.actionName&&Creep.action[e.actionName]?Creep.action[e.actionName]:null,o=r&&e.targetId?Game.getObjectById(e.targetId)||Game.spawns[e.targetId]||Game.flags[e.targetId]:null;o&&o.id===t.id&&(o=Flag.specialFlag()),r&&o?this.registerAction(t,r,o,e):(delete e.actionName,delete e.targetId,t.action=null,t.target=null),void 0===e.hull&&_.assign(e,this.getCombatStats(t.body)),t.data=e}else CENSUS_ANNOUNCEMENTS&&Util.logSystem(e.homeRoom,Util.dye(CRAYON.death,"Good night "+e.creepName+"!")),this.died.push(e.creepName)};_.forEach(Memory.population,t=>{e(t)});let t=e=>{let t=Game.creeps[e.creepName];if(t&&t.action&&t.target){let r=t.target.id||t.target.name,o=t.action.validateActionTarget(t,t.target);o?(r!=o.id||o.name)&&this.registerAction(t,t.action,o,e):(delete e.actionName,delete e.targetId,t.action=null,t.target=null)}};_.forEach(Memory.population,e=>{t(e)})}),this.run=(()=>{if(this.spawned.forEach(e=>Creep.spawningCompleted.trigger(Game.creeps[e])),Creep.died.on(e=>{const t=Memory.population[e];t&&t.determinatedSpot&&t.roomName&&Room.costMatrixInvalid.trigger(t.roomName)}),this.died.forEach(e=>Creep.died.trigger(e)),this.predictedRenewal.forEach(e=>Creep.predictedRenewal.trigger(Game.creeps[e])),Game.time%SPAWN_INTERVAL!=0){let e=e=>Game.spawns[e].run();this.spawnsToProbe.forEach(e)}}),this.cleanup=(()=>{this.died.forEach(e=>this.unregisterCreep(e))}),this.getCreep=(e=>Memory.population[e]),this.setCreep=(e=>(Memory.population[e.creepName]=e,Memory.population[e.creepName])),this.registerCreep=((e,t,r,o,i,a,s=null)=>{let n=this.setCreep({creepName:e,creepType:t,weight:r,roomName:o.name,homeRoom:o.name,motherSpawn:i,actionName:null,targetId:null,spawningTime:0,flagName:null,body:_.countBy(a),destiny:s});this.countCreep(o,n)}),this.unregisterCreep=(e=>{delete Memory.population[e],delete Memory.creeps[e]}),this.registerAction=((e,t,r,o)=>{if(DEBUG&&TRACE&&Util.trace("Population",{creepName:this.name,registerAction:t.name,target:r.name||r.id,Population:"registerAction"}),e===r)throw new Error("attempt to register self target");void 0===o&&(o=this.getCreep(e.name)),o.carryCapacityLeft=e.carryCapacity-e.sum;let i=e.room;void 0===i.population&&(i.population={typeCount:{},typeWeight:{},actionCount:{},actionWeight:{}}),e.action&&(void 0===i.population.actionCount[e.action.name]?i.population.actionCount[e.action.name]=0:i.population.actionCount[e.action.name]--,void 0===i.population.actionWeight[e.action.name]?i.population.actionWeight[e.action.name]=0:i.population.actionWeight[e.action.name]-=o.weight,void 0===this.actionCount[e.action.name]?this.actionCount[e.action.name]=0:this.actionCount[e.action.name]--,void 0===this.actionWeight[e.action.name]?this.actionWeight[e.action.name]=0:this.actionWeight[e.action.name]-=o.weight,delete e.data.determinatedSpot,delete e.data.determinatedTarget),o.actionName=t.name,void 0===i.population.actionCount[t.name]?i.population.actionCount[t.name]=1:i.population.actionCount[t.name]++,void 0===i.population.actionWeight[t.name]?i.population.actionWeight[t.name]=o.weight:i.population.actionWeight[t.name]+=o.weight,void 0===this.actionCount[t.name]?this.actionCount[t.name]=1:this.actionCount[t.name]++,void 0===this.actionWeight[t.name]?this.actionWeight[t.name]=o.weight:this.actionWeight[t.name]+=o.weight;let a,s=r.id||r.name;if(o.targetId){let t=o.targetId?Game.getObjectById(o.targetId)||Game.spawns[o.targetId]||Game.flags[o.targetId]:null;if(t&&(a=t.id||t.name,t.targetOf)){let r=t=>t.creepName===e.name,o=t.targetOf.findIndex(r);o>-1&&t.targetOf.splice(o,1)}}o.targetId=s,r&&!Flag.isSpecialFlag(r)&&(void 0===r.targetOf?r.targetOf=[o]:r.targetOf.push(o)),s!=a&&delete o.path,e.action=t,e.target=r,e.data=o}),this.registerCreepFlag=((e,t)=>{if(!(t&&e.data&&e.data.flagName&&e.data.flagName==t.name&&e.flag.name==t.name)){if(e.data&&e.data.flagName){let t=Game.flags[e.data.flagName];if(t&&t.targetOf){let r=t=>t.creepName===e.name,o=t.targetOf.findIndex(r);o>-1&&t.targetOf.splice(o,1)}}t?(void 0===t.targetOf?t.targetOf=[e.data]:t.targetOf.push(e.data),e.flag=t,e.data.flagName=t.name):(delete e.data.flagName,delete e.flag)}}),this.countCreep=((e,t)=>{t.roomName=e.name,void 0===e.population&&(e.population={typeCount:{},typeWeight:{},actionCount:{},actionWeight:{}}),void 0===e.population.typeCount[t.creepType]?e.population.typeCount[t.creepType]=1:e.population.typeCount[t.creepType]++,void 0===e.population.typeWeight[t.creepType]?e.population.typeWeight[t.creepType]=t.weight:e.population.typeWeight[t.creepType]+=t.weight,void 0===this.typeCount[t.creepType]?this.typeCount[t.creepType]=1:this.typeCount[t.creepType]++,void 0===this.typeWeight[t.creepType]?this.typeWeight[t.creepType]=t.weight:this.typeWeight[t.creepType]+=t.weight}),this.sortEntries=(()=>{let e={};_.map(_.sortBy(Memory.population,e=>e.creepName),t=>e[t.creepName]=t),Memory.population=e}),this.getCombatStats=(e=>{let t=0,r=99,o=100*e.length-99;for(;t<e.length&&!this.stats.creep.coreParts[e[t].type];t++)r+=this.stats.creep.boost.hits[e[t].boost]||100,o-=100;return{hull:r,coreHits:o}}),this.findCircular=(()=>{const e={creeps:Game.creeps,structures:Game.structures,memory:Memory},t={};for(let r in e){const o=e[r];for(let e in o){const i=o[e],a=r+"."+e;t[e]=a,this.checkCircular(e,t,i,a,1)}}}),this.checkCircular=((e,t,r,o,i)=>{if(i>10)Util.logError("Checking for circulars, very deep path",{rootPath:o,depth:i});else for(let a in r){const s=o+"."+a,n=r[a];if(!_.isObject(n))continue;const l=n.id||n.name;if(l===e)throw new Error("circular structure:"+l+" at:"+s+" and at:"+t[l]);l&&!t[l]&&(t[l]=s,this.checkCircular(e,t,n,s,i+1))}})}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(0);t.default=new class extends o.Component{constructor(){super(...arguments),this.storedStatisticsTime=Memory.statistics&&Memory.statistics.time?Memory.statistics.time:0,this.run=(()=>{let e;_.isUndefined(Memory.statistics)&&(Memory.statistics={reports:[]}),SEND_STATISTIC_REPORTS&&this.storedStatisticsTime>0&&(e="<div><h3><b>Status report </b></h3><h4>at "+Util.toDateTimeString(Util.toLocalDate())+",<br/>comparison to state before: "+this.toTimeSpanString(new Date,new Date(this.storedStatisticsTime))+" ("+(Game.time-Memory.statistics.tick)+" loops)</h4>",Game.cpu.bucket&&(bucketDif=Game.cpu.bucket-Memory.statistics.bucket,e+="CPU Bucket: "+Game.cpu.bucket+" ("+(bucketDif>=0?"+":"")+bucketDif+")"),e+="</div>",Memory.statistics.reports.push(e));let t=t=>{let r="<li>"+t.owner+": "+t.body.replace(/"/g,"");void 0===t.leave?r+=" since "+Util.toTimeString(Util.toLocalDate(new Date(t.time)))+"</li>":r+=" for "+(t.leave-t.enter)+" loops at "+Util.toTimeString(Util.toLocalDate(new Date(t.time)))+"</li>",e.length+r.length>REPORT_MAX_LENGTH?(Memory.statistics.reports.push(e+"</ul></li></ul>"),e='<ul><li style="list-style-type:none"><ul>'+r):e+=r};_.forEach(Game.rooms,r=>{if(r.controller){if(SEND_STATISTIC_REPORTS&&this.storedStatisticsTime>0)if(r.controller.my&&r.memory.statistics){e="<ul><li><b>Room "+r.name+"</b><br/><u>Controller</u><ul>";let o=r.controller.progress<r.memory.statistics.controllerProgress,i=(100*r.controller.progress/r.controller.progressTotal).toFixed(0),a=o?r.memory.statistics.controllerProgressTotal-r.memory.statistics.controllerProgress+r.controller.progress:r.controller.progress-r.memory.statistics.controllerProgress,s=(100*a/r.controller.progressTotal).toFixed(1),n=(a/(Game.time-Memory.statistics.tick)).toFixed(2);if(e+="<li>Level "+r.controller.level+", "+i+"% of "+r.controller.progressTotal+"<br/>( +"+a+" | +"+s+"% | +"+n+"/loop )"+(o?" <b><i>Upgraded!</i></b></li></ul>":"</li></ul>"),r.storage&&r.memory.statistics.store){let t=r.memory.statistics.store,o=r.storage.store;e+="<u>Storage</u><ul>";for(let r in t){let i=o[r]?o[r]-t[r]:-1*t[r];e+="<li>"+r+": "+(o[r]||0)+" ("+(i>-1?"+":"")+i+")</li>"}for(let r in o)t[r]||(e+="<li>"+r+": "+o[r]+" (+"+o[r]+")</li>");e+="</ul>"}r.memory.statistics.invaders&&r.memory.statistics.invaders.length>0&&(e+="<u>Invaders</u><ul>",_.forEach(r.memory.statistics.invaders,t),e+="</ul>"),e+="</li></ul>",Memory.statistics.reports.push(e)}else!r.controller.my&&r.controller.reservation&&(e="<ul><li><b>Room "+r.name+"</b><br/><u>Controller</u><ul><li>Reservation: "+r.controller.reservation.ticksToEnd+" for "+r.controller.reservation.username+"</li></ul></li></ul>",Memory.statistics.reports.push(e));let o=e=>void 0===e.leave,i=r.memory.statistics?_.filter(r.memory.statistics.invader,o):[];r.memory.statistics={tick:Game.time,time:Date.now(),store:r.storage?r.storage.store:null,controllerProgress:r.controller.progress,controllerProgressTotal:r.controller.progressTotal,invaders:i}}}),Memory.statistics.tick=Game.time,Memory.statistics.time=Date.now(),Memory.statistics.bucket=Game.cpu.bucket}),this.toTimeSpanString=((e,t)=>{let r=e.getTime()-t.getTime();r<0&&(r*=-1);let o,i=new Date(r),a=Math.floor(r/36e5),s=i.getMinutes(),n=i.getSeconds();return o=a>0?a+"h "+s+"m "+n+"s":s>0?s+"m "+n+"s":n>0?n+"s":"0"})}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(0),i=r(3);t.default=new class extends o.Component{constructor(){super(...arguments),this.list=[],this.stale=[],this.fresh=(()=>{i.Install(Flag,{found:new o.EventClass,FlagRemoved:new o.EventClass}),_.forEach(Game.flags,e=>delete e.targetOf),this.list=[],this.stale=[],delete this._hasInvasionFlag}),this.analyze=(()=>(_.forEach(Game.flags,e=>{try{e.creeps={},e.cloaking&&e.cloaking>0&&e.cloaking--,this.list.push({name:e.name,color:e.color,secondaryColor:e.secondaryColor,roomName:e.pos.roomName,x:e.pos.x,y:e.pos.y,cloaking:e.cloaking})}catch(e){Util.logError(e.stack||e.message)}}),_.forEach(Memory.flags,(e,t)=>{try{Game.flags[t]||this.stale.push(t)}catch(e){Util.logError(e.stack||e.message)}}),!!this.specialFlag(!0))),this.run=(()=>{this.list.forEach(e=>{try{if(!e.cloaking||0==e.cloaking){const t=Game.flags[e.name];Flag.found.trigger(t)}}catch(e){Util.logError(e.stack||e.message)}}),this.stale.forEach(e=>Flag.FlagRemoved.trigger(e))}),this.cleanup=(()=>{this.stale.forEach(e=>delete Memory.flags[e])}),this.flagFilter=(e=>{if(!e)return;let t;return t=e.filter?_.clone(e.filter):{color:e.color,secondaryColor:e.secondaryColor}}),this.findName=((e,t,r=!0,o,i)=>{let a,s=this.list;if(!e||0===s.length)return null;if(t instanceof Room&&(t=t.getPositionAt(25,25)),"function"==typeof e)a=(o=>{if(e(o)&&0==o.cloaking){if(!r)return!0;if(t&&t.roomName&&o.roomName===t.roomName)return!0}return!1});else if(a=this.flagFilter(e),_.assign(a,{cloaking:"0"}),r&&t&&t.roomName){const e=Game.rooms[t.roomName];e?s=e.flags:_.assign(a,{roomName:t.roomName})}let n=_.filter(s,a);if(0===n.length)return null;if(1===n.length)return n[0].name;if(t&&t.roomName){let e=e=>{let r=0,a=Util.routeRange(t.roomName,e.roomName);return r=0===a?_.max([Math.abs(e.x-t.x),Math.abs(e.y-t.y)]):50*a,o&&(r=o(r,e,i)),e.valid=r<1/0,r},r=_.min(n,e);return r.valid?r.name:null}return n[0].name}),this.find=((e,t,r=!0,o,i)=>{t instanceof Room&&(t=t.getPositionAt(25,25));let a=this.findName(e,t,r,o,i);return null===a?null:Game.flags[a]}),this.removeFromDir=(e=>{let t=this.list.indexOf(t=>t.name===e);t>-1&&(this.list=this.list.splice(t,1))}),this.count=((e,t,r=!0)=>{let o=this.list;if(!e||0===this.list.length)return 0;t instanceof Room&&(t=t.getPositionAt(25,25));let i=this.flagFilter(e);if(r&&t&&t.roomName){const e=Game.flags[t.roomName];e?o=e.flags:_.assign(i,{roomName:t.roomName})}return _.countBy(o,i).true||0}),this.filter=((e,t,r=!0)=>{if(!e||0===this.list.length)return[];let o,i=this.list;if(t instanceof Room&&(t=t.getPositionAt(25,25)),Array.isArray(e))o=(o=>{if(r&&t&&t.roomName&&o.roomName!==t.roomName)return!1;for(let t=0;t<e.length;t++)if(this.compare(e[t],o))return!0;return!1});else if(o=this.flagFilter(e),r&&t&&t.roomName){const e=Game.rooms[t.roomName];e?i=e.flags:_.assign(o,{roomName:t.roomName})}return _.filter(i,o)}),this.rangeMod=((e,t,r)=>{let o,i=r&&r.rangeModPerCrowd?r.rangeModPerCrowd:20,a=r?r.rangeModByType:null,s=Game.flags[t.name];return o=s.targetOf?a?_.countBy(s.targetOf,"creepType")[a]||0:s.targetOf.length:0,e+o*i}),this.exploitMod=((e,t,r)=>{if(e>100)return 1/0;let o=Game.flags[t.name];if(o.room){if(o.room.my)return 1/0;let t=o.targetOf?_.sum(o.targetOf.map(e=>"privateer"!=e.creepType||e.creepName==r?0:e.carryCapacityLeft)):0;return o.room.sourceEnergyAvailable<=t?1/0:e*e/(o.room.sourceEnergyAvailable-t)}return e}),this.hasInvasionFlag=(()=>(_.isUndefined(this._hasInvasionFlag)&&(this._hasInvasionFlag=null!=this.findName(FLAG_COLOR.invade)||null!=this.findName(FLAG_COLOR.destroy)),this._hasInvasionFlag)),this.compare=((e,t)=>e.color===t.color&&e.secondaryColor===t.secondaryColor),this.flagType=(e=>{if(this.isSpecialFlag(e))return"_OCS";for(const t in FLAG_COLOR){const r=FLAG_COLOR[t];if(this.compare(e,r))return t;for(const o in r){const i=r[o];if(this.compare(e,i))return`${t}.${o}`}}return Util.logError(`Unknown flag type for flag: ${e?e.name:"undefined flag"}.`),"undefined"}),this.specialFlag=(e=>{const t=Game.flags._OCS;if(e){if(!t)return _(Game.rooms).values().some(e=>(e.getPositionAt(49,49).newFlag({color:COLOR_WHITE,secondaryColor:COLOR_PURPLE},"_OCS"),!0));"W0N0"!==t.pos.roomName&&t.setPosition(new RoomPosition(49,49,"W0N0"))}return t}),this.isSpecialFlag=(e=>"_OCS"===e.name)}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(8);t.default=new class extends o.Component{constructor(){super(...arguments),this.cache={},this.runCache={},this.tasks=[],this.extend=(()=>{this.tasks=[Task.attackController,Task.claim,Task.defense,Task.delivery,Task.guard,Task.labTech,Task.mining,Task.pioneer,Task.reputation,Task.reserve,Task.robbing,Task.safeGen,Task.scheduler]}),this.fresh=(()=>{this.tasks.forEach(e=>{e.fresh&&e.fresh()})}),this.register=(()=>{this.tasks.forEach(e=>{e.register&&e.register(),e.run&&!this.runCache[e.name]&&(this.runCache[e.name]={run:e.run}),e.handleFlagFound&&Flag.found.on(t=>e.handleFlagFound(t)),e.handleFlagRemoved&&Flag.FlagRemoved.on(t=>e.handleFlagRemoved(t)),e.handleSpawningStarted&&Creep.spawningStarted.on(t=>e.handleSpawningStarted(t)),e.handleSpawningCompleted&&Creep.spawningCompleted.on(t=>e.handleSpawningCompleted(t)),e.handleCreepDied&&(Creep.predictedRenewal.on(t=>e.handleCreepDied(t.name)),Creep.died.on(t=>e.handleCreepDied(t))),e.handleCreepError&&Creep.error.on(t=>e.handleCreepError(t)),e.handleNewInvader&&Room.newInvader.on(t=>e.handleNewInvader(t)),e.handleKnownInvader&&Room.knownInvader.on(t=>e.handleKnownInvader(t)),e.handleGoneInvader&&Room.goneInvader.on(t=>e.handleGoneInvader(t)),e.handleRoomDied&&Room.collapsed.on(t=>e.handleRoomDied(t))})}),this.run=(()=>{_.forEach(this.runCache,(e,t)=>{try{e.run()}catch(e){console.log(`Error executing Task "${t}"<br>${e.stack||e.toString()}`)}})}),this.cleanup=((e,t,r)=>{this.removeQueued(this.memory(t,r),e),this.clearMemory(t,r)}),this.memory=((e,t)=>{const r=Util.get(Memory,["tasks",e,t],{});return delete r.queuedValid,delete r.runningValid,delete r.spawningValid,r}),this.removeQueued=((e,t)=>{const r=e=>{if(!_.isUndefined(e))for(const t of e){const e=Game.rooms[t.room];for(const r of["spawnQueueLow","spawnQueueMedium","spawnQueueHigh"]){const o=e[r],i=_.findIndex(o,{name:t.name});if(i>=0){o.splice(i,1);break}}}};if(t)for(const o of t)r(e[o]);else r(e)}),this.clearMemory=((e,t)=>{Memory.tasks[e]&&Memory.tasks[e][t]&&delete Memory.tasks[e][t]}),this.cache=((e,t)=>(this.cache[e]||(this.cache[e]={}),this.cache[e][t]||(this.cache[e][t]={}),this.cache[e][t])),this.clearCache=((e,t)=>{this.cache[e]&&this.cache[e][t]&&delete this.cache[e][t]}),this.spawn=((e,t,r,o)=>{let i=r.explicit?Game.rooms[r.explicit]:Room.findSpawnRoom(r);if(!i)return null;t||(t={}),!t.room&&r.targetRoom&&(t.room=r.targetRoom);let a={parts:Creep.compileBody(i,e),name:`${e.name||e.behaviour}-${t.targetName}`,behaviour:e.behaviour,destiny:t,queueRoom:i.name};return 0===a.parts.length?(Util.logSystem(Util.dye(CRAYON.error,`${t.task} task tried to queue a zero parts body ${e.behaviour} creep. Aborted.`)),null):((i["spawnQueue"+e.queue]||i.spawnQueueLow).push(a),o&&o(a),a)}),this.addToQueue=((e,t,r)=>{if(t.link&&(t={targetRoom:t}),!t.targetRoom)return;const o={};return o.targetName=r?r.name||r.id:t.targetRoom,this.spawn(e,o,t)}),this.forceSpawn=((e,t,r)=>{if(t.link&&(t={targetRoom:t}),!t.targetRoom)return;const o=t.explicit?Game.rooms[t.explicit]:Room.findSpawnRoom(t);if(!o)return;const i={};i.targetName=r?r.name||r.id:t.targetRoom;const a=Creep.compileBody(o,e);if(!a.length)return;const s={parts:a,destiny:i,name:`${e.name||e.behaviour}-${i.targetName}`,behaviour:e.behaviour,queueRoom:o.name};return o.spawnQueueHigh.unshift(s),s}),this.validateQueued=((e,t,r,o={})=>{const i=o.subKey?"queued."+o.subKey:"queued",a=o.subKey?"nextQueuedCheck."+o.subKey:"nextQueuedCheck",s=Util.get(e,i,[]);let n=_.get(e,a,0);if(s.length&&(!o.checkValid||Game.time>n)){const t=o.queues||["Low"],r=[],l=e=>{if(!e)return;const o=Game.rooms[e.room];for(const i of t)if(o["spawnQueue"+i].some(t=>t.name===e.name)){r.push(e);break}};s.forEach(l),_.set(e,i,r),n=Game.time+50,Util.set(e,a,n,!1)}else 0===s.length&&(o.subKey&&e.nextQueuedCheck?delete e.nextQueuedCheck[o.subKey]:delete e.nextQueuedCheck);const l=_.get(t.memory,["nextCheck",r],1/0);t&&n-Game.time>0&&n<l&&_.set(t.memory,["nextCheck",r],n)}),this.validateSpawning=((e,t,r,o={})=>{const i=o.subKey?"spawning."+o.subKey:"spawning",a=o.subKey?"nextSpawnCheck."+o.subKey:"nextSpawnCheck",s=Util.get(e,i,[]);let n=_.get(e,a,0);if(s.length&&(!o.checkValid||Game.time>n)){const t=[];let r;const l=e=>{if(!e)return;const o=Game.spawns[e.spawn];o&&(o.spawning&&o.spawning.name===e.name||o.newSpawn&&o.newSpawn.name===e.name)&&(r=!r||o.spawning.remainingTime<r?o.spawning.remainingTime:r,t.push(e))};s.forEach(l),_.set(e,i,t),r?(n=Game.time+r,Util.set(e,a,n,!1)):o.subKey&&e.nextSpawnCheck?delete e.nextSpawnCheck[o.subKey]:delete e.nextSpawnCheck}const l=_.get(t.memory,["nextCheck",r],1/0);t&&n-Game.time>0&&n<l&&_.set(t.memory,["nextCheck",r],n)}),this.validateRunning=((e,t,r,o={})=>{const i=o.subKey?"running."+o.subKey:"running",a=o.subKey?"nextRunningCheck."+o.subKey:"nextRunningCheck",s=Util.get(e,i,[]),n=o.roomName;let l=_.get(e,a,0);if(n&&s.length&&(!o.checkValid||Game.time>l)){const t=o.deadCreep||"",r=[];let m;const c=e=>{if(!e)return;const o=e.name||e,i=Game.creeps[o];if(!i||!i.data)return;let a;if(a=i.data.predictedRenewal?i.data.predictedRenewal:i.data.spawningTime?i.data.spawningTime+50*Util.routeRange(i.data.homeRoom,n):50*(Util.routeRange(i.data.homeRoom,n)+1),i.name!==t&&i.ticksToLive>a){const t=i.ticksToLive-a;m=!m||t<m?t:m,r.push(e)}};s.forEach(c),_.set(e,i,r),m?(l=Game.time+Math.min(TASK_CREEP_CHECK_INTERVAL,m),Util.set(e,a,l,!1)):o.subKey&&e.nextRunningCheck?delete e.nextRunningCheck[o.subKey]:delete e.nextRunningCheck}const m=_.get(t.memory,["nextCheck",r],1/0);t&&l-Game.time>0&&l<m&&_.set(t.memory,["nextCheck",r],l)}),this.validateAll=((e,t,r,o={})=>{if(_.isUndefined(o.roomName))return Util.logError("Task.validateAll","roomName undefined"+t+o.subKey);this.validateQueued(e,t,r,o),this.validateSpawning(e,t,r,o),this.validateRunning(e,t,r,o)}),this.forceCreepCheck=((e,t)=>{_.set(e.memory,["nextCheck",t],Game.time)}),this.nextCreepCheck=((e,t)=>{const r=_.get(e.memory,["nextCheck",t]);return!(r&&Game.time<r||(_.set(e.memory,["nextCheck",t],Game.time+TASK_CREEP_CHECK_INTERVAL),0))})}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(1);t.default=new class extends o.TaskComponent{constructor(){super("guard"),this.handleFlagFound=(e=>{e.compareTo(FLAG_COLOR.defense)&&Task.nextCreepCheck(e,this.name)&&(Util.set(e.memory,"task",this.name),this.checkForRequiredCreeps(e))}),this.checkForRequiredCreeps=(e=>{let t=this.memory(e);Task.validateAll(t,e,this.name,{roomName:e.pos.roomName,checkValid:!0}),t.queued.length+t.spawning.length+t.running.length<1&&Task.spawn(this.creep.guard,{task:"guard",targetName:e.name,flagName:e.name},{targetRoom:e.pos.roomName,minEnergyCapacity:200,rangeRclRatio:1.8,allowTargetRoom:!0},t=>{this.memory(Game.flags[t.destiny.targetName]).queued.push({room:t.queueRoom,name:t.name,targetName:e.name})})}),this.handleSpawningStarted=(e=>{if(!e.destiny||!e.destiny.task||"guard"!=e.destiny.task)return;let t=Game.flags[e.destiny.flagName];if(t){let r=this.memory(t);r.spawning.push(e),Task.validateQueued(r,t,this.name)}}),this.handleSpawningCompleted=(e=>{if(!e.data||!e.data.destiny||!e.data.destiny.task||"guard"!=e.data.destiny.task)return;let t=Game.flags[e.data.destiny.flagName];if(t){e.data.predictedRenewal=e.data.spawningTime+50*Util.routeRange(e.data.homeRoom,t.pos.roomName);let r=this.memory(t);r.running.push(e.name),Task.validateSpawning(r,t,this.name)}}),this.handleCreepDied=(e=>{let t=Memory.population[e];if(!t||!t.destiny||!t.destiny.task||"guard"!=t.destiny.task)return;let r=Game.flags[t.destiny.flagName];if(r){const t=this.memory(r);Task.validateRunning(t,r,this.name,{roomName:r.pos.roomName,deadCreep:e})}}),this.memory=(e=>(e.memory.tasks||(e.memory.tasks={}),e.memory.tasks.guard||(e.memory.tasks.guard={queued:[],spawning:[],running:[]}),e.memory.tasks.guard)),this.minControllerLevel=3,this.creep={guard:{fixedBody:[RANGED_ATTACK,MOVE],multiBody:{[HEAL]:1,[MOVE]:2,[RANGED_ATTACK]:2,[TOUGH]:1},name:"guard",behaviour:"ranger",queue:"Low"}}}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(1);t.default=new class extends o.TaskComponent{constructor(){super("defense"),this.handleNewInvader=(e=>{if(SPAWN_DEFENSE_ON_ATTACK&&!DEFENSE_BLACKLIST.includes(e.pos.roomName)){if(console.log(e.room.my,e.room.reserved),!e.room.my&&!e.room.reserved){let t=e=>Flag.compare(e,FLAG_COLOR.invade.exploit)||e.color==(FLAG_COLOR.claim.color||FLAG_COLOR.claim.mining);if(!Flag.find(t,e.pos,!0))return}e.room.defenseLevel.sum>e.room.hostileThreatLevel?console.log("room can handle that"):e.room.hostiles.forEach(this.orderDefenses)}}),this.handleGoneInvader=(e=>{if(!Game.getObjectById(e)){let t=this.memory(e);if(t&&t.defender){let r=t=>{let r=Memory.rooms[t.spawnRoom];if(r&&r.spawnQueueHigh){let t=t=>t.destiny&&"defense"===t.destiny.task&&t.destiny.invaderId===e,o=r.spawnQueueHigh.findIndex(t);o>-1&&r.spawnQueueHigh.splice(o,1)}};t.defender.forEach(r)}Task.clearMemory("defense",e)}}),this.handleCreepDied=(e=>{let t=Memory.population[e];if(!(t&&t.destiny&&t.destiny.task&&"defense"==t.destiny.task&&t.destiny.invaderId))return;let r=Game.getObjectById(t.destiny.invaderId);if(!r)return;let o=this.memory(t.destiny.invaderId);if(o.defender){let e=e=>e.order===t.destiny.order,r=o.defender.findIndex(e);r>-1&&o.defender.splice(r,1)}this.orderDefenses(r)}),this.memory=(e=>Task.memory("defense",e)),this.orderDefenses=(e=>{let t=e.id,r=e.threat,o=this.memory(t);if(o.defender){let e=e=>r-=e.threat;o.defender.forEach(e)}else o.defender=[];for(;r>0;){let o=Util.guid();this.creep.defender.queue="High",this.creep.defender.minThreat=1.1*r;let i=Task.spawn(this.creep.defender,{task:"defense",targetName:t,invaderId:t,spottedIn:e.pos.roomName,order:o},{targetRoom:e.pos.roomName,maxRange:4,minEnergyCapacity:800,allowTargetRoom:!0},e=>{this.memory(t).defender.push({spawnRoom:e.queueRoom,order:e.destiny.order}),DEBUG&&Util.logSystem(e.queueRoom,`Defender queued for hostile creep ${e.destiny.order} in ${e.destiny.spottedIn}`)});if(!i)return void((TRACE||DEBUG)&&Util.trace("Task",{task:"defense",invaderId:t,targetRoom:e.pos.roomName},"Unable to spawn. Invader will not get handled!"));{let e=Creep.bodyThreat(i.parts);r-=e}}}),this.nextAction=(e=>{if(Creep.action.defending.isValidAction(e)&&Creep.action.defending.isAddableAction(e)&&Creep.action.defending.assign(e))return;let t=Game.getObjectById(e.data.destiny.invaderId);if(t&&e.pos.roomName===t.pos.roomName)return void Creep.action.travelling.assign(e,t);let r=Game.rooms[e.data.destiny.spottedIn];if(!r||r.hostiles.length>0)return Creep.action.travelling.assignRoom(e,e.data.destiny.spottedIn);let o=e.room.adjacentRooms.find(e=>Game.rooms[e]&&Game.rooms[e].hostiles.length>0);if(o)return Creep.action.travelling.assignRoom(e,o);let i=Game.spawns[e.data.motherSpawn];i&&Creep.action.recycling.assign(e,i)}),this.creep={defender:{fixedBody:[RANGED_ATTACK,MOVE],multiBody:{[HEAL]:1,[MOVE]:2,[RANGED_ATTACK]:2,[TOUGH]:1},name:"defender",behaviour:"ranger"}}}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(1);t.default=new class extends o.TaskComponent{constructor(){super("mining"),this.default={name:`default-${this.name}`},this.reserve={name:`reserve-${this.name}`,spawnParams:e=>{const t=this._carryPopulation(e.pos.roomName);return t<REMOTE_RESERVE_HAUL_CAPACITY?(DEBUG&&TRACE&&Util.trace("Task",{flagName:e.name,pos:e.pos,population:t,spawnParams:"population",[this.name]:"spawnParams",Task:this.name}),{count:0,priority:"Low"}):Task.reserve.state.default.spawnParams(e)}},this.miner={name:`miner-${this.name}`,setup:e=>this.setupCreep(e,this.creep.miner),shouldSpawn:(e,t)=>e<t},this.hauler={name:`hauler-${this.name}`,ept:e=>{const t=Game.rooms[e];return t?10*t.sources.length:20},homeRoomName:e=>{const t=this.memory(e);return t.storageRoom?t.storageRoom:Room.bestSpawnRoomFor(e).name},spawnRoom:(e,t)=>Room.findSpawnRoom({targetRoom:e,minEnergyCapacity:t||500}),maxWeight:(e,t,r,o,i)=>{t||(t=this.state.hauler.homeRoomName(e)),r||(r=this.memory(e));const a=o?[]:_.map(r.running.remoteHauler,e=>Game.creeps[e]),s=i?[]:_.union(r.queued.remoteHauler,r.spawning.remoteHauler),n=(Game.rooms[e],Util.routeRange(e,t)),l=this.state.hauler.ept(e),m=_.filter(a,e=>!this.needsReplacement(e)),c=_.sum(m,e=>e&&e.data&&e.data.body?e.data.body.carry:5),u=_.sum(s,e=>e&&e.body?e.body.carry:5),d=l*n*2+(r.carryParts||0)-c-u,h=this._haulerCarryToWeight(d);return DEBUG&&TRACE&&Util.trace("Task",{Task:this.name,room:e,homeRoom:t,haulers:a.length+s.length,ept:l,travel:n,existingCarry:c,queuedCarry:u,neededCarry:d,maxWeight:h,[this.name]:"maxWeight"}),h}},this.handleFlagRemoved=(e=>{const t=Memory.flags[e];if(t&&t.task===this.name&&t.roomName){const e=Flag.filter(FLAG_COLOR.claim.mining,new RoomPosition(25,25,t.roomName),!0);if(e&&e.length>0)return;Task.cleanup(["remoteMiner","remoteWorker","remoteHauler"],this.name,t.roomName)}}),this.handleFlagFound=(e=>{e.compareTo(FLAG_COLOR.claim.mining)&&Task.nextCreepCheck(e,this.name)&&(Util.set(e.memory,"roomName",e.pos.roomName),Util.set(e.memory,"task",this.name),this.checkForRequiredCreeps(e))}),this.handleSpawningStarted=(e=>{if(!e.destiny||!e.destiny.task||e.destiny.task!=this.name)return;const t=this.memory(e.destiny.room),r=Game.flags[e.destiny.targetName];if(r){const o=_.find(this.creep,{behaviour:e.destiny.type}).queue;Task.validateQueued(t,r,this.name,{subKey:e.destiny.type,queues:[o]}),e.body&&(e.body=_.countBy(e.body)),t.spawning[e.destiny.type].push(e)}}),this.handleSpawningCompleted=(e=>{if(!e.data.destiny||!e.data.destiny.task||e.data.destiny.task!=this.name)return;e.data.destiny.homeRoom&&(e.data.homeRoom=e.data.destiny.homeRoom);const t=Game.flags[e.data.destiny.targetName];if(t){e.data.predictedRenewal=e.data.spawningTime+50*Util.routeRange(e.data.homeRoom,e.data.destiny.room);const r=this.memory(e.data.destiny.room);r.running[e.data.destiny.type].push(e.name),Task.validateSpawning(r,t,this.name,{roomName:e.data.destiny.room,subKey:e.data.destiny.type})}}),this.handleCreepDied=(e=>{const t=Memory.population[e];if(!t||!t.destiny||!t.destiny.task||t.destiny.task!=this.name)return;const r=Game.flags[t.destiny.targetName];if(r){const o=this.memory(t.destiny.room);Task.validateRunning(o,r,this.name,{subKey:t.creepType,roomName:t.destiny.room,deadCreep:e})}}),this.needsReplacement=(e=>!e||(e.ticksToLive||CREEP_LIFE_TIME)<(e.data.predictedRenewal||0)),this.checkForRequiredCreeps=(e=>{const t=e.pos.roomName,r=Game.rooms[t],o=this.memory(t);let i;i=r?r.sources.length:Memory.rooms[t]&&Memory.rooms[t].sources?Memory.rooms[t].sources.length:1;const a=r=>{const i=_.find(this.creep,{behaviour:r}).queue;return Task.validateAll(o,e,this.name,{roomName:t,subKey:r,queues:[i],checkValid:!0,task:this.name}),o.queued[r].length+o.spawning[r].length+o.running[r].length},s=a("remoteHauler"),n=a("remoteMiner"),l=a("remoteWorker");if(DEBUG&&TRACE&&Util.trace("Task",{Task:this.name,flagName:e.name,sourceCount:i,haulerCount:s,minerCount:n,workerCount:l,[this.name]:"Flag.found"},"checking flag@",e.pos),this.state.miner.shouldSpawn(n,i)){DEBUG&&TRACE&&Util.trace("Task",{Task:this.name,room:t,minerCount:n,minerTTLs:_.map(_.map(o.running.remoteMiner,e=>Game.creeps[e]),"ticksToLive"),[this.name]:"minerCount"});const r=this.state.miner.setup(t);for(let o=n;o<i;o++)Task.spawn(r,{task:this.name,targetName:e.name,type:r.behaviour},{targetRoom:t,minEnergyCapacity:r.minEnergyCapacity,rangeRclRatio:1},e=>{this.memory(e.destiny.room).queued[e.behaviour].push({room:e.queueRoom,name:e.name})})}const m=Math.ceil(o.running.remoteMiner.length*REMOTE_HAULER.MULTIPLIER);if(s<m&&(!o.capacityLastChecked||Game.time-o.capacityLastChecked>TASK_CREEP_CHECK_INTERVAL))for(let r=s;r<m;r++){let i=r>=1&&REMOTE_HAULER.MIN_WEIGHT;const a=this.state.hauler.spawnRoom(t,i);if(!a)break;const s=REMOTE_HAULER.REHOME?this.state.hauler.homeRoomName(t):a.name;let n=this.state.hauler.maxWeight(t,s,o);if(!n||!REMOTE_HAULER.ALLOW_OVER_CAPACITY&&n<i){o.capacityLastChecked=Game.time;break}_.isNumber(REMOTE_HAULER.ALLOW_OVER_CAPACITY)?(n=Math.max(n,REMOTE_HAULER.ALLOW_OVER_CAPACITY),i=i&&Math.min(REMOTE_HAULER.MIN_WEIGHT,n)):REMOTE_HAULER.ALLOW_OVER_CAPACITY&&(n=Math.max(n,REMOTE_HAULER.MIN_WEIGHT),i=i&&Math.min(REMOTE_HAULER.MIN_WEIGHT,n));const l=_.create(this.creep.hauler);l.maxWeight=n,i&&(l.minWeight=i),Task.spawn(l,{task:this.name,targetName:e.name,type:this.creep.hauler.behaviour,homeRoom:s},{targetRoom:t,explicit:a.name},e=>{this.memory(e.destiny.room).queued[e.behaviour].push({room:e.queueRoom,name:e.name,body:_.countBy(e.parts)})})}if(r&&r.myConstructionSites.length>0&&l<REMOTE_WORKER_MULTIPLIER)for(let r=l;r<REMOTE_WORKER_MULTIPLIER;r++)Task.spawn(this.creep.worker,{task:this.name,targetName:e.name,type:this.creep.worker.behaviour},{targetRoom:t,minEnergyCapacity:600},e=>{this.memory(e.destiny.room).queued[e.behaviour].push({room:e.queueRoom,name:e.name})})}),this.findSpawning=((e,t)=>{const r=[];return _.forEach(Game.spawns,o=>{if(o.spawning&&(_.includes(o.spawning.name,t)||o.newSpawn&&_.includes(o.newSpawn.name,t))){const t=Population.getCreep(o.spawning.name);if(t&&t.destiny.room===e){const e={spawn:o.name,name:o.spawning.name,destiny:t.destiny};r.push(e)}}}),r}),this.findRunning=((e,t)=>{const r=[];return _.forEach(Game.creeps,o=>{!o.spawning&&o.data.creepType===t&&o.data&&o.data.destiny&&o.data.destiny.room===e&&r.push(o.name)}),r}),this.memory=(e=>{const t=Task.memory(this.name,e);return t.hasOwnProperty("queued")||(t.queued={remoteMiner:[],remoteHauler:[],remoteWorker:[]}),t.hasOwnProperty("spawning")||(t.spawning={remoteMiner:this.findSpawning(e,"remoteMiner"),remoteHauler:this.findSpawning(e,"remoteHauler"),remoteWorker:this.findSpawning(e,"remoteWorker")}),t.hasOwnProperty("running")||(t.running={remoteMiner:this.findRunning(e,"remoteMiner"),remoteHauler:this.findRunning(e,"remoteHauler"),remoteWorker:this.findRunning(e,"remoteWorker")}),t.hasOwnProperty("nextSpawnCheck")||(t.nextSpawnCheck={}),t.queued.miner&&(t.queued.remoteMiner=t.queued.miner,delete t.queued.miner),t.queued.hauler&&(t.queued.remoteHauler=t.queued.hauler,delete t.queued.hauler),t.queued.worker&&(t.queued.remoteWorker=t.queued.worker,delete t.queued.worker),t}),this.setupCreep=((e,t)=>{switch(t.behaviour){default:return t;case"remoteMiner":const r=this.memory(e);if(!r.harvestSize)return t;const o=e=>e===WORK,i=_.reject(t.fixedBody,o),a=_.sum(t.fixedBody,o)+r.harvestSize;return _.create(t,{fixedBody:_.times(a,_.constant(WORK)).concat(_.times(Math.ceil(.5*r.harvestSize),_.constant(MOVE))).concat(i),moveBalance:r.harvestSize%2*-.5})}}),this._carryPopulation=((e,t)=>1-this.state.hauler.maxWeight(e,t,void 0,!1,!0)/this.state.hauler.maxWeight(e,t,void 0,!0,!0)),this._haulerCarryToWeight=(e=>{if(!e||e<0)return 0;const t=_.max([0,e-5]);return 500+150*_.ceil(.5*t)}),this.getFlag=(e=>Flag.find(FLAG_COLOR.claim.mining,new RoomPosition(25,25,e))),this.carry=((e,t)=>{const r=this.memory(e);r.carryParts=(r.carryParts||0)+(t||0);const o=Math.round(100*this._carryPopulation(e));return t&&(Task.forceCreepCheck(this.getFlag(e),this.name),delete r.capacityLastChecked),`Task.${this.name}: hauler carry capacity for ${e} ${r.carryParts>=0?"increased":"decreased"} by ${Math.abs(r.carryParts)}. Currently at ${o}% of desired capacity`}),this.harvest=((e,t)=>{const r=this.memory(e);return r.harvestSize=(r.harvestSize||0)+(t||0),`Task.${this.name}: harvesting work capacity for ${e} ${r.harvestSize>=0?"increased":"decreased"} by ${Math.abs(r.harvestSize)} per miner.`}),this.storage=((e,t)=>{Game.rooms[e];const r=this.memory(e);if(t){const o=r.storageRoom;return r.storageRoom=t,`Task.${this.name}: room ${e}, now sending haulers to ${t}, (was ${o})`}if(r.storageRoom){if(!1===t){const t=r.storageRoom;return delete r.storageRoom,`Task.${this.name}: room ${e}, cleared custom storage room (was ${t})`}return`Task.${this.name}: room ${e}, sending haulers to ${r.storageRoom}`}return`Task.${this.name}: room ${e}, no custom storage destination`}),this.state={default:this.default,reserve:this.reserve,miner:this.miner,hauler:this.hauler},this.minControllerLevel=2,this.creep={miner:{fixedBody:{[MOVE]:1,[WORK]:5},multiBody:[MOVE,MOVE,WORK,CARRY],maxMulti:1,minEnergyCapacity:550,behaviour:"remoteMiner",queue:"Medium"},hauler:{fixedBody:{[CARRY]:5,[MOVE]:3,[WORK]:1},multiBody:[CARRY,CARRY,MOVE],behaviour:"remoteHauler",queue:"Low"},worker:{fixedBody:{[CARRY]:3,[MOVE]:4,[WORK]:4},multiBody:{[CARRY]:1,[MOVE]:2,[WORK]:2},maxMulti:3,behaviour:"remoteWorker",queue:"Low"}}}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(1);t.default=new class extends o.TaskComponent{constructor(){super("claim"),this.handleFlagFound=(e=>{e.compareTo(FLAG_COLOR.claim)&&Task.nextCreepCheck(e,this.name)&&(Util.set(e.memory,"task",this.name),this.checkForRequiredCreeps(e))}),this.checkForRequiredCreeps=(e=>{let t=this.memory(e);Task.validateAll(t,e,this.name,{roomName:e.pos.roomName,checkValid:!0}),t.queued.length+t.spawning.length+t.running.length<1&&Task.spawn(this.creep.claimer,{task:"claim",targetName:e.name,flagName:e.name},{targetRoom:e.pos.roomName,minEnergyCapacity:650},t=>{this.memory(Game.flags[t.destiny.targetName]).queued.push({room:t.queueRoom,name:t.name,targetName:e.name})})}),this.handleSpawningStarted=(e=>{if(!e.destiny||!e.destiny.task||"claim"!=e.destiny.task)return;let t=Game.flags[e.destiny.flagName];if(t){let r=this.memory(t);r.spawning.push(e),Task.validateQueued(r,t,this.name)}}),this.handleSpawningCompleted=(e=>{if(!e.data||!e.data.destiny||!e.data.destiny.task||"claim"!=e.data.destiny.task)return;let t=Game.flags[e.data.destiny.flagName];if(t){e.data.predictedRenewal=e.data.spawningTime+50*Util.routeRange(e.data.homeRoom,t.pos.roomName);let r=this.memory(t);r.running.push(e.name),Task.validateSpawning(r,t,this.name)}}),this.handleCreepDied=(e=>{let t=Memory.population[e];if(!t||!t.destiny||!t.destiny.task||"claim"!=t.destiny.task)return;let r=Game.flags[t.destiny.flagName];if(r){const t=this.memory(r);Task.validateRunning(t,r,this.name,{roomName:r.pos.roomName,deadCreep:e})}}),this.memory=(e=>(e.memory.tasks||(e.memory.tasks={}),e.memory.tasks.claim||(e.memory.tasks.claim={queued:[],spawning:[],running:[]}),e.memory.tasks.claim)),this.nextAction=(e=>{let t=[Creep.action.claiming,Creep.action.recycling];for(let r=0;r<t.length;r++){let o=t[r];if(o.isValidAction(e)&&o.isAddableAction(e)&&o.assign(e))return}}),this.minControllerLevel=3,this.creep={claimer:{fixedBody:[CLAIM,MOVE],multiBody:[],name:"claimer",behaviour:"claimer",queue:"Low"}}}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(1);t.default=new class extends o.TaskComponent{constructor(){super("reserve"),this.VALID_RESERVATION=1e3,this.URGENT_RESERVATION=250,this.default={name:`default-${this.name}`,spawnParams:e=>{const t={count:0,queue:"Low"},r=!!e,o=r&&(Room.isControllerRoom(e.pos.roomName)||e.room&&e.room.controller);if(!r||!o)return DEBUG&&TRACE&&Util.trace("Task",{hasFlag:r,hasController:o,checkForRequiredCreeps:"skipping room, missing flag or controller",[this.name]:"checkForRequiredCreeps",Task:this.name}),t;if(e.room){e.memory.lastVisible=Game.time,e.memory.ticksToEnd=e.room.controller.reservation&&e.room.controller.reservation.ticksToEnd;const r=e.room.controller.reservation&&(e.room.controller.reservation.ticksToEnd>1e3||e.room.controller.reservation.username!==ME),o=!!e.room.controller.owner;if(o||r)return DEBUG&&TRACE&&Util.trace("Task",{validReservation:r,isOwned:o,checkForRequiredCreeps:"skipping room, reserved or owned",[this.name]:"checkForRequiredCreeps",Task:this.name}),t;const i=!e.room.controller.reservation||e.room.controller.reservation.ticksToEnd<250;if(t.count=1,i&&(t.queue="Medium"),DEBUG&&TRACE){const e=i?"urgent":" ";Util.trace("Task",{validReservation:r,isOwned:o,urgent:i,checkForRequiredCreeps:`sending${e}reserver`,[this.name]:"checkForRequiredCreeps",Task:this.name})}}else(_.isUndefined(e.memory.lastVisible)||Game.time-e.memory.lastVisible>(e.memory.ticksToEnd-250||250))&&(t.count=1,t.queue="Medium",DEBUG&&TRACE&&Util.trace("Task",{lastVisible:e.memory.lastVisible,tickToEnd:e.memory.ticksToEnd,checkForRequiredCreeps:"sending urgent reserver, no visibility",[this.name]:"checkForRequiredCreeps",Task:this.name}));return t}},this.handleFlagFound=(e=>{if((e.compareTo(FLAG_COLOR.claim.reserve)||e.compareTo(FLAG_COLOR.invade.exploit)||e.compareTo(FLAG_COLOR.claim.mining))&&(Room.isControllerRoom(e.pos.roomName)||e.room&&e.room.controller)){const t=this.memory(e);if(e.room){e.memory.lastVisible=Game.time,e.memory.ticksToEnd=e.room.controller.reservation&&e.room.controller.reservation.ticksToEnd;const r=_.get(e.memory,["nextCheck",this.name],1/0),o=Game.time+e.memory.ticksToEnd-this.VALID_RESERVATION;o<r&&!t.waitForCreeps&&(0===t.queued.length+t.spawning.length+t.running.length?_.set(e.memory,["nextCheck",this.name],o):t.waitForCreeps=!0)}Task.nextCreepCheck(e,this.name)&&(delete t.waitForCreeps,Util.set(e.memory,"task",this.name),this.checkForRequiredCreeps(e))}}),this.handleFlagFound=(e=>{if((e.compareTo(FLAG_COLOR.claim.reserve)||e.compareTo(FLAG_COLOR.invade.exploit)||e.compareTo(FLAG_COLOR.claim.mining))&&(Room.isControllerRoom(e.pos.roomName)||e.room&&e.room.controller)){const t=this.memory(e);if(e.room){e.memory.lastVisible=Game.time,e.memory.ticksToEnd=e.room.controller.reservation&&e.room.controller.reservation.ticksToEnd;const r=_.get(e.memory,["nextCheck",this.name],1/0),o=Game.time+e.memory.ticksToEnd-this.VALID_RESERVATION;o<r&&!t.waitForCreeps&&(0===t.queued.length+t.spawning.length+t.running.length?_.set(e.memory,["nextCheck",this.name],o):t.waitForCreeps=!0)}Task.nextCreepCheck(e,this.name)&&(delete t.waitForCreeps,Util.set(e.memory,"task",this.name),this.checkForRequiredCreeps(e))}}),this.checkForRequiredCreeps=(e=>{let t;e.compareTo(FLAG_COLOR.claim.mining)?t=Task.mining.state.reserve.spawnParams(e):e.compareTo(FLAG_COLOR.invade.exploit)?(t=this.state.default.spawnParams(e)).queue="Low":t=this.state.default.spawnParams(e);let r=this.memory(e);if(Task.validateAll(r,e,this.name,{roomName:e.pos.roomName,queues:["Low","Medium"],checkValid:!0}),"Low"!==t.queue&&1==r.queued.length){let e=Game.rooms[r.queued[0].room],t=(t,o)=>{if(t.targetName==r.queued[0].targetName){let t=e.spawnQueueLow.splice(o,1);return e.spawnQueueMedium.push(t),!0}return!1};e.spawnQueueLow.find(t)}r.queued.length+r.spawning.length+r.running.length<t.count&&(this.creep.reserver.queue=t.queue,Task.spawn(this.creep.reserver,{task:this.name,targetName:e.name},{targetRoom:e.pos.roomName,minEnergyCapacity:1300,maxRange:this.spawnRoomMaxRange},t=>{this.memory(Game.flags[t.destiny.targetName]).queued.push({room:t.queueRoom,name:t.name,targetName:e.name})}))}),this.handleSpawningStarted=(e=>{if(!e.destiny||!e.destiny.task||e.destiny.task!=this.name)return;let t=Game.flags[e.destiny.targetName];if(t){let r=this.memory(t);Task.validateQueued(r,t,this.name,{queues:["Low","Medium"]}),r.spawning.push(e)}}),this.handleSpawningCompleted=(e=>{if(!e.data||!e.data.destiny||!e.data.destiny.task||e.data.destiny.task!=this.name)return;let t=Game.flags[e.data.destiny.targetName];if(t){e.data.predictedRenewal=e.data.spawningTime+50*Util.routeRange(e.data.homeRoom,t.pos.roomName);let r=this.memory(t);Task.validateSpawning(r,t,this.name),r.running.push(e.name)}}),this.handleCreepDied=(e=>{let t=Memory.population[e];if(!t||!t.destiny||!t.destiny.task||t.destiny.task!=this.name)return;let r=Game.flags[t.destiny.targetName];if(r){const t=this.memory(r);Task.validateRunning(t,r,this.name,{roomName:r.pos.roomName,deadCreep:e})}}),this.nextAction=(e=>{if(e.data.destiny&&e.data.destiny.room!==e.room.name)return Creep.action.travelling.assignRoom(e,e.data.destiny.room);let t=[Creep.action.reserving,Creep.action.recycling];for(let r=0;r<t.length;r++){let o=t[r];if(o.isValidAction(e)&&o.isAddableAction(e)&&o.assign(e))break}DEBUG&&TRACE&&Util.trace("Task",{creepName:e.name,nextAction:e.action.name,[this.name]:"nextAction",Task:this.name})}),this.memory=(e=>{const t=Util.get(e.memory,["tasks","reserve"],{queued:[],spawning:[],running:[]});return delete t.valid,t}),this.state={default:this.default},this.spawnRoomMaxRange=6,this.creep={reserver:{fixedBody:{[CLAIM]:2,[MOVE]:2},multiBody:[CLAIM,MOVE],maxMulti:7,name:"reserver",behaviour:"claimer"}}}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(1);t.default=new class extends o.TaskComponent{constructor(){super("pioneer"),this.handleRoomDied=(e=>{if(e.population&&e.population.typeCount.collapseWorker)return;let t=!0;if(e.energyAvailable>199){e.spawnQueueHigh.splice(0,e.spawnQueueHigh.length);const r=this.creep.worker;t=!Task.spawn(r,{task:"collapseWorker",targetName:e.name,type:r.behaviour},{explicit:e.name})}t&&(Flag.find(FLAG_COLOR.claim.pioneer,e)||e.newFlag(FLAG_COLOR.claim.pioneer))}),this.handleFlagFound=(e=>{e.compareTo(FLAG_COLOR.claim.pioneer)&&Task.nextCreepCheck(e,this.name)&&(Util.set(e.memory,"task",this.name),this.checkForRequiredCreeps(e))}),this.checkForRequiredCreeps=(e=>{if(!e||e.room&&!e.room.my&&!e.room.reserved){if(!PIONEER_UNOWNED)return console.log("Pioneer room not owned",Util.stack());const t=e.room.owner||e.room.reservation;if(t&&!Task.reputation.isAlly(t))return Util.logError(`Pioneer target room owned by ${t}`)}let t=this.memory(e);if(Task.validateAll(t,e,this.name,{roomName:e.pos.roomName,subKey:"pioneer",checkValid:!0}),t.queued.length+t.spawning.length+t.running.length<1){const t=this.creep.pioneer;Task.spawn(t,{task:"pioneer",targetName:e.name,flagName:e.name,type:t.behaviour},{targetRoom:e.pos.roomName,minEnergyCapacity:400,rangeRclRatio:2},t=>{this.memory(Game.flags[t.destiny.targetName]).queued.push({room:t.queueRoom,name:t.name,targetName:e.name})})}}),this.handleSpawningStarted=(e=>{if(!e.destiny||!e.destiny.task||"pioneer"!=e.destiny.task)return;let t=Game.flags[e.destiny.flagName];if(t){let r=this.memory(t);r.spawning.push(e);const o=e.destiny.type,i=o?_.find(this.creep,{behaviour:o}).queue:["Low","High"];Task.validateQueued(r,t,this.name,{queues:[i]})}}),this.handleSpawningCompleted=(e=>{if(!e.data||!e.data.destiny||!e.data.destiny.task||"pioneer"!=e.data.destiny.task)return;let t=Game.flags[e.data.destiny.flagName];if(t){e.data.predictedRenewal=e.data.spawningTime+50*Util.routeRange(e.data.homeRoom,t.pos.roomName);let r=this.memory(t);r.running.push(e.name),Task.validateSpawning(r,t,this.name)}}),this.handleCreepDied=(e=>{let t=Memory.population[e];if(!t||!t.destiny||!t.destiny.task||"pioneer"!=t.destiny.task)return;let r=Game.flags[t.destiny.flagName];if(r){let t=this.memory(r);Task.validateRunning(t,r,this.name,{roomName:r.pos.roomName,deadCreep:e})}}),this.memory=(e=>(e.memory.tasks||(e.memory.tasks={}),e.memory.tasks.pioneer||(e.memory.tasks.pioneer={queued:[],spawning:[],running:[]}),e.memory.tasks.pioneer)),this.creep={pioneer:{fixedBody:{[CARRY]:2,[MOVE]:2,[WORK]:2},multiBody:[WORK,MOVE,CARRY],name:"pioneer",behaviour:"pioneer",queue:"Low"},worker:{fixedBody:[MOVE,CARRY,WORK],behaviour:"collapseWorker",queue:"High"}}}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(1);t.default=new class extends o.TaskComponent{constructor(){super("attackController"),this.handleFlagFound=(e=>{e.compareTo(FLAG_COLOR.invade.attackController)&&Task.nextCreepCheck(e,this.name)&&(Util.set(e.memory,"task",this.name),this.checkForRequiredCreeps(e))}),this.checkForRequiredCreeps=(e=>{const t=e.pos.roomName;Game.rooms[t];let r=this.memory(e);Task.validateAll(r,e,this.name,{roomName:t,checkValid:!0}),r.queued.length+r.spawning.length+r.running.length<1&&Task.spawn(this.creep.attackController,{task:"attackController",targetName:e.name},{targetRoom:e.pos.roomName,minEnergyCapacity:3250,maxRange:5},e=>{r.queued.push({room:e.queueRoom,name:e.name})})}),this.handleSpawningStarted=(e=>{if(!e.destiny||!e.destiny.task||"attackController"!=e.destiny.task)return;let t=Game.flags[e.destiny.targetName];if(t){let r=this.memory(t);r.spawning.push(e),Task.validateQueued(r,t,this.name)}}),this.handleSpawningCompleted=(e=>{if(!e.data||!e.data.destiny||!e.data.destiny.task||"attackController"!=e.data.destiny.task)return;let t=Game.flags[e.data.destiny.targetName];if(t){e.data.predictedRenewal=e.data.spawningTime+50*Util.routeRange(e.data.homeRoom,t.pos.roomName);let r=this.memory(t);r.running.push(e.name),Task.validateSpawning(r,t,this.name)}}),this.handleCreepDied=(e=>{let t=Memory.population[e];if(!t||!t.destiny||!t.destiny.task||"attackController"!=t.destiny.task)return;let r=Game.flags[t.destiny.targetName];if(r){const t=this.memory(r);Task.validateRunning(t,r,this.name,{roomName:r.pos.roomName,deadCreep:e})}}),this.memory=(e=>(e.memory.tasks||(e.memory.tasks={}),e.memory.tasks.attackController||(e.memory.tasks.attackController={queued:[],spawning:[],running:[]}),e.memory.tasks.attackController)),this.nextAction=(e=>{let t=[Creep.action.attackController,Creep.action.recycling];for(let r=0;r<t.length;r++){let o=t[r];if(o.isValidAction(e)&&o.isAddableAction(e)&&o.assign(e))return}}),this.creep={attackController:{fixedBody:[],multiBody:{[CLAIM]:5,[MOVE]:5},minMulti:1,maxMulti:4,name:"Atk-Contr",behaviour:"claimer",queue:"Low"}}}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(1);t.default=new class extends o.TaskComponent{constructor(){super("robbing"),this.default={name:`default-${this.name}`},this.robber={name:`robber-${this.name}`,homeRoom:e=>{const t=this.memory(e);return t.storageRoom?Game.rooms[t.storageRoom]:Room.bestSpawnRoomFor(e.pos.roomName)},spawnRoom:({roomName:e,minWeight:t})=>Room.findSpawnRoom({targetRoom:e,minEnergyCapacity:t||250})},this.checkFlag=(e=>!(e.room&&e.room.my)&&e.compareTo(FLAG_COLOR.invade.robbing)&&Task.nextCreepCheck(e,this.name)),this.handleFlagFound=(e=>{this.checkFlag(e)&&(Util.set(e.memory,"task",this.name),this.checkForRequiredCreeps(e))}),this.checkForRequiredCreeps=(e=>{let t=this.memory(e);Task.validateAll(t,e,this.name,{roomName:e.pos.roomName,checkValid:!0});const r=t.queued.length+t.spawning.length+t.running.length,o=e.pos.roomName;if(r<(t.numRobbers||2)){const t=this.robber.spawnRoom({roomName:o});if(!t)return;const r=ROBBER_REHOME?this.robber.homeRoom(e):t;Task.spawn(this.creep.robbing,{task:this.name,targetName:e.name,homeRoom:r.name},{targetRoom:o,explicit:t.name},e=>{this.memory(Game.flags[e.destiny.targetName]).queued.push({room:e.queueRoom,name:e.name})})}}),this.handleSpawningStarted=(e=>{if(!e.destiny||!e.destiny.task||"robbing"!=e.destiny.task)return;let t=Game.flags[e.destiny.targetName||e.destiny.flagName];if(t){let r=this.memory(t);r.spawning.push(e),Task.validateQueued(r,t,this.name)}}),this.handleSpawningCompleted=(e=>{if(!e.data||!e.data.destiny||!e.data.destiny.task||"robbing"!=e.data.destiny.task)return;e.data.destiny.homeRoom&&(e.data.homeRoom=e.data.destiny.homeRoom);let t=Game.flags[e.data.destiny.targetName||e.data.destiny.flagName];if(t){e.data.predictedRenewal=e.data.spawningTime+50*Util.routeRange(e.data.homeRoom,t.pos.roomName);let r=this.memory(t);r.running.push(e.name),Task.validateSpawning(r,t,this.name)}}),this.handleCreepDied=(e=>{let t=Memory.population[e];if(!t||!t.destiny||!t.destiny.task||"robbing"!=t.destiny.task)return;let r=Game.flags[t.destiny.targetName||t.destiny.flagName];if(r){const t=this.memory(r);Task.validateRunning(t,r,this.name,{roomName:r.pos.roomName,deadCreep:e})}}),this.memory=(e=>(e.memory.tasks||(e.memory.tasks={}),e.memory.tasks.robbing||(e.memory.tasks.robbing={queued:[],spawning:[],running:[],numRobbers:2}),e.memory.tasks.robbing)),this.nextAction=(e=>{let t=e.sum;if(e.pos.roomName==e.data.homeRoom){if(t>0){DEBUG&&TRACE&&Util.trace("Task",{creepName:e.name,pos:e.pos,nextAction:"storing?",robbing:"nextAction",Task:"robbing"});let r=[];if(e.carry.energy==t&&(r=e.room.structures.links.privateers),e.room.storage&&r.push(e.room.storage),e.room.structures.container&&(r=r.concat(e.room.structures.container.privateers)),r.length>0){let t=e.pos.findClosestByRange(r);if(t.structureType==STRUCTURE_STORAGE&&Creep.action.storing.assign(e,t))return;if(Creep.action.charging.assign(e,t))return}if(Creep.action.charging.assign(e))return;if(!e.room.ally&&Creep.action.storing.assign(e))return;if(Creep.action.dropping.assign(e))return;return void Creep.behaviour.worker.nextAction(e)}return Task[e.data.destiny.task].exploitNextRoom(e)?void(DEBUG&&TRACE&&Util.trace("Task",{creepName:e.name,pos:e.pos,nextAction:"travelling",robbing:"nextAction",Task:"robbing"})):(DEBUG&&TRACE&&Util.trace("Task",{creepName:e.name,pos:e.pos,nextAction:"working",robbing:"nextAction",Task:"robbing"}),void Creep.behaviour.worker.nextAction(e))}if(!e.flag||e.flag.pos.roomName!==e.pos.roomName)return DEBUG&&TRACE&&Util.trace("Task",{creepName:e.name,pos:e.pos,nextAction:"travelling2",robbing:"nextAction",Task:"robbing"}),void Task[e.data.destiny.task].exploitNextRoom(e);if(DEBUG&&TRACE&&Util.trace("Task",{creepName:e.name,pos:e.pos,nextAction:"robbing",robbing:"nextAction",Task:"robbing"}),e.sum<.4*e.carryCapacity){let t=[Creep.action.picking,Creep.action.robbing];for(let r=0;r<t.length;r++){let o=t[r];if(o.isValidAction(e)&&o.isAddableAction(e)&&o.assign(e))return}return e.flag&&(e.flag.cloaking=50),void Task[e.data.destiny.task].exploitNextRoom(e)}this.goHome(e)}),this.exploitNextRoom=(e=>{if(e.sum<.4*e.carryCapacity){let t;if(e.data.destiny&&(t=Game.flags[e.data.destiny.flagName]),t||(t=this.getFlag(e.data.homeRoom)),t)return this.gotoTargetRoom(e,t)}return this.goHome(e)}),this.goHome=(e=>(Population.registerCreepFlag(e,null),Creep.action.travelling.assignRoom(e,e.data.homeRoom),!1)),this.getFlag=(e=>Flag.find(e=>e.color==FLAG_COLOR.invade.robbing.color&&e.secondaryColor==FLAG_COLOR.invade.robbing.secondaryColor,new RoomPosition(25,25,e),!1)),this.storage=((e,t)=>{const r=this.memory(this.getFlag(e));if(t){const o=r.storageRoom;return r.storageRoom=t,`Task.${this.name}: room ${e}, now sending haulers to ${t}, (was ${o})`}if(r.storageRoom){if(!1===t){const t=r.storageRoom;return delete r.storageRoom,`Task.${this.name}: room ${e}, cleared custom storage room (was ${t})`}return`Task.${this.name}: room ${e}, sending haulers to ${r.storageRoom}`}return`Task.${this.name}: room ${e}, no custom storage destination`}),this.gotoTargetRoom=((e,t)=>{if(Creep.action.travelling.assignRoom(e,t.pos.roomName))return Population.registerCreepFlag(e,t),!0}),this.creep={robbing:{fixedBody:[WORK,CARRY,MOVE,MOVE],multiBody:[CARRY,MOVE],name:"robber",behaviour:"privateer",queue:"Low"}},this.state={default:this.default,robber:this.robber}}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(1),i={"Source Keeper":!0,Invader:!0},a={MY_SCORE:1e3,WHITELIST_SCORE:200,ALLY:100,NEUTRAL:1,NPC_SCORE:-200};t.default=new class extends o.TaskComponent{constructor(){super("reputation"),this.myName=(()=>ME),this.isNPC=(e=>!0===i[e]),this.npcOwner=(e=>e.owner&&this.isNPC(e.owner.username)),this.isAlly=(e=>this.score(e)>=a.ALLY),this.notAlly=(e=>!this.isAlly(e)),this.allyOwner=(e=>e.owner&&this.isAlly(e.owner.username)),this.isHostile=(e=>this.score(e)<a.NEUTRAL),this.notHostile=(e=>!this.isHostile(e)),this.hostileOwner=(e=>e.owner&&this.isHostile(e.owner.username)),this.whitelist=(()=>this.cache("whitelist")),this.whitelist=(()=>this.cache("whitelist")),this.score=(e=>{const t=this.cache("score");if(void 0===e)return t;const r=e&&e.toLowerCase();return t[r]?t[r]:t[r]=0}),this.setScore=((e,t)=>{const r=e&&e.toLowerCase();this.score()[r]=t,this.playerMemory(r).score=t}),this.fresh=(()=>{this._loadWhitelist(),this._loadScore()}),this.cache=(e=>Task.cache(this.name,e)),this.killScoreCache=(()=>(Task.clearCache(this.name,"score"),this.score())),this.killWhitelistCache=(()=>(Task.clearCache(this.name,"score"),Task.clearCache(this.name,"whitelist"),this.whitelist())),this.memory=(e=>Task.memory(this.name,e)),this.playerMemory=(e=>{const t=this.memory("players"),r=e&&e.toLowerCase();return t[r]?t[r]:t[r]={}}),this._loadScore=(()=>{const e=this.cache("etc"),t=this.memory("players"),r=this.whitelist();let o=this.score();if(_.keys(t).length+_.keys(r).length!==_.keys(o).length+e.whitelistRepUnion){o=this.killScoreCache();for(const e in i)o[e]=a.NPC_SCORE;_.keys(r).forEach(e=>{o[e]=a.WHITELIST_SCORE}),e.whitelistRepUnion=0,_.reduce(t,(t,o,i)=>("number"==typeof o.score&&(r[i]&&e.whitelistRepUnion++,t[i]=o.score),t),o),this.setScore(this.myName(),a.MY_SCORE)}}),this._loadWhitelist=(()=>{let e=this.whitelist();_.keys(e).length!==PLAYER_WHITELIST.length&&(e=this.killWhitelistCache(),_.forEach(PLAYER_WHITELIST,t=>{e[t.toLowerCase()]=!0}))})}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(1);t.default=new class extends o.TaskComponent{constructor(){super("delivery"),this.memory=(e=>{let t=Task.memory(this.name,e);return t.hasOwnProperty("queued")||(t.queued=[]),t.hasOwnProperty("spawning")||(t.spawning=[]),t.hasOwnProperty("running")||(t.running=[]),t}),this.memoryKey=(e=>{const t=Game.flags[e.destiny.targetName];return t&&t.pos.roomName}),this.checkFlag=(e=>e.room&&e.room.my&&e.compareTo(FLAG_COLOR.invade.robbing)&&Task.nextCreepCheck(e,this.name)),this.handleFlagFound=(e=>{this.checkFlag(e)&&this.checkForRequiredCreeps(e)}),this.maxCreeps=(e=>e.room&&e.room.storage?Math.floor(2*e.room.storage.charge):1),this.checkForRequiredCreeps=(e=>{const t=this.memory(e.pos.roomName);if(Task.validateAll(t,e,this.name,{roomName:e.pos.roomName,checkValid:!0}),t.queued.length+t.spawning.length>0)return;const r=this.maxCreeps(e);if(t.running.length<r){const t=Flag.find(FLAG_COLOR.claim.delivery,e.pos);let r=t&&t.pos.roomName;if(!r){const t=Room.findSpawnRoom({targetRoom:e.pos.roomName});if(!t)return;r=t.name}Task.spawn(this.creep.recycler,{task:this.name,targetName:e.name,targetRoom:r},{explicit:e.pos.roomName,targetRoom:r,minEnergyCapacity:100},e=>{this.memory(Game.flags[e.destiny.targetName].pos.roomName).queued.push({room:e.queueRoom,name:e.name})})}}),this.handleSpawningStarted=(e=>{if(!e.destiny||!e.destiny.task||e.destiny.task!=this.name)return;let t=Game.flags[e.destiny.targetName];if(t){let r=this.memory(t.pos.roomName);r.spawning.push(e),Task.validateQueued(r,t,this.name)}}),this.handleSpawningCompleted=(e=>{if(!e.data||!e.data.destiny||!e.data.destiny.task||e.data.destiny.task!=this.name)return;e.data.homeRoom=e.data.destiny.homeRoom||e.data.homeRoom,e.data.travelRoom=e.data.destiny.targetRoom||e.data.travelRoom;let t=Game.flags[e.data.destiny.targetName];if(t){let r=this.memory(t.pos.roomName);Task.validateSpawning(r,t,this.name),e.data.predictedRenewal=e.data.spawningTime+50*Util.routeRange(e.data.homeRoom,t.pos.roomName),r.running.push(e.name)}}),this.handleCreepDied=(e=>{const t=Memory.population[e];if(!t||!t.destiny||!t.destiny.task||t.destiny.task!=this.name)return;const r=Game.flags[t.destiny.targetName];if(r){const t=this.memory(r.pos.roomName);Task.validateRunning(t,r,this.name,{roomName:r.pos.roomName,deadCreep:e})}}),this.minControllerLevel=4,this.creep={recycler:{fixedBody:[CARRY,MOVE],multiBody:[CARRY,MOVE],name:"recycler",behaviour:"recycler",queue:"Low"}}}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(1);t.default=new class extends o.TaskComponent{constructor(){super("labTech"),this.register=(()=>{Flag.found.on(e=>this.handleFlagFound(e)),Creep.spawningStarted.on(e=>this.handleSpawningStarted(e)),Creep.spawningCompleted.on(e=>this.handleSpawningCompleted(e)),Creep.predictedRenewal.on(e=>this.handleCreepDied(e.name)),Creep.died.on(e=>this.handleCreepDied(e))}),this.handleFlagFound=(e=>{e.compareTo(FLAG_COLOR.labs.labTech)&&Task.nextCreepCheck(e,this.name)&&(Util.set(e.memory,"task",this.name),this.checkForRequiredCreeps(e))}),this.checkForRequiredCreeps=(e=>{const t=this.memory(e);Task.validateAll(t,e,this.name,{roomName:e.pos.roomName,checkValid:!0}),t.queued.length+t.spawning.length+t.running.length<1&&Task.spawn(this.creep.labTech,{task:"labTech",targetName:e.name},{targetRoom:e.pos.roomName,minEnergyCapacity:1e3,maxRange:1,allowTargetRoom:!0},e=>{this.memory(Game.flags[e.destiny.targetName]).queued.push({room:e.queueRoom,name:e.name})})}),this.handleSpawningStarted=(e=>{if(!e.destiny||!e.destiny.task||"labTech"!=e.destiny.task)return;let t=Game.flags[e.destiny.targetName||e.destiny.flagName];if(t){const r=this.memory(t);r.spawning.push(e),Task.validateQueued(r,t,this.name)}}),this.handleSpawningCompleted=(e=>{if(!e.data||!e.data.destiny||!e.data.destiny.task||"labTech"!=e.data.destiny.task)return;let t=Game.flags[e.data.destiny.targetName||e.data.destiny.flagName];if(t){e.data.predictedRenewal=e.data.spawningTime+50*Util.routeRange(e.data.homeRoom,t.pos.roomName);const r=this.memory(t);r.running.push(e.name),Task.validateSpawning(r,t,this.name)}}),this.handleCreepDied=(e=>{const t=Memory.population[e];if(!t||!t.destiny||!t.destiny.task||"labTech"!=t.destiny.task)return;const r=Game.flags[t.destiny.targetName||t.destiny.flagName];if(r){const t=this.memory(r);Task.validateRunning(t,r,this.name,{roomName:r.pos.roomName,deadCreep:e})}}),this.memory=(e=>(e.memory.tasks||(e.memory.tasks={}),e.memory.tasks.labTech||(e.memory.tasks.labTech={queued:[],spawning:[],running:[]}),e.memory.tasks.labTech)),this.creep={labTech:{fixedBody:[WORK,CARRY,MOVE],multiBody:[CARRY,CARRY,MOVE],name:"labTech",behaviour:"labTech",queue:"Low"}}}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(1);t.default=new class extends o.TaskComponent{constructor(){super("safeGen"),this.handleFlagFound=(e=>{if(e.compareTo(FLAG_COLOR.command.safeGen)&&Task.nextCreepCheck(e,this.name)){const t=Game.rooms[e.pos.roomName];t&&(t.storage&&t.storage.store[RESOURCE_GHODIUM]>=1e3||t.terminal&&t.terminal.store[RESOURCE_GHODIUM]>=1e3)?(Util.set(e.memory,"task",this.name),this.checkForRequiredCreeps(e)):e.remove()}}),this.checkForRequiredCreeps=(e=>{const t=this.memory(e);Task.validateAll(t,e,this.name,{roomName:e.pos.roomName,checkValid:!0}),t.queued.length+t.spawning.length+t.running.length<1&&Task.spawn(this.creep.safeGen,{task:"safeGen",targetName:e.name},{targetRoom:e.pos.roomName,minEnergyCapacity:2e3,maxRange:1,allowTargetRoom:!0},e=>{this.memory(Game.flags[e.destiny.targetName]).queued.push({room:e.queueRoom,name:e.name})})}),this.handleSpawningStarted=(e=>{if(!e.destiny||!e.destiny.task||"safeGen"!=e.destiny.task)return;let t=Game.flags[e.destiny.targetName||e.destiny.flagName];if(t){const r=this.memory(t);r.spawning.push(e),Task.validateQueued(r,t,this.name)}}),this.handleSpawningCompleted=(e=>{if(!e.data||!e.data.destiny||!e.data.destiny.task||"safeGen"!=e.data.destiny.task)return;let t=Game.flags[e.data.destiny.targetName||e.data.destiny.flagName];if(t){e.data.predictedRenewal=e.data.spawningTime+50*Util.routeRange(e.data.homeRoom,t.pos.roomName);const r=this.memory(t);r.running.push(e.name),Task.validateSpawning(r,t,this.name)}}),this.handleCreepDied=(e=>{const t=Memory.population[e];if(!t||!t.destiny||!t.destiny.task||"safeGen"!=t.destiny.task)return;const r=Game.flags[t.destiny.targetName||t.destiny.flagName];if(r){const t=this.memory(r);Task.validateRunning(t,r,this.name,{roomName:r.pos.roomName,deadCreep:e})}}),this.memory=(e=>(e.memory.tasks||(e.memory.tasks={}),e.memory.tasks.safeGen||(e.memory.tasks.safeGen={queued:[],spawning:[],running:[]}),e.memory.tasks.safeGen)),this.minControllerLevel=6,this.creep={safeGen:{multiBody:[CARRY,MOVE],maxMulti:20,maxWeight:2e3,name:"safeGen",behaviour:"safeGen",queue:"Low"}}}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(1);t.default=new class extends o.TaskComponent{constructor(){super("scheduler"),this.processes={example:{conditions:()=>!1,run:()=>{console.log("Hello!")}}},this.run=(()=>{_.forEach(this.processes,(e,t)=>{e.conditions()&&e.run()})}),this.registerProcess=((e,t,r)=>{this.processes[e]?(this.processes[e].conditions=t,this.processes[e].run=r):this.processes[e]={conditions:t,run:r}}),this.unregisterProcess=(e=>{this.processes[e]&&delete this.processes[e]}),this.forceRunProcess=(e=>{let t=this.processes[e];t&&t.conditions()&&t.run()})}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(0);t.default=new class extends o.CreepAction{constructor(){super("attackController"),this.isValidAction=(e=>!0),this.isValidTarget=((e,t)=>e&&(!e.reservation||!Task.reputation.allyOwner(e.reservation))&&t.flag),this.isAddableAction=(()=>!0),this.isAddableTarget=(e=>e&&(e instanceof Flag||"controller"===e.structureType&&(e.reservation||e.owner))),this.newTarget=(e=>{let t;return e.data.destiny&&(t=Game.flags[e.data.destiny.targetName]),t||(t=Flag.find(e=>Flag.compare(e,FLAG_COLOR.invade.attackController),e.pos,!1,Flag.reserveMod,e.name)),t?(Population.registerCreepFlag(e,t),e.flag.room&&e.flag.pos.roomName==e.pos.roomName?e.flag.room.controller:e.flag):null}),this.step=(e=>{if(CHATTY&&e.say(this.name,SAY_PUBLIC),e.target.color)return e.flag.pos.roomName==e.pos.roomName&&(e.data.targetId=null),void e.travelTo(e.target);let t=e.pos.getRangeTo(e.target);if(t<=this.targetRange){let r=this.work(e);r!=OK&&e.handleError({errorCode:r,action:this.name,target:e.target,range:t,creep:e})}else e.travelTo(e.target)}),this.work=(e=>{let t;return e.controllerSign(),t=e.target.owner&&!e.target.my||e.target.reservation&&!Task.reputation.allyOwner(e.target.reservation)?e.attackController(e.target):e.claimController(e.target)}),this.setDefault({moveOptions:e=>e})}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(0);t.default=new class extends o.CreepAction{constructor(){super("avoiding"),this.targetRange=0,this.reachedRange=0,this.lairDangerTime=24,this.lairDangerRange=14,this.isActiveLair=(e=>!_.isUndefined(e.ticksToSpawn)&&e.ticksToSpawn<=this.lairDangerTime),this.isValidAction=(e=>e.data.destiny&&e.data.destiny.room===e.room.name&&(Room.isSKRoom(e.room.name)||e.room.situation.invasion)),this.isAddableAction=(e=>!0),this.isValidTarget=((e,t)=>Task.reputation.npcOwner(e)?_.isUndefined(e.ticksToSpawn)||this.isActiveLair(e):!(!Task.reputation.hostileOwner(e)||!e.hasActiveBodyparts)&&e.hasActiveBodyparts([ATTACK,RANGED_ATTACK])),this.newTarget=(e=>{if(Room.isSKRoom(e.pos.roomName)){const t=_.first(e.room.find(FIND_STRUCTURES,{filter:t=>this.isActiveLair(t)&&e.pos.getRangeTo(t.pos)<=this.lairDangerRange}));if(t)return t}if(e.room.situation.invasion){const t=_.chain(e.room.hostiles).filter(e=>this.isValidTarget(e)).map(t=>{let r=0;const o=e.pos.getRangeTo(t);return{target:t,score:r="Invader"===e.owner.username?o-51:o<10?o-11:0}}).filter("score").sortBy("score").first().get("target").value();if(t)return t}}),this.work=(e=>{if(!e.data.safeSpot||!e.data.safeSpot.roomName){const t=e.data.destiny&&Game.flags[e.data.destiny.targetName];if(t)e.data.safeSpot=t.pos;else{const t=_.chain(e.room.findRoute(e.data.homeRoom)).first().get("exit").value();t&&(e.data.safeSpot=e.pos.findClosestByRange(t),e.data.safeSpot.roomName=e.pos.roomName)}}e.data.safeSpot&&(e.pos.getRangeTo(e.target)<10?e.travelTo(e.data.safeSpot):e.idleMove())}),this.run=(e=>{if(this.isValidAction(e)&&(e.action===this&&this.isValidTarget(e.target,e)||this.isAddableAction(e)&&this.assign(e)))return!!e.leaveBorder()||(this.work(e),!0)})}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(0);t.default=new class extends o.CreepAction{constructor(){super("boosting"),this.maxPerAction=1,this.isValidMineralType=(e=>{for(const t in BOOSTS)for(const r in BOOSTS[t])if(e===r)return!0;return!1}),this.isValidMineralType=(e=>{for(const t in BOOSTS)for(const r in BOOSTS[t])if(e===r)return!0;return!1}),this.getBoostPartType=(e=>{for(const t in BOOSTS)for(const r in BOOSTS[t])if(e===r)return t}),this.canBoostType=((e,t)=>!_(e.body).filter({type:t}).every(e=>e.boost)),this.isValidAction=(e=>!_.every(e.body,e=>e.boost)),this.isValidTarget=((e,t)=>e instanceof StructureLab&&e.active&&e.energy>=LAB_BOOST_ENERGY&&e.mineralAmount>=LAB_BOOST_MINERAL),this.newTarget=(e=>_(e.room.structures.labs.all).filter(this.isValidTarget).filter(t=>this.isAddableTarget(t,e)).min(t=>e.pos.getRangeTo(t))),this.work=(e=>e.target.boostCreep(e)),this.onAssignment=(e=>{SAY_ASSIGNMENT&&e.say(ACTION_SAY.BOOSTING,SAY_PUBLIC)}),this.setDefault({isValidMineralType:e=>{for(const t in BOOSTS)for(const r in BOOSTS[t])if(e===r)return!0;return!1}}),this._isAddableTarget=this.isAddableTarget,this.isAddableTarget=((e,t)=>{const r=this.getBoostPartType(e.mineralType);return this._isAddableTarget(e,t)&&t.getStrategyHandler([this.name],"isValidMineralType",e.mineralType)&&t.hasActiveBodyparts(r)&&this.canBoostType(t,r)})}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(0);t.default=new class extends o.CreepAction{constructor(){super("building"),this.maxPerTarget=3,this.maxPerAction=3,this.targetRange=3,this.reachedRange=(e=>e.getStrategyHandler([this.name],"reachedRange",e)),this.isValidAction=(e=>e.carry.energy>0),this.isAddableAction=(e=>!e.room.population||!e.room.population.actionCount[this.name]||e.room.population.actionCount[this.name]<this.maxPerAction),this.isValidTarget=(e=>null!=e&&(e.my||Task.reputation.allyOwner(e))&&e.progress&&e.progress<e.progressTotal),this.isAddableTarget=(e=>e&&(e.my||Task.reputation.allyOwner(e))&&(!e.targetOf||e.targetOf.length<this.maxPerTarget)),this.newTarget=(e=>e.room.getBestConstructionSiteFor(e.pos,t=>this.isAddableTarget(t,e))),this.work=(e=>(e.getStrategyHandler([this.name],"getEnergy",e),e.build(e.target))),this.setDefault({reachedRange:1,getEnergy:()=>!1})}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(0);t.default=new class extends o.CreepAction{constructor(){super("bulldozing"),this.maxPerAction=2,this.maxPerTarget=1,this.isValidTarget=(e=>!(!e.room.my&&e.room.controller&&e.room.controller.safeMode)&&e instanceof ConstructionSite&&Task.reputation.notAlly(e.owner.username)),this.newTarget=(e=>{const t=_(e.room.constructionSites).filter(this.isValidTarget).max(t=>{let r;return r=t.structureType===STRUCTURE_SPAWN?2e4:1e4,r+=t.progress/t.progressTotal*1e4,r-=e.pos.getRangeTo(t)});if(t instanceof ConstructionSite)return t}),this.work=(e=>e.move(e.pos.getDirectionTo(e.target)))}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(0);t.default=new class extends o.CreepAction{constructor(){super("charging"),this.renewTarget=!1,this.maxPerTarget=1,this.isValidAction=(e=>e.carry.energy>0),this.isAddableAction=(e=>!0),this.isValidTarget=(e=>!!e&&(e.structureType==STRUCTURE_LINK?e.energy<.85*e.energyCapacity:e.structureType==STRUCTURE_CONTAINER&&e.sum<(!0===e.source&&1==e.controller?e.storeCapacity*MANAGED_CONTAINER_TRIGGER:e.storeCapacity))),this.newTarget=(e=>{if(e.room.structures.links.storage.length>0){let t=e.room.structures.links.storage.find(e=>e.energy<.85*e.energyCapacity);if(t&&e.room.structures.links.controller.find(e=>e.energy<=.15*e.energyCapacity)&&this.isValidTarget(t,e)&&this.isAddableTarget(t,e))return t}let t=this;if(e.room.structures.container.out.length>0){let r=null,o=0,i=i=>{if(t.isValidTarget(i,e)&&t.isAddableTarget(i,e)){let e=i.storeCapacity-i.sum;e>o&&(o=e,r=i)}};return _.forEach(e.room.structures.container.out,i),r}return null}),this.work=(e=>{let t;if(!0===e.target.source&&1==e.target.controller){let r=e.target.storeCapacity*MANAGED_CONTAINER_TRIGGER-e.target.sum;if(r<1)t=ERR_FULL;else{let o=_.min([e.carry.energy,r]);t=e.transfer(e.target,RESOURCE_ENERGY,o),e.target._sum+=o}}else t=e.transfer(e.target,RESOURCE_ENERGY);return delete e.data.actionName,delete e.data.targetId,e.action=null,e.target=null,t}),this._isAddableTarget=this.isAddableTarget,this.isAddableTarget=((e,t)=>this._isAddableTarget(e,t)&&(e instanceof OwnedStructure&&e.my||!t.room.controller||(!t.room.controller.owner||t.room.controller.my)&&(!t.room.controller.reservation||t.room.controller.reservation.username==t.owner.username))&&(e.structureType==STRUCTURE_CONTAINER&&e.storeCapacity-e.sum>Math.min(t.carry.energy,500)||e.structureType==STRUCTURE_LINK)&&(e.structureType!=STRUCTURE_CONTAINER||!e.controller||t.carry.energy==t.sum))}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(0);t.default=new class extends o.CreepAction{constructor(){super("claiming"),this.isValidAction=(e=>!0),this.isValidTarget=(e=>!e.room||!e.owner),this.isAddableAction=(()=>!0),this.isAddableTarget=(()=>!0),this.newTarget=(e=>{let t;if(e.data.destiny&&(t=Game.flags[e.data.destiny.targetName||e.data.destiny.flagName]),t||(t=Flag.find(FLAG_COLOR.claim,e.pos,!1,Flag.claimMod,e.name)),!t)return null;if(Population.registerCreepFlag(e,t),!e.flag.room||e.flag.pos.roomName!=e.pos.roomName)return e.flag;if(e.flag.room.controller.my){e.flag.setColor(FLAG_COLOR.claim.spawn.color,FLAG_COLOR.claim.spawn.secondaryColor);let t=e=>Game.flags[e.name].remove();return _.forEach(Flag.filter(FLAG_COLOR.invade.exploit,e.flag.pos,!0),t),null}return e.flag.room.controller}),this.step=(e=>{if(CHATTY&&e.say(this.name,SAY_PUBLIC),e.target.color)return e.flag.pos.roomName==e.pos.roomName&&(e.data.targetId=null),void e.travelTo(e.target.pos);let t=e.pos.getRangeTo(e.target);if(t<=this.targetRange){let r=this.work(e);r!=OK&&e.handleError({errorCode:r,action:this.name,target:e.target,range:t,creep:e})}e.travelTo(e.target.pos)}),this.work=(e=>(e.controllerSign(),e.claimController(e.target)))}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(0);t.default=new class extends o.CreepAction{constructor(){super("defending"),this.isValidAction=(e=>e.room.hostiles.length>0),this.isAddableAction=(()=>!0),this.isAddableTarget=(()=>!0),this.isValidTarget=(e=>e&&null!=e.hits&&e.hits>0&&0==e.my),this.newTarget=(e=>{let t=e.pos.findClosestByRange(e.room.hostiles,{filter:e.getStrategyHandler([this.name],"priorityTargetFilter",e)});return t||(t=e.pos.findClosestByRange(e.room.hostiles,{filter:e.getStrategyHandler([this.name],"targetFilter",e)})),t}),this.step=(e=>{if(CHATTY&&e.say(this.name,SAY_PUBLIC),e.target.pos.roomName!==e.room.name)return Creep.action.travelling.assignRoom(e,e.target.pos.roomName);this.run[e.data.creepType](e)}),this.run={ranger(e){let t=e.pos.getRangeTo(e.target);if(!e.flee&&(t>3&&e.travelTo(e.target,{respectRamparts:COMBAT_CREEPS_RESPECT_RAMPARTS}),t<3)){let r=e.target.pos.getDirectionTo(e);r&&(COMBAT_CREEPS_RESPECT_RAMPARTS&&!_.filter(e.pos.lookFor(LOOK_STRUCTURES),{my:!0,structureType:STRUCTURE_RAMPART})&&e.move(r),1===t&&(e.attacking=e.attack(e.target)==OK))}let r=e.pos.findInRange(e.room.hostiles,3);if(r.length>2)return CHATTY&&e.say("MassAttack"),void(e.attackingRanged=e.rangedMassAttack()==OK);t<4?e.attackingRanged=e.rangedAttack(e.target)==OK:r.length>0&&(e.attackingRanged=e.rangedAttack(r[0])==OK)},melee(e){e.flee||e.travelTo(e.target,{respectRamparts:COMBAT_CREEPS_RESPECT_RAMPARTS});let t=e.attack(e.target);if(t==ERR_NOT_IN_RANGE){let t=e.pos.findInRange(e.room.hostiles,1);t.length>0&&(e.attacking=e.attack(t[0])==OK)}else e.attacking=t==OK}},this.setDefault({priorityTargetFilter:e=>e=>e.hasBodyparts(HEAL),targetFilter:e=>e=>!0})}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(0);t.default=new class extends o.CreepAction{constructor(){super("dismantling"),this.maxPerAction=3,this.maxPerTarget=3,this.renewTarget=!1,this.isValidAction=(e=>0===e.carryCapacity||e.sum<e.carryCapacity),this.isValidTarget=(e=>null!=e),this.newTarget=(e=>{let t,r=Flag.find(FLAG_COLOR.destroy.dismantle,e.pos,!0);if(r)if(void 0!==r.room){let o=r.room.lookForAt(LOOK_STRUCTURES,r.pos.x,r.pos.y);if(o&&o.length>0)return o[0];{let o=r.name;Room.costMatrixInvalid.trigger(r.room),Flag.removeFromDir(r.name),r.remove();let i=(e,t,r)=>t.name==r?1/0:e;if(o==(r=Flag.find(FLAG_COLOR.destroy.dismantle,e.pos,!0,i,o)).name&&Util.logError("Removed flag found again in dismantling.newTarget!"),r)if(void 0!==r.room){let e=r.room.lookForAt(LOOK_STRUCTURES,r.pos.x,r.pos.y);if(e&&e.length>0)return e[0];Room.costMatrixInvalid.trigger(r.room),Flag.removeFromDir(r.name),r.remove()}else t=r}}else t=r;return t}),this.work=(e=>e.dismantle(e.target))}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(0);t.default=new class extends o.CreepAction{constructor(){super("dropping"),this.targetRange=1,this.reachedRange=0,this.isValidAction=(e=>e.sum>0),this.isValidTarget=((e,t)=>!!e&&(!(e instanceof Flag)||e.compareTo(FLAG_COLOR.claim.spawn)||e.compareTo(FLAG_COLOR.command.drop))),this.newTarget=(e=>{let t=e.pos.findClosestByRange(e.room.structures.piles);return t||(t=e.pos.findClosestByRange(e.room.structures.spawns)),t||(t=e.pos.findClosestByRange(e.room.find(FIND_FLAGS,Flag.flagFilter(FLAG_COLOR.claim.spawn)))),t||(t=e.pos.findClosestByRange(_.filter(e.room.constructionSites,{structureType:STRUCTURE_SPAWN}))),t||(t=e.room.controller),t}),this.work=(e=>{let t=OK;if(!(e.target instanceof StructureSpawn||e.target instanceof ConstructionSite||e.target instanceof StructureController||(e=>e&&Flag.compare(e,FLAG_COLOR.claim.spawn))(e.target))&&e.pos.getRangeTo(e.target)>0&&e.data.lastPos&&e.data.path&&!_.eq(e.pos,e.data.lastPos)){let r=e=>e.type==LOOK_TERRAIN&&"wall"==e.terrain||e.type==LOOK_CREEPS||e.type==LOOK_STRUCTURES&&OBSTACLE_OBJECT_TYPES.includes(e.structure.structureType),o=e.room.lookAt(e.target);if(!_.some(o,r))return t}for(let r in e.carry)t=e.drop(r);return t})}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(0);t.default=new class extends o.CreepAction{constructor(){super("feeding"),this.maxPerTarget=1,this.isValidAction=(e=>e.carry.energy>0&&e.room.energyAvailable<e.room.energyCapacityAvailable),this.isValidTarget=(e=>e&&!_.isUndefined(e.energy)&&e.energy<e.energyCapacity),this.isAddableTarget=(e=>e.my&&(!e.targetOf||_.filter(e.targetOf,{actionName:"feeding"}).length<this.maxPerTarget)),this.newTarget=(e=>e.room.energyAvailable===e.room.energyCapacityAvailable?null:e.pos.findClosestByRange(e.room.structures.feedable,{filter:t=>this.isValidTarget(t)&&this.isAddableTarget(t,e)})),this.work=(e=>{let t=e.transfer(e.target,RESOURCE_ENERGY);return t==OK&&e.carry.energy>e.target.energyCapacity-e.target.energy&&(e.target=null,this.assign(e)),t})}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(0);t.default=new class extends o.CreepAction{constructor(){super("fortifying"),this.maxPerTarget=1,this.maxPerAction=1,this.targetRange=3,this.isValidAction=(e=>e.carry.energy>0&&(!e.room.storage||!e.room.storage.active||e.room.storage.charge>.6)),this.isValidTarget=(e=>e&&e.active&&e.hits&&e.hits<e.hitsMax),this.newTarget=(e=>_.find(e.room.structures.fortifyable,t=>this.isAddableTarget(t,e))),this.work=(e=>e.repair(e.target))}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(0);t.default=new class extends o.CreepAction{constructor(){super("fueling"),this.maxPerTarget=1,this.maxPerAction=1,this.isValidAction=(e=>e.carry.energy>0&&e.room.towerFreeCapacity>0),this.isValidTarget=(e=>e&&(e.energy||0==e.energy)&&e.active&&e.energy<e.energyCapacity),this.isAddableTarget=(e=>e.my&&(!e.targetOf||e.targetOf.length<this.maxPerTarget)),this.newTarget=(e=>e.room.structures.fuelable.length>0?e.pos.findClosestByRange(e.room.structures.fuelable):null),this.work=(e=>{let t=e.transfer(e.target,RESOURCE_ENERGY);return e.target.energyCapacity-e.target.energy<20&&(e.data.targetId=null),t})}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(0);t.default=new class extends o.CreepAction{constructor(){super("guarding"),this.reachedRange=0,this.isAddableAction=(()=>!0),this.isAddableTarget=(()=>!0),this.newTarget=(e=>{let t;return e.data.destiny&&(t=Game.flags[e.data.destiny.flagName]),t||(t=Flag.find(FLAG_COLOR.defense,e.pos,!1,Flag.rangeMod,{rangeModPerCrowd:400})),e.action===this&&e.flag?e.flag:(t&&Population.registerCreepFlag(e,t),t)}),this.work=(e=>e.data.flagName?OK:ERR_INVALID_ARGS)}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(0);t.default=new class extends o.CreepAction{constructor(){super("harvesting"),this.renewTarget=!1,this.isValidAction=(e=>e.sum<e.carryCapacity&&e.room.sourceEnergyAvailable>0),this.isValidTarget=((e,t)=>null!==e&&null!==e.energy&&e.energy>0&&(void 0===e.targetOf||e.targetOf.length<=e.accessibleFields&&!_.some(e.targetOf,e=>("miner"===e.creepType||"remoteMiner"===e.creepType)&&e.body.work>=5&&(e.ticksToLive||CREEP_LIFE_TIME)>=(e.data&&e.data.predictedRenewal||0)))),this.isAddableTarget=((e,t)=>(!t.room.controller||(!t.room.controller.owner||t.room.controller.my)&&(!t.room.controller.reservation||t.room.controller.reservation.username==t.owner.username))&&(void 0===e.targetOf||e.targetOf.length<e.accessibleFields)),this.newTarget=(e=>{const t=_.sortBy(e.room.sources,t=>e.pos.getRangeTo(t));for(const r of t)if(this.isValidTarget(r,e)&&this.isAddableTarget(r,e))return r;return null}),this.work=(e=>e.harvest(e.target))}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(0);t.default=new class extends o.CreepAction{constructor(){super("healing"),this.targetRange=3,this.isAddableAction=(()=>!0),this.isAddableTarget=((e,t)=>{const r=t.getStrategyHandler([this.name],"targetFilter",t);return r&&r(e)}),this.isValidTarget=((e,t)=>{if(null!=e&&null!=e.hits&&e.hits<e.hitsMax&&e.pos.roomName===t.data.healRoom){const r=t.getStrategyHandler([this.name],"targetFilter",t);return r&&r(e)}return!1}),this.newTarget=(e=>{if(e.room.casualties.length>0)for(const t of e.room.casualties)if(t.name!==e.name)return e.data.healRoom=t.pos.roomName,t;return delete e.data.healRoom,null}),this.work=(e=>{if(e.target.hits<e.target.hitsMax)return e.pos.isNearTo(e.target)?e.heal(e.target):e.pos.inRangeTo(e.target,3)?e.rangedHeal(e.target):OK}),this.setDefault({targetFilter:e=>e=>e.my,moveOptions:e=>e})}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(0);t.default=new class extends o.CreepAction{constructor(){super("idle"),this.targetRange=3,this.isValidAction=(e=>!0),this.isAddableAction=(e=>!0),this.isAddableTarget=(e=>!0),this.newTarget=(e=>Flag.specialFlag()),this.step=(e=>{CHATTY&&e.say(this.name,SAY_PUBLIC),e.getStrategyHandler([this.name],"idleMove",e)&&e.idleMove(),delete e.data.actionName,delete e.data.targetId}),this.setDefault({idleMove:e=>!0})}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(0);t.default=new class extends o.CreepAction{constructor(){super("invading"),this.isValidAction=(e=>Flag.hasInvasionFlag()),this.isAddableAction=(()=>!0),this.isAddableTarget=(()=>!0),this.getFlaggedStructure=((e,t)=>{let r=[];return Flag.filter(e,t,!0).forEach(e=>{let o=Game.flags[e.name];if(o&&o.pos.roomName==t.roomName&&void 0!==o.room){let e=o.room.lookForAt(LOOK_STRUCTURES,o.pos.x,o.pos.y);if(e&&e.length>0){const t=e=>{e.destroyFlag=o,r.push(e)};e.forEach(t)}else o.remove()}}),r&&r.length>0?t.findClosestByRange(r):null}),this.newTarget=(e=>{let t=this.getFlaggedStructure(FLAG_COLOR.destroy,e.pos);if(t)return t.destroyFlag&&Population.registerCreepFlag(e,t.destroyFlag),t;let r=Flag.find(FLAG_COLOR.invade,e.pos,!1);if(r&&(!r.room||r.pos.roomName!=e.pos.roomName))return Population.registerCreepFlag(e,r),r;if(!r)return e.action=null,delete e.data.actionName,void delete e.data.targetId;if(!r.room.controller||!r.room.controller.my){let t=e.pos.findClosestByRange(e.room.hostiles,{filter:e=>_.some(e.body,{type:HEAL})});if(t)return t;if(t=e.pos.findClosestByRange(e.room.hostiles,{filter:e=>_.some(e.body,e=>e.type==ATTACK||e.type==RANGED_ATTACK)}))return t;if(t=e.pos.findClosestByPath(FIND_HOSTILE_STRUCTURES,{filter:e=>e.structureType==STRUCTURE_TOWER}))return t;if(t=e.pos.findClosestByRange(e.room.hostiles))return t;if(t=e.pos.findClosestByPath(FIND_HOSTILE_STRUCTURES,{filter:e=>e.structureType==STRUCTURE_SPAWN}))return t;if(t=e.pos.findClosestByPath(FIND_HOSTILE_STRUCTURES,{filter:e=>e.structureType!=STRUCTURE_CONTROLLER}))return t;if(t=e.pos.findClosestByPath(FIND_HOSTILE_CONSTRUCTION_SITES))return t}return r.remove(),null}),this.step=(e=>{CHATTY&&e.say(this.name),e.target instanceof Flag&&e.target.pos.roomName==e.pos.roomName&&this.assign(e),this.run[e.data.creepType](e)}),this.run={melee:e=>{if(!e.flee){if(e.target instanceof Flag)return void e.travelTo(e.target);if(e.target instanceof ConstructionSite)return void e.travelTo(e.target,{range:0});e.travelTo(e.target)}e.target.my||(e.attacking=e.attack(e.target)==OK)},ranger:e=>{let t=e.pos.getRangeTo(e.target);if(!e.flee){if(e.target instanceof Flag)return void e.travelTo(e.target);if(e.target instanceof ConstructionSite)return void e.travelTo(e.target,{range:0});t>3&&e.travelTo(e.target),t<3&&e.move(e.target.pos.getDirectionTo(e))}let r=e.pos.findInRange(e.room.hostiles,3);if(r.length>2)return CHATTY&&e.say("MassAttack"),void(e.attackingRanged=e.rangedMassAttack()==OK);t<4?e.attackingRanged=e.rangedAttack(e.target)==OK:r.length>0&&(e.attackingRanged=e.rangedAttack(r[0])==OK)}},this.setDefault({moveOptions:e=>(_.isUndefined(e.allowHostile)&&(e.allowHostile=!0),e)})}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(0);t.default=new class extends o.CreepAction{constructor(){super("mining"),this.renewTarget=!0,this.isValidTarget=((e,t)=>e&&(e instanceof Source||e instanceof Mineral&&!e.ticksToRegeneration)),this.isAddableAction=(e=>{const t=e.room;return t.my||t.myReservation||!t.owner&&!t.reservation}),this.isAddableTarget=((e,t)=>!e.targetOf||!_.some(e.targetOf,e=>{const r=e.predictedRenewal?e.predictedRenewal:e.spawningTime;return e.creepType===t.data.creepType&&e.ttl>r})),this.newTarget=(e=>{const t=e.getStrategyHandler([this.name],"newTarget",e);return t&&this.determineSpot(e,t),t}),this.determineSpot=((e,t)=>{const r=[];_.forEach(Memory.population,t=>{if(t.name===e.name)return;const o=t.predictedRenewal?t.predictedRenewal:t.spawningTime;t.roomName===e.pos.roomName&&["miner","upgrader"].includes(t.creepType)&&t.determinatedSpot&&t.ttl>o&&r.push(t.determinatedSpot)});const o=t.container&&t.container.structureType===STRUCTURE_CONTAINER&&t.container.pos.isNearTo(t)&&!_.some(r,{x:t.container.pos.x,y:t.container.pos.y})?t.container.pos:null;let i,a=[];if(o||(i={spots:[{pos:t.pos,range:1}],checkWalkable:!0,where:e=>!_.some(r,{x:e.x,y:e.y}),roomName:e.pos.roomName},t.container&&i.spots.push({pos:t.container.pos,range:1}),!e.remote&&t.link&&i.spots.push({pos:t.link.pos,range:1}),a=Room.fieldsInRange(i)),o||a.length>0){let r=o;if(r||(r=e.pos.findClosestByPath(a,{filter:t=>!_.some(e.room.lookForAt(LOOK_STRUCTURES,t),{structureType:STRUCTURE_ROAD})})),r||(r=e.pos.findClosestByPath(a)||a[0]),r){if(e.data.determinatedSpot={x:r.x,y:r.y},!e.remote){const t=Game.spawns[e.data.motherSpawn];if(t){const o=r.findPathTo(t,{ignoreCreeps:!0});o&&(e.data.predictedRenewal=e.data.spawningTime+o.length)}}MINERS_AUTO_BUILD&&!t.container&&!_.filter(t.pos.findInRange(FIND_CONSTRUCTION_SITES,2),e=>e.structureType===STRUCTURE_CONTAINER).length&&t.room&&t.room.createConstructionSite(r,STRUCTURE_CONTAINER)}}e.data.determinatedSpot||Util.logError("Unable to determine working location for miner in room "+e.pos.roomName)}),this.work=(e=>{if(0===e.target.energy||e.target.cooldown>0)this.maintain(e);else{if(!(e.target instanceof Mineral&&e.target.ticksToRegeneration>0)){this.resetChecks(e);const t=e.carryCapacity-(e.data.body&&e.data.body.work?2*e.data.body.work:e.carryCapacity/2);if(e.sum>t)if(e.target.link&&e.target.link.energy<e.target.link.energyCapacity)e.transfer(e.target.link,RESOURCE_ENERGY);else if(e.target.container&&e.target.container.sum<e.target.container.storeCapacity){const t=t=>{e.carry[t]>0&&e.transfer(e.target.container,t)};_.forEach(Object.keys(e.carry),t)}else{CHATTY&&e.say("dropmining",SAY_PUBLIC),OOPS&&e.say(String.fromCharCode(8681),SAY_PUBLIC);const t=t=>{e.carry[t]>0&&e.drop(t)};_.forEach(Object.keys(e.carry),t)}return e.harvest(e.target)}this.resetChecks(e),this.unassign(e)}}),this.resetChecks=(e=>{delete e.data.repairChecked,delete e.data.repairTarget,delete e.data.buildChecked,delete e.data.buildTarget,delete e.data.energyChecked}),this.step=(e=>{if(_.isUndefined(e.data.determinatedSpot))this.determineSpot(e,e.target);else{const t=e.data.destiny?e.data.destiny.room:e.data.homeRoom,r=new RoomPosition(e.data.determinatedSpot.x,e.data.determinatedSpot.y,t),o=e.pos.getRangeTo(r);o>1?e.travelTo(r,{range:1}):1===o?r.lookFor(LOOK_CREEPS).length>0||e.move(e.pos.getDirectionTo(r)):this.work(e)}}),this.getEnergy=(e=>{const t=e.pos.findInRange(FIND_DROPPED_RESOURCES,1,{filter:e=>e.resourceType===RESOURCE_ENERGY})[0];if(t)return DEBUG&&TRACE&&Util.trace("Action",{actionName:this.name,method:"getEnergy",creepName:e.name,pos:e.pos,pickup:t.id}),e.pickup(t),!0;const r=e.pos.findInRange(FIND_STRUCTURES,1,{filter:e=>e.structureType===STRUCTURE_CONTAINER})[0];if(r&&r.sum>0)return DEBUG&&TRACE&&Util.trace("Action",{actionName:this.name,method:"getEnergy",creepName:e.name,pos:e.pos,withdrawCon:r.id}),e.withdraw(r,RESOURCE_ENERGY),!0;const o=e.pos.findInRange(FIND_STRUCTURES,1,{filter:e=>e.my&&e.structureType===STRUCTURE_LINK})[0];return o&&o.energy>0?(DEBUG&&TRACE&&Util.trace("Action",{actionName:this.name,method:"getEnergy",creepName:e.name,pos:e.pos,withdrawLink:o.id}),e.withdraw(o,RESOURCE_ENERGY),!0):(DEBUG&&TRACE&&Util.trace("Action",{actionName:this.name,method:"getEnergy",creepName:e.name,pos:e.pos,result:"no energy"}),e.data.energyChecked=Game.time,!1)}),this.maintain=(e=>{const t=e.data.body&&e.data.body.work?5*e.data.body.work:e.carryCapacity/2;if(DEBUG&&TRACE&&Util.trace("Action",{actionName:this.name,method:"maintain",creepName:e.name,pos:e.pos,energy:e.carryenergy,minCarry:t}),e.carry.energy<=t&&(!e.data.energyChecked||Game.time-e.data.energyChecked>MINER_WORK_THRESHOLD)&&this.getEnergy(e),e.carry.energy>0){if(!e.data.repairChecked||Game.time-e.data.repairChecked>MINER_WORK_THRESHOLD){let t=Game.getObjectById(e.data.repairTarget);if(t&&t.hits!==t.hitsMax||(t=e.pos.findInRange(FIND_STRUCTURES,3,{filter:e=>(e.structureType===STRUCTURE_CONTAINER||e.structureType===STRUCTURE_ROAD)&&e.hits<e.hitsMax})[0]),t)return e.data.repairTarget=t.id,DEBUG&&TRACE&&Util.trace("Action",{actionName:this.name,method:"maintain",creepName:e.name,pos:e.pos,repairTarget:t.id,progress:t.hits/t.hitsMax}),e.repair(t);delete e.data.repairTarget,e.data.repairChecked=Game.time}if(!e.data.buildChecked||Game.time-e.data.buildChecked>MINER_WORK_THRESHOLD){let t=Game.getObjectById(e.data.buildTarget);if(t&&t.progress!==t.progressTotal||(t=e.pos.findInRange(e.room.myConstructionSites,3,{filter:e=>(e.structureType===STRUCTURE_CONTAINER||e.structureType===STRUCTURE_ROAD)&&e.progress<e.progressTotal})[0]),t)return e.data.buildTarget=t.id,DEBUG&&TRACE&&Util.trace("Action",{actionName:this.name,method:"maintain",creepName:e.name,pos:e.pos,buildTarget:t.id,progress:t.progress/t.progressTotal}),e.build(t);delete e.data.buildTarget,e.data.buildChecked=Game.time}}return!1}),this.setDefault({newTarget:e=>_(e.room.sources).sortBy(t=>e.pos.getRangeTo(t)).find(t=>this.isValidTarget(t,e)&&this.isAddableTarget(t,e))||null})}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(0);t.default=new class extends o.CreepAction{constructor(){super("picking"),this.maxPerAction=4,this.maxPerTarget=2,this.isValidAction=(e=>e.sum<e.carryCapacity),this.isValidTarget=(e=>null!=e&&null!=e.amount&&e.amount>0),this.isAddableAction=(e=>e.data.creepType.indexOf("remote")>0||this.maxPerAction===1/0||!e.room.population||!e.room.population.actionCount[this.name]||e.room.population.actionCount[this.name]<this.maxPerAction),this.isAddableTarget=((e,t)=>{let r;r=t.data.creepType.indexOf("remote")>0?1/0:this.maxPerTarget;let o=e.targetOf?_.filter(e.targetOf,{actionName:"picking"}):[];return!e.targetOf||!o.length||o.length<r&&e.amount>_.sum(o.map(e=>e.carryCapacityLeft))}),this.newTarget=(e=>{const t=this.getStrategy("energyOnly",e)?_.filter(e.room.droppedResources,{resourceType:RESOURCE_ENERGY}):e.room.droppedResources;let r;return r=e.room.my&&e.room.situation.invasion?t=>this.isAddableTarget(t,e)&&t.pos.findInRange(e.room.sources,1).length>0:t=>this.isAddableTarget(t,e),e.pos.findClosestByPath(t,{filter:r})}),this.work=(e=>{let t=e.pickup(e.target);if(t==OK){if(e.sum<.8*e.carryCapacity){let r=e.pos.findInRange(e.room.droppedResources,1,{filter:t=>t.resourceType!=RESOURCE_ENERGY&&this.isAddableTarget(t,e)});if((!r||r.length<1)&&(r=e.pos.findInRange(e.room.droppedResources,1,{filter:t=>this.isAddableTarget(t,e)})),r&&r.length>0)return this.assign(e,r[0]),t}if(e.sum<e.carryCapacity){let r=e.pos.findInRange(e.room.structures.container.in,2,{filter:t=>Creep.action.uncharging.isValidTarget(t,e)});if(r&&r.length>0)return Creep.action.uncharging.assign(e,r[0]),t}delete e.data.actionName,delete e.data.targetId}return t}),this.setDefault({energyOnly:!0})}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(0);t.default=new class extends o.CreepAction{constructor(){super("reallocating"),this.getLabOrder=(e=>{if(!e)return null;let t=null,r=e.room;if(!r.memory||!r.memory.resources)return null;let o=r.memory.resources.lab.find(t=>t.id==e.id);if(o){let e=o.orders;for(let r=0;r<e.length;r++)if(e[r].type!=RESOURCE_ENERGY&&(e[r].orderRemaining>0||e[r].storeAmount>0)){t=e[r];break}}return t}),this.findNeeding=((e,t,r,o)=>{r||(r=1);const i=e.structures.labs.all;if(i.length>0)for(let e=0;e<i.length;e++){const a=Game.getObjectById(i[e].id);let s=0;if(a&&(s=a.getNeeds(t)),s>=r&&(0===a.mineralAmount||a.mineralType==t||t==RESOURCE_ENERGY)&&a.id!=o)return{structure:a,amount:s}}const a=e.structures.powerSpawns.all;if(a.length>0)for(let e=0;e<a.length;e++){const i=Game.getObjectById(a[e].id);let s=0;if(i&&(s=i.getNeeds(t)),s>=r&&(t==RESOURCE_POWER||t==RESOURCE_ENERGY)&&i.id!=o)return{structure:i,amount:s}}const s=e.structures.container.all;if(s.length>0)for(let e=0;e<s.length;e++){const i=Game.getObjectById(s[e].id);let a=0;if(i&&(a=i.getNeeds(t)),a>=r&&i.id!=o)return{structure:i,amount:a}}const n=e.terminal;if(n&&n.active){let e=n.getNeeds(t);if(e>=r&&n.id!=o)return{structure:n,amount:e}}let l=e.storage;if(l&&l.active){let e=l.getNeeds(t);if(e>=r&&l.id!=o)return{structure:l,amount:e}}return l&&l.active&&(t==RESOURCE_ENERGY||t==RESOURCE_POWER)&&l.storeCapacity-l.sum>r?{structure:l,amount:0}:n&&n.active&&t!=RESOURCE_ENERGY&&t!=RESOURCE_POWER&&n.storeCapacity-n.sum>r?{structure:n,amount:0}:null}),this.newTargetLab=(e=>{let t=e.room,r=t.memory;if(r&&r.labs&&r.labs.length>0)for(let o=0;o<r.labs.length;o++){let i=r.labs[o],a=Game.getObjectById(i.id);if(!a)continue;let s=0;if(a.mineralAmount>0){if((s=a.getNeeds(a.mineralType))<0){let r;if(DEBUG&&TRACE&&Util.trace("Action",{actionName:"reallocating",roomName:t.name,creepName:e.name,structureId:a.id,resourceType:a.mineralType,needs:s}),r=this.findNeeding(t,a.mineralType))return DEBUG&&TRACE&&Util.trace("Action",{actionName:"reallocating",roomName:t.name,creepName:e.name,targetStructureId:r.structure.id,resourceType:a.mineralType,targetNeeds:r.amount}),a}if(s>0){if(DEBUG&&TRACE&&Util.trace("Action",{actionName:"reallocating",roomName:t.name,creepName:e.name,structureId:a.id,resourceType:a.mineralType,needs:s}),t.storage&&t.storage.active&&t.storage.store[a.mineralType])return DEBUG&&TRACE&&Util.trace("Action",{actionName:"reallocating",roomName:t.name,creepName:e.name,targetStructureId:t.storage.id,resourceType:a.mineralType,targetNeeds:t.storage.store[a.mineralType]}),e.data.reallocating=a.mineralType,t.storage;if(t.terminal&&t.terminal.active&&t.terminal.getNeeds(a.mineralType)<0)return DEBUG&&TRACE&&Util.trace("Action",{actionName:"reallocating",roomName:t.name,creepName:e.name,targetStructureId:t.terminal.id,resourceType:a.mineralType,targetNeeds:t.terminal.store[a.mineralType]}),e.data.reallocating=a.mineralType,t.terminal;let r=t.findContainerWith(a.mineralType);if(r)return DEBUG&&TRACE&&Util.trace("Action",{actionName:"reallocating",roomName:t.name,creepName:e.name,targetStructureId:r.structure.id,resourceType:a.mineralType,targetNeeds:r.amount}),e.data.reallocating=a.mineralType,r.structure;!ROOM_TRADING||MAKE_COMPOUNDS||ALLOCATE_COMPOUNDS||a.mineralType==RESOURCE_ENERGY||a.mineralType==t.mineralType||_.some(t.memory.resources.orders,{type:a.mineralType})||t.placeRoomOrder(a.id,a.mineralType,s)}}else{let r=this.getLabOrder(a),o=null;if(r){o=r.type;let i=r.orderRemaining+r.storeAmount;if(DEBUG&&TRACE&&Util.trace("Action",{actionName:"reallocating",roomName:t.name,creepName:e.name,structureId:a.id,resourceType:o,needs:i}),t.storage&&t.storage.active&&t.storage.store[o])return DEBUG&&TRACE&&Util.trace("Action",{actionName:"reallocating",roomName:t.name,creepName:e.name,targetStructureId:t.storage.id,resourceType:o,targetNeeds:t.storage.store[o]}),e.data.reallocating=o,t.storage;if(t.terminal&&t.terminal.active&&t.terminal.getNeeds(o)<0)return DEBUG&&TRACE&&Util.trace("Action",{actionName:"reallocating",roomName:t.name,creepName:e.name,targetStructureId:t.terminal.id,resourceType:o,targetNeeds:t.terminal.store[o]}),e.data.reallocating=o,t.terminal;let s=t.findContainerWith(o);if(s)return DEBUG&&TRACE&&Util.trace("Action",{actionName:"reallocating",roomName:t.name,creepName:e.name,targetStructureId:s.structure.id,resourceType:o,targetNeeds:s.amount}),e.data.reallocating=o,s.structure;!ROOM_TRADING||MAKE_COMPOUNDS||ALLOCATE_COMPOUNDS||o==RESOURCE_ENERGY||o==t.mineralType||_.some(t.memory.resources.orders,{type:a.mineralType})||t.placeRoomOrder(a.id,o,r.orderRemaining)}}if((s=a.getNeeds(RESOURCE_ENERGY))<0){DEBUG&&TRACE&&Util.trace("Action",{actionName:"reallocating",roomName:t.name,creepName:e.name,structureId:a.id,resourceType:RESOURCE_ENERGY,needs:s});let r=this.findNeeding(t,RESOURCE_ENERGY);if(r)return DEBUG&&TRACE&&Util.trace("Action",{actionName:"reallocating",roomName:t.name,creepName:e.name,targetStructureId:r.structure.id,resourceType:RESOURCE_ENERGY,targetNeeds:r.amount}),a}if(s>0){if(DEBUG&&TRACE&&Util.trace("Action",{actionName:"reallocating",roomName:t.name,creepName:e.name,structureId:a.id,resourceType:RESOURCE_ENERGY,needs:s}),t.storage&&t.storage.active&&t.storage.charge>.5)return DEBUG&&TRACE&&Util.trace("Action",{actionName:"reallocating",roomName:t.name,creepName:e.name,targetStructureId:t.storage.id,resourceType:RESOURCE_ENERGY,targetNeeds:t.storage.store[RESOURCE_ENERGY]}),e.data.reallocating=RESOURCE_ENERGY,t.storage;if(t.terminal&&t.terminal.active&&t.terminal.getNeeds(RESOURCE_ENERGY)<0)return DEBUG&&TRACE&&Util.trace("Action",{actionName:"reallocating",roomName:t.name,creepName:e.name,targetStructureId:t.terminal.id,resourceType:RESOURCE_ENERGY,targetNeeds:t.terminal.store[RESOURCE_ENERGY]}),e.data.reallocating=RESOURCE_ENERGY,t.terminal;let r=t.findContainerWith(RESOURCE_ENERGY);if(r)return DEBUG&&TRACE&&Util.trace("Action",{actionName:"reallocating",roomName:t.name,creepName:e.name,targetStructureId:r.structure.id,resourceType:RESOURCE_ENERGY,targetNeeds:r.amount}),e.data.reallocating=RESOURCE_ENERGY,r.structure}}return null}),this.newTargetPowerSpawn=(e=>{const t=e.room,r=t.structures.powerSpawns.all;if(r.length>0)for(let o=0;o<r.length;o++){const i=Game.getObjectById(r[o].id);if(!i)continue;let a=0;if((a=i.getNeeds(RESOURCE_ENERGY))>0){if(DEBUG&&TRACE&&Util.trace("Action",{actionName:"reallocating",roomName:t.name,creepName:e.name,structureId:i.id,resourceType:RESOURCE_ENERGY,needs:a}),t.storage&&t.storage.active&&t.storage.charge>.5)return DEBUG&&TRACE&&Util.trace("Action",{actionName:"reallocating",roomName:t.name,creepName:e.name,targetStructureId:t.storage.id,resourceType:RESOURCE_ENERGY,targetNeeds:t.storage.store[RESOURCE_ENERGY]}),e.data.reallocating=RESOURCE_ENERGY,t.storage;if(t.terminal&&t.terminal.active&&t.terminal.getNeeds(RESOURCE_ENERGY)<0)return DEBUG&&TRACE&&Util.trace("Action",{actionName:"reallocating",roomName:t.name,creepName:e.name,targetStructureId:t.terminal.id,resourceType:RESOURCE_ENERGY,targetNeeds:t.terminal.store[RESOURCE_ENERGY]}),e.data.reallocating=RESOURCE_ENERGY,t.terminal;let r=t.findContainerWith(RESOURCE_ENERGY);if(r)return DEBUG&&TRACE&&Util.trace("Action",{actionName:"reallocating",roomName:t.name,creepName:e.name,targetStructureId:r.structure.id,resourceType:RESOURCE_ENERGY,targetNeeds:r.amount}),e.data.reallocating=RESOURCE_ENERGY,r.structure}if((a=i.getNeeds(RESOURCE_POWER))>0){if(DEBUG&&TRACE&&Util.trace("Action",{actionName:"reallocating",roomName:t.name,creepName:e.name,structureId:i.id,resourceType:RESOURCE_POWER,needs:a}),t.storage&&t.storage.active&&t.storage.store[RESOURCE_POWER])return DEBUG&&TRACE&&Util.trace("Action",{actionName:"reallocating",roomName:t.name,creepName:e.name,targetStructureId:t.storage.id,resourceType:RESOURCE_POWER,targetNeeds:t.storage.store[RESOURCE_POWER]}),e.data.reallocating=RESOURCE_POWER,t.storage;if(t.terminal&&t.terminal.active&&t.terminal.getNeeds(RESOURCE_POWER)<0)return DEBUG&&TRACE&&Util.trace("Action",{actionName:"reallocating",roomName:t.name,creepName:e.name,targetStructureId:t.terminal.id,resourceType:RESOURCE_POWER,targetNeeds:t.terminal.store[RESOURCE_POWER]}),e.data.reallocating=RESOURCE_POWER,t.terminal;let r=t.findContainerWith(RESOURCE_POWER);if(r)return DEBUG&&TRACE&&Util.trace("Action",{actionName:"reallocating",roomName:t.name,creepName:e.name,targetStructureId:r.structure.id,resourceType:RESOURCE_POWER,targetNeeds:r.amount}),e.data.reallocating=RESOURCE_POWER,r.structure}}return null}),this.newTargetContainer=(e=>{const t=e.room,r=t.structures.container.all;if(r.length>0)for(let o=0;o<r.length;o++){const i=Game.getObjectById(r[o].id);if(i){for(let r in i.store){let o=i.getNeeds(r);if(r&&o<0){DEBUG&&TRACE&&Util.trace("Action",{actionName:"reallocating",roomName:t.name,creepName:e.name,structureId:i.id,resourceType:r,needs:o});let a=this.findNeeding(t,r);if(a)return DEBUG&&TRACE&&Util.trace("Action",{actionName:"reallocating",roomName:t.name,creepName:e.name,targetStructureId:a.structure.id,resourceType:r,targetNeeds:a.amount}),e.data.reallocating=r,i}}if(t.memory.resources){let r=t.memory.resources.container.find(e=>e.id==i.id);if(r){let o=r.orders;for(let r=0;r<o.length;r++){let a=o[r].type,s=i.getNeeds(a);if(s>0){if(DEBUG&&TRACE&&Util.trace("Action",{actionName:"reallocating",roomName:t.name,creepName:e.name,structureId:i.id,resourceType:resource,needs:s}),t.storage&&t.storage.active&&t.storage.store[a]&&!(a==RESOURCE_ENERGY&&t.storage.charge<.5))return DEBUG&&TRACE&&Util.trace("Action",{actionName:"reallocating",roomName:t.name,creepName:e.name,targetStructureId:t.storage.id,resourceType:resource,targetNeeds:t.storage.store[resource]}),e.data.reallocating=resource,t.storage;if(t.terminal&&t.terminal.active&&t.terminal.getNeeds(a)<0)return DEBUG&&TRACE&&Util.trace("Action",{actionName:"reallocating",roomName:t.name,creepName:e.name,targetStructureId:t.terminal.id,resourceType:resource,targetNeeds:t.terminal.store[resource]}),e.data.reallocating=resource,t.terminal}}}}}}return null}),this.newTargetTerminal=(e=>{let t=e.room,r=e.room.terminal;if(r&&r.active){for(let o in r.store){let i=-r.getNeeds(o);if(i>0){DEBUG&&TRACE&&Util.trace("Action",{actionName:"reallocating",roomName:t.name,creepName:e.name,structureId:r.id,resourceType:o,needs:-i});let a=this.findNeeding(t,o,1,r.id);if(a&&a.structure.id!=r.id)return DEBUG&&TRACE&&Util.trace("Action",{actionName:"reallocating",roomName:t.name,creepName:e.name,targetStructureId:a.structure.id,resourceType:o,targetNeeds:a.amount}),e.data.reallocating=o,r}}if(t.memory.resources&&t.memory.resources.terminal[0]){let o=t.memory.resources.terminal[0].orders.slice();o.push(RESOURCE_ENERGY);let i=null,a=0;for(let s=0;s<o.length;s++)if(i=o[s].type,(a=r.getNeeds(i))>0&&(DEBUG&&TRACE&&Util.trace("Action",{actionName:"reallocating",roomName:t.name,creepName:e.name,structureId:r.id,resourceType:i,needs:a}),t.storage&&t.storage.active&&t.storage.store[i]&&!(i==RESOURCE_ENERGY&&t.storage.charge<.5)))return DEBUG&&TRACE&&Util.trace("Action",{actionName:"reallocating",roomName:t.name,creepName:e.name,targetStructureId:t.storage.id,resourceType:i,targetNeeds:t.storage.store[i]}),e.data.reallocating=i,t.storage}}return null}),this.newTargetStorage=(e=>{let t=e.room,r=e.room.storage;if(r&&r.active)for(let o in r.store){let i=-r.getNeeds(o);if(o&&i>0){DEBUG&&TRACE&&Util.trace("Action",{actionName:"reallocating",roomName:t.name,creepName:e.name,structureId:r.id,resourceType:o,needs:-i});let a=this.findNeeding(t,o,1,r.id);if(a)return DEBUG&&TRACE&&Util.trace("Action",{actionName:"reallocating",roomName:t.name,creepName:e.name,targetStructureId:a.structure.id,resourceType:o,targetNeeds:a.amount}),e.data.reallocating=o,r}}return null}),this.isValidAction=(e=>!0),this.isValidTarget=(e=>!0),this.isAddableAction=(e=>{let t=e.room.population;return 0==e.sum&&(!t||!t.actionCount[this.name]||t.actionCount[this.name]<this.maxPerAction)}),this.isAddableTarget=(e=>!0),this.newTarget=(e=>{let t=e.room;DEBUG&&TRACE&&Util.trace("Action",{actionName:"reallocating",roomName:t.name,creepName:e.name,subAction:"newTarget"});let r=null;if(0==e.sum)return t.memory&&(null===(r=this.newTargetLab(e))&&(r=this.newTargetPowerSpawn(e)),null===r&&(r=this.newTargetContainer(e)),null===r&&(r=this.newTargetTerminal(e)),null===r&&(r=this.newTargetStorage(e))),r;{let r=Object.keys(e.carry)[0],o=this.findNeeding(t,r);return DEBUG&&TRACE&&Util.trace("Action",{actionName:"reallocating",roomName:t.name,creepName:e.name,subAction:"assignDropOff",targetStructureId:o.structure.id,resourceType:r,targetNeeds:o.amount}),o?o.structure:null}}),this.cancelAction=(e=>{delete e.data.actionName,delete e.data.targetId,e.action=null,e.target=null,delete e.data.path}),this.unloadStructure=((e,t,r,o)=>{let i=Math.min(o,e.carryCapacity-e.sum),a=e.withdraw(t,r,i);return DEBUG&&TRACE&&Util.trace("Action",{actionName:"reallocating",roomName:e.room.name,creepName:e.name,subAction:"unloadStructure",structureId:t.id,resourceType:r,amount:i,result:a}),a}),this.loadStructure=((e,t,r,o)=>{let i=null,a=e.room,s=Math.min(o,e.carry[r]||0);if(s>0&&(i=e.transfer(t,r,s)),i==OK){let e=null;if(a.memory.resources&&(e=a.memory.resources[t.structureType].find(e=>e.id==t.id)),e&&e.orders){let t=e.orders.find(e=>e.type==r);t&&t.orderRemaining>0&&(t.orderRemaining-=s)}}return DEBUG&&TRACE&&Util.trace("Action",{actionName:"reallocating",roomName:e.room.name,creepName:e.name,subAction:"loadStructure",structureId:t.id,resourceType:r,amount:s,result:i}),i}),this.assignDropOff=((e,t)=>{let r=this.findNeeding(e.room,t,1,e.target.id);r&&(DEBUG&&TRACE&&Util.trace("Action",{actionName:"reallocating",roomName:e.room.name,creepName:e.name,subAction:"assignDropOff",targetStructureId:r.structure.id,resourceType:t,amount:r.amount}),this.assign(e,r.structure))}),this.unloadLab=(e=>{let t=e.target,r=null,o=null,i=0;return(i=-t.getNeeds(RESOURCE_ENERGY))>0&&(o=RESOURCE_ENERGY),o||(i=-t.getNeeds(t.mineralType))>0&&(o=t.mineralType),o&&(r=this.unloadStructure(e,t,o,i)),DEBUG&&TRACE&&Util.trace("Action",{actionName:"reallocating-unloadLab",roomName:room.name,creepName:e.name,structureId:t.id,resourceType:o,needs:i,workResult:r}),r==OK?this.assignDropOff(e,o):this.cancelAction(e),r}),this.unloadPowerSpawn=(e=>{let t=e.target,r=null,o=null,i=0;return(i=-t.getNeeds(RESOURCE_ENERGY))>0&&(o=RESOURCE_ENERGY),o||(i=-t.getNeeds(RESOURCE_POWER))>0&&(o=RESOURCE_POWER),o&&(r=this.unloadStructure(e,t,o,i)),DEBUG&&TRACE&&Util.trace("Action",{actionName:"reallocating-unloadPowerSpawn",roomName:room.name,creepName:e.name,structureId:t.id,resourceType:o,needs:i,workResult:r}),r==OK?this.assignDropOff(e,o):this.cancelAction(e),r}),this.unloadContainer=(e=>{let t=e.target,r=null,o=null,i=0,a=Object.keys(t.store);e.data.reallocating&&(a.unshift(e.data.reallocating),delete e.data.reallocating);for(let e=0;e<a.length;e++){let r=a[e];if(r&&t.store[r]>0&&(t.structureType==STRUCTURE_LAB||t.getNeeds(r)<0)){let e=this.findNeeding(room,r,1,t.id);if(e&&(i=e.amount),i>0){o=r;break}if(storage&&storage.active&&e&&e.structure.structureType==STRUCTURE_STORAGE&&r==RESOURCE_ENERGY){i=storage.storeCapacity-storage.sum,o=r;break}}}return o&&(r=this.unloadStructure(e,t,o,i)),DEBUG&&TRACE&&Util.trace("Action",{actionName:"reallocating-unloadContainer",roomName:room.name,creepName:e.name,structureId:t.id,resourceType:o,needs:i,workResult:r}),r==OK?this.assignDropOff(e,o):this.cancelAction(e),r}),this.unloadTerminal=(e=>{let t=e.target,r=e.room,o=r.storage,i=null,a=null,s=0,n=Object.keys(t.store);e.data.reallocating&&(n.unshift(e.data.reallocating),delete e.data.reallocating);for(let e=0;e<n.length;e++){let i=n[e];if(i&&t.store[i]>0&&(t.structureType==STRUCTURE_LAB||t.getNeeds(i)<0)){let e=this.findNeeding(r,i,1,t.id);if(e&&(s=e.amount),s>0){a=i;break}if(o&&o.active&&e&&e.structure.structureType==STRUCTURE_STORAGE&&i==RESOURCE_ENERGY){s=o.storeCapacity-o.sum,a=i;break}}}return a&&(s=Math.min(s,t.store[a]||0,e.carryCapacity-e.sum),i=this.unloadStructure(e,t,a,s)),DEBUG&&TRACE&&Util.trace("Action",{actionName:"reallocating-unloadTerminal",roomName:r.name,creepName:e.name,structureId:t.id,resourceType:a,needs:s,workResult:i}),i==OK?this.assignDropOff(e,a):this.cancelAction(e),i}),this.unloadStorage=(e=>{let t=e.target,r=e.room,o=r.terminal,i=null,a=null,s=0,n=Object.keys(t.store);e.data.reallocating&&(n.unshift(e.data.reallocating),delete e.data.reallocating);for(let i=0;i<n.length;i++){let l=n[i];if(l&&t.store[l]>0){if(l==RESOURCE_ENERGY&&t.charge<.5)continue;let i=this.findNeeding(r,l,1,t.id);if(DEBUG&&TRACE&&Util.trace("Action",{actionName:"reallocating",subAction:"findNeeding",roomName:r.name,creepName:e.name,structureId:i&&i.structure.id,resourceType:l,amount:i&&i.amount}),i&&i.structure.id==t.id&&(i=null),i&&(s=i.amount),s>0){a=l;break}if(o&&o.active&&i&&i.structure.structureType==STRUCTURE_TERMINAL&&l!=RESOURCE_ENERGY&&l!=RESOURCE_POWER){s=o.storeCapacity-o.sum,a=l;break}}}return a&&(s=Math.min(s,t.store[a]||0,e.carryCapacity-e.sum),i=this.unloadStructure(e,t,a,s)),DEBUG&&TRACE&&Util.trace("Action",{actionName:"reallocating-unloadStorage",roomName:r.name,creepName:e.name,structureId:t.id,resourceType:a,needs:s,workResult:i}),i==OK?this.assignDropOff(e,a):this.cancelAction(e),i}),this.loadLab=(e=>{let t=e.target,r=e.room,o=null,i=null,a=0;if((a=t.getNeeds(RESOURCE_ENERGY))>0&&(e.carry.energy||0)>0)i=RESOURCE_ENERGY;else{let r=this.getLabOrder(t);r&&(i=r.type),(a=t.getNeeds(i))>0&&(e.carry[i]||0)>0||(i=null)}return i&&(o=this.loadStructure(e,t,i,a)),DEBUG&&TRACE&&Util.trace("Action",{actionName:"reallocating-loadLab",roomName:r.name,creepName:e.name,structureId:t.id,resourceType:i,needs:a,workResult:o}),(e.carry[i]||0)>1?this.assignDropOff(e,i):this.cancelAction(e),o}),this.loadPowerSpawn=(e=>{let t=e.target,r=e.room,o=null,i=null,a=0;return r.memory.resources&&void 0===r.memory.resources.powerSpawn&&(r.memory.resources.powerSpawn=[]),(a=t.getNeeds(RESOURCE_ENERGY))>0&&(e.carry.energy||0)>0?i=RESOURCE_ENERGY:(a=t.getNeeds(RESOURCE_POWER))>0&&(e.carry[RESOURCE_POWER]||0)>0&&(i=RESOURCE_POWER),i&&(o=this.loadStructure(e,t,i,a)),DEBUG&&TRACE&&Util.trace("Action",{actionName:"reallocating-loadPowerSpawn",roomName:r.name,creepName:e.name,structureId:t.id,resourceType:i,needs:a,workResult:o}),(e.carry[i]||0)>a?this.assignDropOff(e,i):this.cancelAction(e),o}),this.loadContainer=(e=>{let t=e.target,r=e.room,o=null,i=null,a=0;for(let r in e.carry)if((!r||0!=e.carry[r])&&(a=t.getNeeds(r))>0){i=r;break}return i&&(o=this.loadStructure(e,t,i,a)),DEBUG&&TRACE&&Util.trace("Action",{actionName:"reallocating-loadContainer",roomName:r.name,creepName:e.name,structureId:t.id,resourceType:i,needs:a,workResult:o}),(e.carry[i]||0)>a?this.assignDropOff(e,i):this.cancelAction(e),o}),this.loadTerminal=(e=>{let t=e.target,r=e.room,o=null,i=null,a=0;for(let r in e.carry)if(!r||0!=e.carry[r]){if((a=t.getNeeds(r))>0){i=r;break}if(r!=RESOURCE_ENERGY&&r!=RESOURCE_POWER){i=r,a=t.storeCapacity-t.sum;break}}return i&&(o=this.loadStructure(e,t,i,a)),DEBUG&&TRACE&&Util.trace("Action",{actionName:"reallocating-loadTerminal",roomName:r.name,creepName:e.name,structureId:t.id,resourceType:i,needs:a,workResult:o}),(e.carry[i]||0)>a?this.assignDropOff(e,i):this.cancelAction(e),o}),this.loadStorage=(e=>{let t=e.target,r=e.room,o=null,i=null,a=0;for(let r in e.carry)if((!r||0!=e.carry[r])&&(a=t.getNeeds(r))>0){i=r;break}return i&&(o=this.loadStructure(e,t,i,a)),DEBUG&&TRACE&&Util.trace("Action",{actionName:"reallocating-loadStorage",roomName:r.name,creepName:e.name,structureId:t.id,resourceType:i,needs:a,workResult:o}),(e.carry[i]||0)>a?this.assignDropOff(e,i):this.cancelAction(e),o}),this.work=(e=>{let t=null,r=e.room,o=e.target;if(r.storage,r.terminal,0==e.sum)switch(o.structureType){case STRUCTURE_LAB:t=this.unloadLab(e);break;case STRUCTURE_POWER_SPAWN:this.cancelAction(e);break;case STRUCTURE_CONTAINER:t=this.unloadContainer(e);break;case STRUCTURE_TERMINAL:t=this.unloadTerminal(e);break;case STRUCTURE_STORAGE:t=this.unloadStorage(e);break;default:this.cancelAction(e)}else switch(o.structureType){case STRUCTURE_LAB:t=this.loadLab(e);break;case STRUCTURE_POWER_SPAWN:t=this.loadPowerSpawn(e);break;case STRUCTURE_CONTAINER:t=this.loadContainer(e);break;case STRUCTURE_TERMINAL:t=this.loadTerminal(e);break;case STRUCTURE_STORAGE:t=this.loadStorage(e);break;default:this.cancelAction(e)}return t})}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(0);t.default=new class extends o.CreepAction{constructor(){super("recycling"),this.isValidAction=(()=>!0),this.isAddableAction=(()=>!0),this.isAddableTarget=(()=>!0),this.newTarget=(e=>{let t=null;return e.room.my&&e.room.structures.spawns.length>0&&(t=e.pos.findClosestByRange(e.room.structures.spawns)),null==t&&(t=Game.spawns[e.data.motherSpawn]),null==t&&(t=e.pos.findClosestSpawn()),t}),this.work=(e=>{e.target.recycleCreep(e)})}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(0);t.default=new class extends o.CreepAction{constructor(){super("repairing"),this.targetRange=3,this.maxPerTarget=1,this.reachedRange=(e=>e.getStrategyHandler([this.name],"reachedRange",e)),this.isValidAction=(e=>e.carry.energy>0),this.isValidTarget=(e=>null!=e&&e.hits&&e.hits<e.hitsMax),this.isAddableTarget=((e,t)=>(e instanceof OwnedStructure&&e.my||!t.room.controller||(!t.room.controller.owner||t.room.controller.my)&&(!t.room.controller.reservation||t.room.controller.reservation.username==t.owner.username))&&(!e.targetOf||e.targetOf.length<this.maxPerTarget)),this.newTarget=(e=>_.find(e.room.structures.urgentRepairable,t=>this.isAddableTarget(t,e))),this.work=(e=>(e.getStrategyHandler([this.name],"getEnergy",e),e.repair(e.target))),this.setDefault({eachedRange:1,getEnergy:e=>!1})}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(0);t.default=new class extends o.CreepAction{constructor(){super("reserving"),this.isValidAction=(e=>!0),this.isValidTarget=(e=>e&&(!e.reservation||e.reservation.ticksToEnd<4999)),this.isAddableAction=(()=>!0),this.isAddableTarget=((e,t)=>e&&(e instanceof Flag||"controller"===e.structureType&&!e.owner)),this.newTarget=(e=>{let t;return e.data.destiny&&(t=Game.flags[e.data.destiny.targetName||e.data.destiny.flagName]),t||(t=Flag.find(e=>Flag.compare(e,FLAG_COLOR.claim.reserve)||Flag.compare(e,FLAG_COLOR.invade.exploit),e.pos,!1,Flag.reserveMod,e.name)),t?(Population.registerCreepFlag(e,t),e.flag.room&&e.flag.pos.roomName==e.pos.roomName?e.flag.room.controller:e.flag):null}),this.step=(e=>{if(CHATTY&&e.say(this.name,SAY_PUBLIC),e.target.color)return e.flag.pos.roomName==e.pos.roomName&&(e.data.targetId=null),e.travelTo(e.target.pos);let t=e.pos.getRangeTo(e.target);if(t<=this.targetRange){let r=this.work(e);return r!=OK&&e.handleError({errorCode:r,action:this.name,target:e.target,range:t,creep:e}),r}return e.travelTo(e.target.pos)}),this.work=(e=>{let t;return e.controllerSign(),t=e.target.owner&&!e.target.my?e.attackController(e.target):e.reserveController(e.target)})}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(0);t.default=new class extends o.CreepAction{constructor(){super("robbing"),this.maxPerTarget=2,this.maxPerAction=10,this.scoreMultiplier=1/Math.log(1.2),this.minimumTTL=500,this.isValidAction=(e=>e.sum<.95*e.carryCapacity&&!e.room.my),this.isValidTarget=(e=>!_.some(e.pos.lookFor(LOOK_STRUCTURES),{structureType:STRUCTURE_RAMPART,isPublic:!1,my:!1})&&e.structureType!==STRUCTURE_NUKER&&e.structureType!==STRUCTURE_POWER_SPAWN&&(e.store||e.energy||e.mineralAmount)),this.newTarget=(e=>{const t=e.room.structures.all;if(t.length){const r=_.chain(t).filter(e=>this.isValidTarget(e)).map(this.targetScore(e)).filter("score").sortBy("score").reverse().value();return _.get(r,[0,"target"],null)}return!1}),this.work=(e=>{const t=e.getStrategyHandler([this.name],"resourceValue",e),r=_.chain(Util.resources()).filter(t).sortBy(t).values().value();return this.targetCall(e,r,t=>(r,o,i)=>{const a=o?e.withdraw(t,r,o):0;return a?{amount:i,score:a}:{amount:o,score:a}})(e.target)}),this.targetScore=(e=>{const t=e.getStrategyHandler([this.name],"resourceValue",e),r=_.chain(Util.resources()).filter(t).sortBy(t).values().value();return this.targetCall(e,r,r=>e.getStrategyHandler([this.name],"resourceScore",e,r,t))}),this.targetCall=((e,t,r)=>o=>{const i=r(o);let a=0;return{target:o,score:a=o.store?this.storeCall(e,o,o.store,Util.valueOrZero,i,t):o.structureType===STRUCTURE_LAB?this.storeCall(e,o,{[RESOURCE_ENERGY]:o.energy,[o.mineralType]:o.mineralAmount},Util.valueOrZero,i):this.storeCall(e,o,{[RESOURCE_ENERGY]:o.energy},Util.valueOrZero,i)}}),this.storeCall=((e,t,r,o,i,a)=>{let s=e.carryCapacity-e.sum,n=0;a||(a=_.keys(r));for(let e=a.length-1;e>=0&&0!==s;e--){const t=a[e],l=Math.min(o(r[t]),s),{amount:m,score:c}=i(t,l<1?0:l,s);s-=m,n+=c}return n}),this.setDefault({moveOptions:e=>e,resourceValue:e=>{let t=e.ticksToLive<this.minimumTTL;if(!t&&e.data.homeRoom){const r=Game.rooms[e.data.homeRoom];t=r&&!r.storage}return t?e=>e===RESOURCE_ENERGY?1:0:e=>e===RESOURCE_ENERGY?.2:e===RESOURCE_POWER?500:e.length},resourceScore:(e,t,r)=>{const o=e.pos.getRangeTo(t),i=this.scoreMultiplier;return(e,t,a)=>0===t?{amount:0,score:0}:{amount:t,score:r(e)*t*(50-Math.log1p(o)*i)}}})}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(0);t.default=new class extends o.CreepAction{constructor(){super("safeGen"),this.maxPerAction=1,this.isValidAction=(e=>e.carryCapacity-_.sum(e.carry)>=1e3||e.carry[RESOURCE_GHODIUM]&&e.carry[RESOURCE_GHODIUM]>=1e3),this.newTarget=(e=>{let t=null;return!e.carry[RESOURCE_GHODIUM]||e.carry[RESOURCE_GHODIUM]<1e3?e.room.storage&&e.room.storage.store[RESOURCE_GHODIUM]&&e.room.storage.store[RESOURCE_GHODIUM]>=1e3?t=e.room.storage:e.room.terminal&&e.room.terminal.store[RESOURCE_GHODIUM]&&e.room.terminal.store[RESOURCE_GHODIUM]>=1e3&&(t=e.room.terminal):t=e.room.controller,t}),this.unloadStructure=(e=>{let t=0;return t=e.carry[RESOURCE_GHODIUM]?1e3-e.carry[RESOURCE_GHODIUM]:1e3,e.withdraw(e.target,RESOURCE_GHODIUM,t)}),this.generateSafeMode=(e=>e.generateSafeMode(e.target)),this.work=(e=>{let t=null;switch(e.target.structureType){case STRUCTURE_STORAGE:case STRUCTURE_TERMINAL:t=this.unloadStructure(e);break;case STRUCTURE_CONTROLLER:t=this.generateSafeMode(e);break;default:"safeGen"==e.data.creepType&&Game.flags[e.data.destiny.targetName]&&Game.flags[e.data.destiny.targetName].remove(),this.cancelAction(e)}return t}),this.cancelAction=(e=>{delete e.data.actionName,delete e.data.targetId,e.action=null,e.target=null,delete e.data.path})}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(0);t.default=new class extends o.CreepAction{constructor(){super("storing"),this.isValidAction=(e=>e.room.storage&&e.room.storage.isActive()&&e.sum>0),this.isValidTarget=(e=>e&&e.store&&e.active&&e.sum<e.storeCapacity),this.isAddableTarget=((e,t)=>e.my&&(!e.targetOf||e.targetOf.length<this.maxPerTarget)&&e.sum+t.carry[RESOURCE_ENERGY]<e.storeCapacity),this.isValidMineralToTerminal=(e=>e.storage.store[e.mineralType]&&e.storage.store[e.mineralType]>1.05*MAX_STORAGE_MINERAL&&e.terminal.sum-e.terminal.store.energy+Math.max(e.terminal.store.energy,TERMINAL_ENERGY)<e.terminal.storeCapacity),this.newTarget=(e=>{let t=e.room.mineralType;return e.room.terminal&&e.room.terminal.active&&((e=>e.carry[t]&&e.carry[t]>0&&this.isValidMineralToTerminal(e.room))(e)||(e=>e.carry.energy>0&&e.room.storage.charge>.5&&e.room.terminal.store.energy<.95*TERMINAL_ENERGY&&e.room.terminal.sum<e.room.terminal.storeCapacity)(e))&&this.isAddableTarget(e.room.terminal,e)?e.room.terminal:this.isValidTarget(e.room.storage)&&this.isAddableTarget(e.room.storage,e)?e.room.storage:null}),this.work=(e=>{let t;for(let r in e.carry)if(e.carry[r]>0&&(t=e.transfer(e.target,r))!=OK)break;return delete e.data.actionName,delete e.data.targetId,t})}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(0);t.default=new class extends o.CreepAction{constructor(){super("travelling"),this.isValidTarget=(e=>null!==e),this.isAddableAction=(()=>!0),this.isAddableTarget=(()=>!0),this.newTarget=(e=>e.getStrategyHandler([this.name],"newTarget",e)),this.step=(e=>{CHATTY&&e.say(this.name,SAY_PUBLIC);let t=_.get(e,["data","travelRange"],this.targetRange),r=e.target;if(Flag.isSpecialFlag(e.target))if(e.data.travelRoom){const o=Game.rooms[e.data.travelRoom];o&&o.name===e.pos.roomName?(e.leaveBorder(),r=null):(t=_.get(e,["data","travelRange"],TRAVELLING_BORDER_RANGE||22),r=new RoomPosition(25,25,e.data.travelRoom))}else Util.logError(e.name+"Creep.action.travelling called with specialFlag target and travelRoom undefined."),r=null;if(r){if(e.pos.getRangeTo(r)<=t)return this.unregister(e);if(0===t&&e.pos.isNearTo(r)&&r.pos.lookFor(LOOK_CREEPS).length>0)return DEBUG&&Util.logSystem(e.name,"travelling.step: destination blocked, stopping."),this.unregister(e);e.travelTo(r,{range:t,ignoreCreeps:e.data.ignoreCreeps||!0})}else this.unregister(e)}),this.assignRoom=((e,t)=>{if(t)return _.isUndefined(e.data.travelRange)&&(e.data.travelRange=TRAVELLING_BORDER_RANGE||22),e.data.travelRoom=t,DEBUG&&TRACE&&Util.trace("Action",{creepName:e.name,assign:this.name,roomName:t,Action:"assign"}),this.assign(e,Flag.specialFlag());Util.logError(e.name+"Creep.action.travelling.assignRoom called with no room.")}),this.unregister=(e=>{delete e.action,delete e.target,delete e.data.actionName,delete e.data.ignoreCreeps,delete e.data.targetId,delete e.data.travelRoom,delete e.data.travelRange}),this.setDefault({newTarget:e=>e.data.travelPos||e.data.travelRoom?Flag.specialFlag():null})}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(0);t.default=new class extends o.CreepAction{constructor(){super("uncharging"),this.renewTarget=!1,this.maxPerTarget=1,this.isAddableAction=(e=>!0),this.isValidAction=(e=>e.getStrategyHandler([this.name],"isValidAction",e)),this.isValidTarget=((e,t)=>{if(!e)return!1;if("link"==e.structureType)return e.energy>0;if("container"==e.structureType){let r=0;return r=!0===e.source&&1==e.controller?e.storeCapacity*MANAGED_CONTAINER_TRIGGER:t.data.creepType.indexOf("remote")>=0?250:500,e.sum>r}return!1}),this.newTarget=(e=>{if(e.room.structures.links.storage.length>0){let t=e.room.structures.links.storage.find(e=>e.energy>0);if(t&&(!e.room.structures.links.controller.find(e=>e.energy<.15*e.energyCapacity)||t.energy<=.85*t.energyCapacity))return t}let t=this;if(e.room.structures.container.in.length>0){let r;r=e.data.creepType.indexOf("remote")>=0?250:500;let o=null,i=0,a=a=>{if(t.isValidTarget(a,e)){let t=a.sum;if(a.targetOf&&(t-=_.sum(a.targetOf.map(e=>"uncharging"==e.actionName?e.carryCapacityLeft:0))),t<Math.min(e.carryCapacity-e.sum,r))return;t>i&&(i=t,o=a)}};return _.forEach(e.room.structures.container.in,a),o}}),this.work=(e=>{let t=OK;if(!0===e.target.source&&1==e.target.controller){let r=e.target.sum-e.target.storeCapacity*(1-MANAGED_CONTAINER_TRIGGER);if(r<1)t=ERR_NOT_ENOUGH_RESOURCES;else{let o=e.carryCapacity-e.sum,i=_.min([e.target.store.energy,r,o]);e.target._sum-=i,t=e.withdraw(e.target,RESOURCE_ENERGY,i)}}else if(null!=e.target.store){let r=r=>{e.target.store[r]>0&&(t=e.withdraw(e.target,r))};_.forEach(Object.keys(e.target.store),r)}else t=e.withdraw(e.target,RESOURCE_ENERGY);return delete e.data.actionName,delete e.data.targetId,e.action=null,e.target=null,t}),this.setDefault({isValidAction:e=>e.sum<e.carryCapacity||!1})}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(0);t.default=new class extends o.CreepAction{constructor(){super("upgrading"),this.targetRange=3,this.reachedRange=3,this.isAddableAction=(e=>!e.room.storage||e.room.storage.charge>1||!e.room.storage.my&&e.room.storage.store.energy>0),this.isAddableTarget=((e,t)=>!!(8!==e.level||t.data&&"upgrader"===t.data.creepType)),this.isValidAction=(e=>e.carry.energy>0),this.isValidTarget=(e=>e&&"controller"===e.structureType&&e.my),this.newTarget=(e=>{const t=e.room.controller&&e.room.controller.my?e.room.controller:null;return this.isValidTarget(t)&&this.isAddableTarget(t,e)&&t}),this.work=((e,t)=>(t&&t<2&&e.controllerSign(),e.upgradeController(e.target)))}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(0);t.default=new class extends o.CreepAction{constructor(){super("withdrawing"),this.isValidAction=(e=>e.getStrategyHandler([this.name],"isValidAction",e)),this.isValidTarget=(e=>!(e instanceof StructureTerminal&&e.charge<=0)&&e&&!!e.store&&e.store[RESOURCE_ENERGY]),this.newTarget=(e=>{const t=e.room.terminal,r=e.room.storage,o=[];return t&&this.isValidTarget(t)?o.push(t):r&&this.isValidTarget(r)&&o.push(r),!!o.length&&_.max(o,"charge")}),this.work=(e=>e.withdraw(e.target,RESOURCE_ENERGY)),this.assignDebounce=((e,t,r)=>{const o=r||this.newTarget(e);if(o){if(!(o instanceof StructureStorage&&"storing"===e.data.lastAction&&e.data.lastTarget===e.room.storage.id))return this.assign(e,o);{const r={carry:{},owner:e.owner,pos:e.pos,room:e.room,sum:e.carryCapacity},i=e.room.storage.store[RESOURCE_ENERGY],a=i>e.carryCapacity?e.carryCapacity:i;r.carry[RESOURCE_ENERGY]=a;let s=null;const n=_.find(t,e=>!("storing"===e.name||!e.isValidAction(r)||!e.isAddableAction(r)||!(s=e.newTarget(r))));if(n&&this.assign(e,o))return e.data.nextAction=n.name,e.data.nextTarget=s.id,!0}}return!1}),this.setDefault({isValidAction:e=>!!((e.room.storage&&e.room.storage.store[RESOURCE_ENERGY]||e.room.terminal&&e.room.terminal.store[RESOURCE_ENERGY])&&"privateer"!==e.data.creepType&&e.sum<e.carryCapacity&&(!e.room.conserveForDefense||e.room.relativeEnergyAvailable<.8))})}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(0);t.default=new class extends o.CreepBehaviour{constructor(){super("claimer"),this.actions=(e=>[Creep.action.claiming,Creep.action.reserving,Creep.action.bulldozing]),this._run=this.run,this.run=(e=>{if(this._run(e),e.hits<e.hitsMax&&(!e.action||"travelling"!==e.action.name)&&e.data){if(!e.data.nearestHome||!Game.rooms[e.data.nearestHome]){const t=Room.bestSpawnRoomFor(e.pos.roomName);t&&(e.data.nearestHome=t.name)}e.data.nearestHome&&Creep.action.travelling.assignRoom(e,e.data.nearestHome)}DEBUG&&TRACE&&Util.trace("Behaviour",{creepName:e.name,run:e.action&&e.action.name||"none",[this.name]:"run",Behaviour:this.name})})}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(0);t.default=new class extends o.CreepBehaviour{constructor(){super("collapseWorker"),this.inflowActions=(e=>{let t=[Creep.action.picking,Creep.action.withdrawing,Creep.action.uncharging,Creep.action.harvesting,Creep.action.dismantling,Creep.action.reallocating];return e.sum>e.carry.energy&&t.unshift(Creep.action.storing),t}),this.outflowActions=(e=>{const t=e.room.situation.invasion&&e.room.controller&&e.room.controller.level>2;if(t)return[Creep.action.feeding,Creep.action.fueling,Creep.action.repairing];{let r=[Creep.action.feeding,Creep.action.fueling,Creep.action.charging,Creep.action.repairing,Creep.action.building,Creep.action.fortifying,Creep.action.upgrading];return t||(r.push(Creep.action.storing),r.push(Creep.action.dropping)),e.room.controller&&e.room.controller.ticksToDowngrade<500&&r.unshift(Creep.action.upgrading),r}}),this.needEnergy=(e=>Creep.behaviour.worker.needEnergy(e)),this.nextAction=(e=>e.pos.roomName!==e.data.homeRoom?(DEBUG&&TRACE&&Util.trace("Behaviour",{actionName:"travelling",behaviourName:this.name,creepName:e.name,assigned:!0,Behaviour:"nextAction",Action:"assign"}),Creep.action.travelling.assignRoom(e,e.data.homeRoom),!0):!e.room.collapsed&&(Util.set(e,["data","recycleTick"],Game.time+50),Game.time>=e.data.recycleTick)?(DEBUG&&TRACE&&Util.trace("Behaviour",{actionName:"recycling",behaviourName:this.name,creepName:e.name,assigned:!0,Behaviour:"nextAction",Action:"assign"}),this.assignAction(e,"recycling")):Creep.behaviour.worker.nextAction(e)),this.mergeState({default:{canWithdrawEnergy:(e,t)=>e=>e>0}})}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(0);t.default=new class extends o.CreepBehaviour{constructor(){super("hauler"),this.inflowActions=(e=>[Creep.action.uncharging,Creep.action.picking,Creep.action.withdrawing,Creep.action.reallocating]),this.outflowActions=(e=>{let t=[Creep.action.feeding,Creep.action.charging,Creep.action.fueling,Creep.action.storing];return(e.sum>e.carry.energy||!e.room.situation.invasion&&SPAWN_DEFENSE_ON_ATTACK&&e.room.conserveForDefense&&e.room.relativeEnergyAvailable>.8)&&t.unshift(Creep.action.storing),e.room.structures.urgentRepairable.length>0&&t.unshift(Creep.action.fueling),t}),this.nextAction=(e=>e.pos.roomName!=e.data.homeRoom&&Game.rooms[e.data.homeRoom]&&Game.rooms[e.data.homeRoom].controller?Creep.action.travelling.assignRoom(e,e.data.homeRoom):this.nextEnergyAction(e)),this.setState({picking:{name:`picking-${this.name}`,energyOnly:!1}})}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(0);t.default=new class extends o.CreepBehaviour{constructor(){super("healer"),this.actions=(e=>[Creep.action.healing,Creep.action.guarding]),this._invalidAction=this.invalidAction,this.invalidAction=(e=>this._invalidAction(e)||"guarding"===e.action.name)}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(0);t.default=new class extends o.CreepBehaviour{constructor(){super("labTech"),this.inflowActions=(e=>[Creep.action.reallocating,Creep.action.withdrawing,Creep.action.uncharging,Creep.action.picking]),this.outflowActions=(e=>{let t=[Creep.action.storing,Creep.action.charging,Creep.action.fueling,Creep.action.feeding];return(e.sum>e.carry.energy||!e.room.situation.invasion&&SPAWN_DEFENSE_ON_ATTACK&&e.room.conserveForDefense&&e.room.relativeEnergyAvailable>.8)&&t.unshift(Creep.action.storing),e.room.structures.urgentRepairable.length>0&&t.unshift(Creep.action.fueling),t}),this.nextAction=(e=>Creep.behaviour.hauler.nextAction(e))}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(0);t.default=new class extends o.CreepBehaviour{constructor(){super("melee"),this.heal=(e=>{!e.attacking&&void 0!==e.data.body.heal&&e.hits<e.hitsMax&&e.heal(e)}),this.actions=(e=>[Creep.action.defending,Creep.action.invading,Creep.action.guarding]),this._invalidAction=this.invalidAction,this._run=this.run,this.setState({healing:{moveOptions:e=>(e.respectRamparts=!0,e)}}),this.invalidAction=(e=>this._invalidAction(e)||"guarding"===e.action.name&&(!e.flag||e.flag.pos.roomName===e.pos.roomName||e.leaveBorder())),this.run=(e=>{e.flee=e.flee||!e.hasActiveBodyparts([ATTACK,RANGED_ATTACK]),e.attacking=!1,e.attackingRanged=!1,this._run(e),this.heal(e)})}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(0);t.default=new class extends o.CreepBehaviour{constructor(){super("miner"),this.actions=(e=>[Creep.action.mining,Creep.action.recycling])}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(0);t.default=new class extends o.CreepBehaviour{constructor(){super("mineralMiner"),this.actions=(e=>Creep.behaviour.miner.actions(e)),this.getEnergy=(e=>Creep.behaviour.miner.getEnergy(e)),this.maintain=(e=>Creep.behaviour.miner.maintain(e)),this.setState({mining:{newTarget:e=>_.find(e.room.minerals,t=>!_.find(Memory.population,r=>r.creepName!==e.name&&r.determinatedTarget===t.id))}})}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(0);t.default=new class extends o.CreepBehaviour{constructor(){super("remoteMiner"),this.actions=(e=>Creep.behaviour.miner.actions(e)),this.getEnergy=(e=>Creep.behaviour.miner.getEnergy(e)),this.maintain=(e=>Creep.behaviour.miner.maintain(e)),this._run=this.run,this.run=(e=>{if(!Creep.action.avoiding.run(e)){const t=e.data.destiny&&Game.flags[e.data.destiny.targetName];t?e.room.name!==e.data.destiny.room&&Creep.action.travelling.assignRoom(e,t.pos.roomName):e.action&&"recycling"===e.action.name||this.assignAction(e,"recycling"),this._run(e)}})}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(0);t.default=new class extends o.CreepBehaviour{constructor(){super("remoteHauler"),this.nextAction=(e=>{if(!e.data.destiny||!Game.flags[e.data.destiny.targetName])return Creep.action.recycling.assign(e);if(e.pos.roomName==e.data.homeRoom){if(e.sum>0){let t=[];if(e.carry.energy==e.sum&&(t=e.room.structures.links.privateers),e.room.storage&&t.push(e.room.storage),e.room.structures.container&&(t=t.concat(e.room.structures.container.privateers)),t.length>0){let r=e.pos.findClosestByRange(t);if(r.structureType==STRUCTURE_STORAGE&&this.assignAction(e,"storing",r))return;if(this.assignAction(e,"charging",r))return;if(this.assignAction(e,"storing"))return}if(this.assignAction(e,"charging"))return;if(this.assignAction(e,"feeding"))return;if(this.assignAction(e,"dropping"))return;{const t=t=>{e.carry[t]>0&&e.drop(t)};return _.forEach(Object.keys(e.carry),t),this.assignAction(e,"idle")}}if(this.gotoTargetRoom(e))return}else{if(e.data.destiny.room==e.pos.roomName){if(e.sum/e.carryCapacity>REMOTE_HAULER.MIN_LOAD)return void this.goHome(e);if(this.assignAction(e,"uncharging"))return;if(this.assignAction(e,"picking"))return;if(0===e.sum){let t=e.pos.findClosestByRange(e.room.sources);if(e.room&&t&&e.pos.getRangeTo(t)>3)return e.data.travelRange=3,this.assignAction(e,"travelling",t)}return this.assignAction(e,"idle")}{let t=!1;if(t=e.sum/e.carryCapacity>REMOTE_HAULER.MIN_LOAD?this.goHome(e):this.gotoTargetRoom(e))return}}let t=Game.spawns[e.data.motherSpawn];t&&this.assignAction(e,Creep.action.recycling,t)}),this.gotoTargetRoom=(e=>{const t=e.data.destiny?Game.flags[e.data.destiny.targetName]:null;if(t)return Creep.action.travelling.assignRoom(e,t.pos.roomName)}),this.goHome=(e=>Creep.action.travelling.assignRoom(e,e.data.homeRoom)),this.setState({picking:{name:`picking-${this.name}`,energyOnly:!1}})}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(0);t.default=new class extends o.CreepBehaviour{constructor(){super("remoteWorker"),this.inflowActions=(e=>[Creep.action.picking,Creep.action.uncharging,Creep.action.withdrawing,Creep.action.harvesting]),this.outflowActions=(e=>[Creep.action.repairing,Creep.action.building,Creep.action.recycling]),this.needEnergy=(e=>e.sum<.8*e.carryCapacity),this.nextAction=(e=>e.data.destiny&&Game.flags[e.data.destiny.targetName]||e.action&&"recycling"===e.action.name?e.data.destiny.room===e.pos.roomName?this.nextEnergyAction(e):this.gotoTargetRoom(e):this.assignAction(e,"recycling")),this.gotoTargetRoom=(e=>{const t=e.data.destiny?Game.flags[e.data.destiny.targetName]:null;if(t)return Creep.action.travelling.assignRoom(e,t.pos.roomName)}),this._run=this.run,this.run=(e=>{Creep.action.avoiding.run(e)||this._run(e)})}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(0);t.default=new class extends o.CreepBehaviour{constructor(){super("pioneer"),this.inflowActions=(e=>Creep.behaviour.worker.inflowActions(e)),this.outflowActions=(e=>{let t;return t=e.room.controller&&e.room.controller.level<2?[Creep.action.feeding,Creep.action.upgrading,Creep.action.building,Creep.action.repairing,Creep.action.fueling,Creep.action.fortifying,Creep.action.charging,Creep.action.storing,Creep.action.picking]:[Creep.action.feeding,Creep.action.building,Creep.action.repairing,Creep.action.fueling,Creep.action.fortifying,Creep.action.charging,Creep.action.upgrading,Creep.action.storing,Creep.action.picking],e.room.controller&&e.room.controller.ticksToDowngrade<2e3&&t.unshift(Creep.action.upgrading),e.sum>e.carry.energy&&t.unshift(Creep.action.storing),t}),this.nextAction=(e=>{let t;if(e.data.destiny&&(t=Game.flags[e.data.destiny.flagName]),t){if((!t.room||t.pos.roomName!=e.pos.roomName)&&Creep.action.travelling.assignRoom(e,t.pos.roomName))return Population.registerCreepFlag(e,t),!0;if(t.room&&t.room.my){let r=Flag.find(FLAG_COLOR.claim.spawn,e.pos,!0);if(r)if(r.room.structures.spawns&&r.room.structures.spawns.length>0){r.remove();let e=e=>Game.flags[e.name].remove();_.forEach(Flag.filter(FLAG_COLOR.invade.exploit,r.pos,!0),e)}else t.room.myConstructionSites.some(e=>e.structureType===STRUCTURE_SPAWN)||t.room.createConstructionSite(r,STRUCTURE_SPAWN)}}return this.nextEnergyAction(e)})}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(0);t.default=new class extends o.CreepBehaviour{constructor(){super("privateer"),this.nextAction=(e=>{let t=e.sum;if(e.pos.roomName==e.data.homeRoom){if(t>0){let r=[];if(e.carry.energy==t&&(r=e.room.structures.links.privateers),e.room.storage&&r.push(e.room.storage),e.room.structures.container&&(r=r.concat(e.room.structures.container.privateers)),r.length>0){let t=e.pos.findClosestByRange(r);if(t.structureType===STRUCTURE_STORAGE&&this.assignAction(e,"storing",t))return;if(this.assignAction(e,"charging",t))return}if(this.assignAction(e,"charging"))return;if(!e.room.ally&&this.assignAction(e,"storing"))return;return void Creep.behaviour.worker.nextAction(e)}return this.exploitNextRoom(e)?void 0:void Creep.behaviour.worker.nextAction(e)}if(e.flag&&e.flag.pos.roomName==e.pos.roomName){if(e.room.situation.invasion&&!e.flag.compareTo(FLAG_COLOR.invade.robbing))return e.flag.cloaking=50,void this.exploitNextRoom(e);if(e.sum<.4*e.carryCapacity){if(0===e.room.sourceEnergyAvailable)return e.flag.cloaking=_.max([e.room.ticksToNextRegeneration-20,0]),void this.exploitNextRoom(e);{let t=[Creep.action.dismantling,Creep.action.picking,Creep.action.robbing,Creep.action.harvesting];for(let r=0;r<t.length;r++){let o=t[r];if(o.isValidAction(e)&&o.isAddableAction(e)&&o.assign(e))return}return e.flag.cloaking=50,void this.exploitNextRoom(e)}}{let t=[Creep.action.building];for(let r=0;r<t.length;r++){let o=t[r];if(o.isValidAction(e)&&o.isAddableAction(e)&&o.assign(e))return}return Population.registerCreepFlag(e,null),void Creep.action.travelling.assignRoom(e,e.data.homeRoom)}}this.exploitNextRoom(e)}),this.exploitNextRoom=(e=>{if(e.sum<.4*e.carryCapacity){let t=e=>Flag.compare(e,FLAG_COLOR.invade.exploit)||Flag.compare(e,FLAG_COLOR.invade.robbing),r=Flag.find(t,new RoomPosition(25,25,e.data.homeRoom),!1,Flag.exploitMod,e.name);if(r&&Creep.action.travelling.assignRoom(e,r.pos.roomName))return Population.registerCreepFlag(e,r),!0}return Population.registerCreepFlag(e,null),e.room.name!==e.data.homeRoom&&Creep.action.travelling.assignRoom(e,e.data.homeRoom),!1}),this._invalidAction=this.invalidAction,this._run=this.run,this.setState({withdrawing:{name:`withdrawing-${this.name}`,isValidAction:e=>!1}}),this.invalidAction=(e=>this._invalidAction(e)||!e.flag),this.run=(e=>{if(this._run(e),e.hits<e.hitsMax&&(!e.action||"travelling"!==e.action.name)&&e.data){if(!e.data.nearestHome||!Game.rooms[e.data.nearestHome]){const t=Room.bestSpawnRoomFor(e.pos.roomName);t&&(e.data.nearestHome=t.name)}e.data.nearestHome&&Creep.action.travelling.assignRoom(e,e.data.nearestHome)}DEBUG&&TRACE&&Util.trace("Behaviour",{creepName:e.name,run:e.action&&e.action.name||"none",[this.name]:"run",Behaviour:this.name})})}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(0);t.default=new class extends o.CreepBehaviour{constructor(){super("recycler"),this.actions=(e=>[Creep.action.picking,Creep.action.withdrawing,Creep.action.uncharging,Creep.action.travelling,Creep.action.storing,Creep.action.feeding,Creep.action.dropping,Creep.action.recycling,Creep.action.idle]),this._invalidAction=this.invalidAction,this.setState({recycling:{name:`recycling-${this.name}`,isValidAction:e=>!e.sum},uncharging:{name:`uncharging-${this.name}`,isValidAction:e=>e.data.travelRoom&&e.sum<e.carryCapacity||!1},withdrawing:{name:`withdrawing-${this.name}`,isValidAction:e=>e.data.travelRoom&&e.room.storage&&e.room.storage.store.energy>0&&e.sum<e.carryCapacity||!1},travelling:{name:`travelling-${this.name}`,newTarget:e=>{if(!e.data.travelRoom)if(e.data.travelPos)e.data.travelRoom=e.data.travelPos.roomName;else{if(e.room.structures.spawns.length)return null;e.data.travelRoom=e.data.homeRoom}const t=Game.rooms[e.data.travelRoom];let r=t&&(t.storage||t.structures.spawns[0]);return r||e}}}),this.invalidAction=(e=>!(!this._invalidAction(e)&&e.action.isMember(this.actions())||(delete e.data.targetId,delete e.data.path,0)))}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(0);t.default=new class extends o.CreepBehaviour{constructor(){super("ranger"),this.heal=(e=>{!e.attacking&&void 0!==e.data.body.heal&&e.hits<e.hitsMax&&e.heal(e)}),this.actions=(e=>[Creep.action.defending,Creep.action.invading,Creep.action.guarding]),this._run=this.run,this.setState({healing:{moveOptions:e=>(e.respectRamparts=!0,e)}}),this.run=(e=>{e.flee=e.flee||!e.hasActiveBodyparts([ATTACK,RANGED_ATTACK]),e.attacking=!1,e.attackingRanged=!1,this._run(e),this.heal(e)})}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(0);t.default=new class extends o.CreepBehaviour{constructor(){super("upgrader"),this.invalidCreep=(e=>["miner","upgrader"].includes(e.data.creepType)&&e.data.determinatedSpot&&(e.data.ttl>e.data.spawningTime||e.data.ttl>e.data.predictedRenewal)),this.approach=(e=>{let t=new RoomPosition(e.data.determinatedSpot.x,e.data.determinatedSpot.y,e.pos.roomName),r=e.pos.getRangeTo(t);if(r>0){e.data.movingToTarget=!0;const o=t.lookFor(LOOK_CREEPS),i=o.length?1:0;1===r&&o.length&&_.some(o,this.invalidCreep)&&delete e.data.determinatedSpot,e.travelTo(t,{range:i})}else e.data.movingToTarget&&(e.room.invalidateCostMatrix(),delete e.data.movingToTarget);return r}),this.run=(e=>{if(e.room.controller.upgradeBlocked)e.data.creepType="recycler";else{if(e.action&&"upgrading"===e.action.name||Population.registerAction(e,Creep.action.upgrading,e.room.controller),!e.data.determinatedSpot){let t=(t=!1)=>{let r=r=>{let o={spots:[{pos:e.room.controller.pos,range:3},{pos:r.pos,range:1}],checkWalkable:!0,where:r=>!_.some(r.lookFor(LOOK_CREEPS),this.invalidCreep)&&(t||0===r.findInRange(e.room.sources,1).length),roomName:e.pos.roomName};return Room.fieldsInRange(o)},o=e.room.structures.links.controller?_.flatten(_.map(e.room.structures.links.controller,r)):[],i=e.room.structures.container.controller?_.flatten(_.map(e.room.structures.container.controller,r)):[],a=e.room.storage?r(e.room.storage):[],s=e.room.terminal?r(e.room.terminal):[];if(o.length){let e=[];return 0===e.length&&i.length&&(e=_.filter(o,e=>_.some(i,t=>t.isEqualTo(e)))),0===e.length&&a.length&&(e=_.filter(o,e=>_.some(a,t=>t.isEqualTo(e)))),0===e.length&&s.length&&(e=_.filter(o,e=>_.some(s,t=>t.isEqualTo(e)))),e.length?e:o}return i.length?i:a.length?a:s},r=t();if(r.length>0&&(r=t(!0)),r.length>0){let t=e.pos.findClosestByPath(r,{filter:t=>!_.some(e.room.lookForAt(LOOK_STRUCTURES,t),{structureType:STRUCTURE_ROAD})});if(t||(t=e.pos.findClosestByPath(r)||r[0]),t){e.data.determinatedSpot={x:t.x,y:t.y};let r=Game.spawns[e.data.motherSpawn];if(r){let o=t.findPathTo(r,{ignoreCreeps:!0});const i=e.data.body?Math.ceil(e.data.body.work/(2*e.data.body.move)):1;o&&(e.data.predictedRenewal=e.data.spawningTime+o.length*i)}}}e.data.determinatedSpot?SAY_ASSIGNMENT&&e.say(String.fromCharCode(9962),SAY_PUBLIC):Util.logError("Unable to determine working location for upgrader in room "+e.pos.roomName)}if(e.data.determinatedSpot&&(CHATTY&&e.say("upgrading",SAY_PUBLIC),this.approach(e),e.room.controller&&e.pos.getRangeTo(e.room.controller)<=3)){let t=e.data.body&&e.data.body.work?e.data.body.work:e.carryCapacity/2;if(e.carry.energy<=t){let t=_.find(e.room.structures.links.controller,t=>t.energy>0&&e.pos.isNearTo(t));t||(t=_.find(e.room.structures.container.controller,t=>t.store[RESOURCE_ENERGY]>0&&e.pos.isNearTo(t))),t||(t=e.room.storage&&e.room.storage.charge>0&&e.pos.isNearTo(e.room.storage)),t||(t=e.room.terminal&&e.room.terminal.store[RESOURCE_ENERGY]>.5*TERMINAL_ENERGY&&e.pos.isNearTo(e.room.terminal)),t&&e.withdraw(t,RESOURCE_ENERGY)}e.controllerSign(),e.upgradeController(e.room.controller)}}})}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(0);t.default=new class extends o.CreepBehaviour{constructor(){super("worker"),this.inflowActions=(e=>{let t=[Creep.action.bulldozing,Creep.action.picking,Creep.action.dismantling,Creep.action.withdrawing,Creep.action.uncharging,Creep.action.harvesting,Creep.action.reallocating];return e.sum>e.carry.energy&&t.unshift(Creep.action.storing),t}),this.outflowActions=(e=>{if(e.room.situation.invasion&&e.room.controller&&e.room.controller.level>2)return[Creep.action.fueling,Creep.action.feeding,Creep.action.repairing];{let t=[Creep.action.repairing,Creep.action.feeding,Creep.action.building,Creep.action.fueling,Creep.action.fortifying,Creep.action.charging,Creep.action.upgrading,Creep.action.storing];const r=e=>{const t=e.population&&e.population.typeCount;return!t.hauler||t.hauler<1||!t.miner||t.miner<1};return e.room.relativeEnergyAvailable<1&&r(e.room)&&t.unshift(Creep.action.feeding),e.room.controller&&e.room.controller.ticksToDowngrade<2e3&&t.unshift(Creep.action.upgrading),e.sum>e.carry.energy&&t.unshift(Creep.action.storing),t.unshift(Creep.action.bulldozing),t}}),this.nextAction=(e=>"worker"==e.data.creepType&&e.pos.roomName!=e.data.homeRoom&&Game.rooms[e.data.homeRoom]&&Game.rooms[e.data.homeRoom].controller?(DEBUG&&TRACE&&Util.trace("Behaviour",{actionName:"travelling",behaviourName:this.name,creepName:e.name,assigned:!0,Behaviour:"nextAction",Action:"assign"}),Creep.action.travelling.assignRoom(e,e.data.homeRoom),!0):this.nextEnergyAction(e))}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(0);t.default=new class extends o.CreepBehaviour{constructor(){super("safeGen"),this.actions=(e=>[Creep.action.safeGen,Creep.action.recycling])}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(0);t.default=new class extends o.CreepSetup{constructor(){super("hauler"),this.maxMulti=(e=>{let t=7;e.minerals.length>0&&(t+=2);let r=_.sum(e.structures.container.in,"sum");return r+=_.sum(e.droppedResources,"amount"),t+=Math.floor(r/1e3),t+=Creep.setup.upgrader._maxMulti(e),Math.min(t,16)}),this.maxCount=(e=>{if(!e.population)return 0;let t=0,r=e.population.typeCount.miner||0,o=e.population.typeCount.worker||0,i=e.population.typeCount.mineralMiner||0,a=e.structures.container.in.length+e.structures.links.storage.length;if(r>0||a>0&&o>Creep.setup.worker._maxCount(e)){e.storage&&e.storage.id===e.controller.memory.storage||(t+=Math.round(Creep.setup.upgrader._maxCount(e)/2)),(e.structures.links.all.length<3||e.storage&&e.storage.active&&e.storage.charge>1&&e.structures.container.controller&&0==_.sum(e.structures.container.controller,"store.energy"))&&t++,i>0&&t++;let r=0,o=t=>e.sources.some(e=>e.pos.x===t.x&&e.pos.y===t.y),a=e=>{e.resourceType===RESOURCE_ENERGY&&e.pos.adjacent.some(o)&&(r+=e.amount)};e.droppedResources.forEach(a),0===t&&(t=1)}return t}),this.maxWeight=(e=>2e3*this._maxCount(e)),this.minControllerLevel=2}get default(){return{fixedBody:[WORK,CARRY,MOVE],multiBody:[CARRY,CARRY,MOVE],minAbsEnergyAvailable:200,minEnergyAvailable:.4,maxMulti:e=>this.maxMulti(e),maxCount:e=>this.maxCount(e),maxWeight:e=>this.maxWeight(e)}}get high(){return{fixedBody:[WORK,CARRY,MOVE],multiBody:[CARRY,CARRY,MOVE],minAbsEnergyAvailable:200,minEnergyAvailable:.1,maxMulti:e=>this.maxMulti(e),maxCount:e=>this.maxCount(e),maxWeight:e=>this.maxWeight(e)}}get RCL(){return{1:this.none,2:this.none,3:this.default,4:this.default,5:this.default,6:this.default,7:this.default,8:this.high}}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(0);t.default=new class extends o.CreepSetup{constructor(){super("healer"),this.minControllerLevel=7,this.globalMeasurement=!0}get RCL(){return{1:this.none,2:this.none,3:this.none,4:this.none,5:this.none,6:this.none,7:{fixedBody:[],multiBody:[MOVE,HEAL],minAbsEnergyAvailable:300,minEnergyAvailable:.8,maxMulti:4,maxCount:0,maxWeight:0},8:{fixedBody:[],multiBody:[MOVE,HEAL],minAbsEnergyAvailable:300,minEnergyAvailable:.8,maxMulti:4,maxCount:0,maxWeight:0}}}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(0);t.default=new class extends o.CreepSetup{constructor(){super("miner"),this.minControllerLevel=1}get default(){return{fixedBody:{[CARRY]:1,[MOVE]:1,[WORK]:4},multiBody:[WORK,MOVE],minAbsEnergyAvailable:500,minEnergyAvailable:.3,maxMulti:2,maxCount:e=>e.sources.length}}get low(){return{fixedBody:[WORK,WORK,MOVE],multiBody:[WORK],minAbsEnergyAvailable:250,minEnergyAvailable:.9,maxMulti:3,maxCount:e=>e.sources.length}}get high(){return{fixedBody:{[CARRY]:1,[MOVE]:1,[WORK]:4},multiBody:[WORK,MOVE],minAbsEnergyAvailable:500,minEnergyAvailable:.1,maxMulti:2,maxCount:e=>e.sources.length}}get RCL(){return{1:this.low,2:this.low,3:this.default,4:this.default,5:this.default,6:this.default,7:this.default,8:this.high}}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(0);t.default=new class extends o.CreepSetup{constructor(){super("mineralMiner"),this.maxCount=(e=>{if(e.memory.noMineralMiners)return 0;let t=0;if(0===(e.population.typeCount.hauler||0))return 0;if(e.storage&&e.storage.sum<.9*e.storage.storeCapacity){let r=e=>{e.mineralAmount>0&&t++};e.minerals.forEach(r)}return t}),this.minControllerLevel=6}get default(){return{fixedBody:{[CARRY]:1,[MOVE]:1,[WORK]:3},multiBody:{[MOVE]:1,[WORK]:3},minAbsEnergyAvailable:750,minEnergyAvailable:.3,maxMulti:11,minMulti:1,maxCount:e=>this.maxCount(e)}}get RCL(){return{1:this.none,2:this.none,3:this.none,4:this.none,5:this.none,6:this.default,7:this.default,8:this.default}}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(0);t.default=new class extends o.CreepSetup{constructor(){super("privateer"),this.minControllerLevel=3,this.globalMeasurement=!0,this.measureByHome=!0}get default(){return{fixedBody:[WORK,CARRY,MOVE],multiBody:[WORK,CARRY,MOVE],minAbsEnergyAvailable:400,minEnergyAvailable:.8,maxMulti:15,minMulti:e=>e.controller.level,maxWeight:e=>e.privateerMaxWeight}}get RCL(){return{1:this.none,2:this.none,3:this.default,4:this.default,5:this.default,6:this.default,7:this.default,8:this.default}}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(0);t.default=new class extends o.CreepSetup{constructor(){super("upgrader"),this.maxMulti=(e=>{let t=0;const r=e.storage&&e.storage.active?e.storage.charge:0;if((!e.storage||e.storage.active&&r>0)&&t++,(!e.storage||e.storage.active&&r>.5)&&t++,e.storage&&e.storage.active&&r>=1){let r=e.storage.store.energy-MAX_STORAGE_ENERGY[e.controller.level];t+=Math.ceil(r/2e4)}return Math.min(11,t)}),this.maxCount=(e=>{const t=_.get(e,["memory","addUpgrader"],0);if(e.situation.invasion||e.conserveForDefense||e.structures.container.controller.length+e.structures.links.controller.length===0||e.controller.upgradeBlocked||e.myConstructionSites.length>0&&!e.storage)return 0;if(8==e.controller.level)return 1;let r=0;if(e.structures.container.controller.forEach(e=>r+=e.store.energy),e.structures.links.controller.forEach(e=>r+=e.energy),0===r)return 0;if(e.storage&&e.storage.active)return t+Math.max(1,Math.floor((e.storage.store.energy-MAX_STORAGE_ENERGY[e.controller.level])/35e4));if(e.droppedResources){let t=0,r=t=>e.sources.some(e=>e.pos.x===t.x&&e.pos.y===t.y),o=e=>{e.resourceType===RESOURCE_ENERGY&&e.pos.adjacent.some(r)&&(t+=e.amount)};e.droppedResources.forEach(o)}return t+2}),this.minControllerLevel=2}get default(){return{fixedBody:{[CARRY]:1,[MOVE]:1,[WORK]:2},multiBody:{[MOVE]:1,[WORK]:3},minAbsEnergyAvailable:400,minEnergyAvailable:.5,maxMulti:e=>this.maxMulti(e),maxCount:e=>this.maxCount(e)}}get low(){return{fixedBody:{[CARRY]:1,[MOVE]:1,[WORK]:2},multiBody:{[MOVE]:1,[WORK]:2},minAbsEnergyAvailable:300,minEnergyAvailable:1,maxMulti:e=>this.maxMulti(e),maxCount:e=>this.maxCount(e)}}get level8(){return{fixedBody:{[CARRY]:1,[MOVE]:3},multiBody:[WORK],minAbsEnergyAvailable:1700,minEnergyAvailable:.5,maxMulti:CONTROLLER_MAX_UPGRADE_PER_TICK/UPGRADE_CONTROLLER_POWER,maxCount:e=>this.maxCount(e)}}get RCL(){return{1:this.none,2:this.low,3:this.default,4:this.default,5:this.default,6:this.default,7:this.default,8:this.level8}}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(0);t.default=new class extends o.CreepSetup{constructor(){super("worker"),this.maxWorker=(e=>{let t=0;return(e.structures.fortifyable.length>0||e.isCriticallyFortifyable)&&t++,e.controller.level<4?e.situation.invasion?1:(2===e.controller.level?3*e.sources.length:2*e.sources.length)-(e.population&&e.population.typeCount.pioneer||0):(this.hasMinerOrHauler(e)||(t+=1),e.myConstructionSites.length>0&&(!e.storage||!e.storage.active||e.storage.store&&e.storage.charge>0)&&t<=1&&(t+=1),t)}),this.hasMinerOrHauler=(e=>!!e.population&&(e.population.typeCount.hauler>0||e.population.typeCount.miner>0)),this.byPopulation=((e,t,r,o)=>{let i=t;return e.population&&(i+=e.population.typeCount[this.type]*r),!o||i<=o?i:o}),this.minEnergyAvailable=(e=>{switch(e.controller.level){case 1:return this.byPopulation(e,0,1,1);case 2:return this.byPopulation(e,0,.8,1);case 3:return this.byPopulation(e,0,.6,1);case 4:return this.hasMinerOrHauler(e)?.5:0;case 7:return this.hasMinerOrHauler(e)?.2:1;default:return this.hasMinerOrHauler(e)?.1:1}}),this.maxMulti=((e,t,r,o)=>_.min([Math.floor((e.energyCapacityAvailable-t)/r),Math.floor(50/o)]))}get default(){return{fixedBody:[],multiBody:{[CARRY]:1,[WORK]:1,[MOVE]:1},minMulti:1,maxMulti:e=>this.maxMulti(e,0,200,_.size(this.default.multiBody)),maxWeight:9600,maxCount:e=>this.maxWorker(e),minEnergyAvailable:e=>this.minEnergyAvailable(e)}}get low(){return{fixedBody:[],multiBody:{[CARRY]:1,[WORK]:1,[MOVE]:2},minMulti:1,maxMulti:8,maxWeight:e=>2===e.controller.level?14400:4e3,maxCount:e=>this.maxWorker(e),minEnergyAvailable:e=>this.minEnergyAvailable(e)}}get RCL(){return{1:this.low,2:this.low,3:this.default,4:this.default,5:this.default,6:this.default,7:this.default,8:this.default}}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(0),i=r(3),a=r(7);t.default=new class extends o.Component{constructor(){super(...arguments),this.extend=(()=>{a.Strategy.decorateAgent(Creep.prototype,{default:e=>e.action&&e.action.name,selector:e=>Creep.action[e]},{default:e=>e.data.creepType,selector:e=>Creep.behaviour[e]&&Creep.behaviour[e]},{default:e=>e.data.destiny&&e.data.destiny.task,selector:e=>Task[e]&&Task[e]})}),this.fresh=(()=>{i.Install(Creep,{spawningStarted:new o.EventClass,spawningCompleted:new o.EventClass,predictedRenewal:new o.EventClass,died:new o.EventClass,error:new o.EventClass})}),this.register=(()=>{for(const e in Creep.action)Creep.action[e].register&&Creep.action[e].register(this);for(const e in Creep.behaviour)Creep.behaviour[e].register&&Creep.behaviour[e].register(this);for(const e in Creep.setup)Creep.setup[e].register&&Creep.setup[e].register(this)}),this.run=(()=>{DEBUG&&Memory.CPU_CRITICAL&&Util.logSystem("system",`${Game.time}: CPU Bucket level is critical (${Game.cpu.bucket}). Skipping non critical creep roles.`),_.forEach(Game.creeps,e=>{try{e.run()}catch(t){console.log('<span style="color:FireBrick">Creep '+e.name+(t.stack||t.toString())+"</span>",Util.stack())}})}),this.isWorkingAge=(e=>{const t=Game.creeps[e.creepName];return!t||(e.predictedRenewal||e.spawningTime||CREEP_LIFE_TIME)<=(t.ticksToLive||CREEP_LIFE_TIME)}),this.run=(()=>{DEBUG&&Memory.CPU_CRITICAL&&Util.logSystem("system",`${Game.time}: CPU Bucket level is critical (${Game.cpu.bucket}). Skipping non critical creep roles.`),_.forEach(Game.creeps,e=>{try{e.run()}catch(t){console.log('<span style="color:FireBrick">Creep '+e.name+(t.stack||t.toString())+"</span>",Util.stack())}})}),this.bodyCosts=(e=>{let t=0;return e&&e.forEach(function(e){t+=BODYPART_COST[e]}),t}),this.multi=((e,t={})=>{const r=t.minMulti||0,o=this.bodyCosts(t.fixedBody),i=this.bodyCosts(t.multiBody);if(0===i)return 0;let a=1/0;if(t.minThreat){const e=this.bodyThreat(t.fixedBody),r=this.bodyThreat(t.multiBody);a=0;let o=e;for(;o<t.minThreat;)a+=1,o+=r}let s=0;if(t.minWeight){let e=o;for(;e<t.minWeight;)s+=1,e+=i}const n=Math.floor((50-t.fixedBody.length)/t.multiBody.length),l=t.currentEnergy?e.energyAvailable:e.energyCapacityAvailable,m=Math.floor((l-o)/i),c=t.maxWeight?Math.floor((t.maxWeight-o)/i):1/0,u=t.maxMulti||1/0,d=_.min([m,a,c,u]),h=_.max([r,s,d]);return _.min([n,h])}),this.partsComparator=((e,t)=>{let r=[TOUGH,CLAIM,WORK,CARRY,ATTACK,RANGED_ATTACK,HEAL,MOVE];return r.indexOf(e)-r.indexOf(t)}),this.formatParts=(e=>{if(e&&!Array.isArray(e)&&"object"==typeof e){const t=[];for(const r of BODYPARTS_ALL)r in e&&t.push(..._.times(e[r],e=>r));e=t}return e}),this.formatBody=((e,t)=>({fixedBody:e=this.formatParts(e),multiBody:t=this.formatParts(t)})),this.compileBody=((e,t,r=!0)=>{const{fixedBody:o,multiBody:i}=this.formatBody(t.fixedBody||[],t.multiBody||[]);_.assign(t,{fixedBody:o,multiBody:i}),void 0!==t.sort&&(r=t.sort);let a=[];const s=this.multi(e,t);for(let e=0;e<s;e++)a=a.concat(t.multiBody);if(a=a.concat(t.fixedBody),r){const e="function"==typeof r?r:this.partsComparator;a.sort(e)}if(a.includes(HEAL)){let e=a.indexOf(HEAL);a.splice(e,1),a.push(HEAL)}return a}),this.bodyThreat=(e=>{let t=0;return e&&e.forEach(e=>{t+=CREEP_PART_THREAT[e.type?e.type:e][e.boost?"boosted":"common"]}),t})}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(0),i=r(3);t.default=new class extends o.Component{constructor(){super(...arguments),this.pathfinderCache={},this.pathfinderCacheDirty=!1,this.pathfinderCacheLoaded=!1,this.COSTMATRIX_CACHE_VERSION=COMPRESS_COST_MATRICES?4:5,this.extend=(()=>{for(const e of Object.keys(Room.manager))Room.manager[e].extend&&Room.manager[e].extend()}),this.fresh=(()=>{i.Install(Room,{newInvader:new o.EventClass,knownInvader:new o.EventClass,goneInvader:new o.EventClass,collapsed:new o.EventClass,costMatrixInvalid:new o.EventClass,RCLChange:new o.EventClass});for(const e of Object.keys(Room.manager))Room.manager[e].fresh&&Room.manager[e].fresh();_.forEach(Game.rooms,e=>{for(const t of Object.keys(Room.manager))Room.manager[t].freshRoom&&Room.manager[t].freshRoom(e)})}),this.register=(()=>{for(const e of Object.keys(Room.manager))Room.manager[e].register&&Room.manager[e].register();Room.costMatrixInvalid.on(e=>this.rebuildCostMatrix(e.name||e)),Room.RCLChange.on(e=>e.structures.all.filter(e=>![STRUCTURE_ROAD,STRUCTURE_WALL,STRUCTURE_RAMPART].includes(e.structureType)).forEach(t=>{t.isActive()||_.set(e.memory,["structures",t.id,"active"],!1)}))}),this.analyze=(()=>{for(const e of Object.keys(Room.manager))Room.manager[e].analyze&&Room.manager[e].analyze();const e=e=>{try{for(const t of Object.keys(Room.manager))Room.manager[t].analyzeRoom&&Room.manager[t].analyzeRoom(e,this.needMemoryResync(e));this.totalSitesChanged()&&e.countMySites(),this.totalStructuresChanged()&&e.countMyStructures(),e.checkRCL()}catch(t){Game.notify(t+"<br/>"+t.stack),console.log(Util.dye(CRAYON.error,'Error in room.js (Room.prototype.loop) for "'+e.name+'": <br/>'+(t.stack||t.toString())+"<br/>"+t.stack))}};_.forEach(Game.rooms,t=>{t.skip||e(t)})}),this.run=(()=>{for(const e of Object.keys(Room.manager))Room.manager[e].run&&Room.manager[e].run();_.forEach(Memory.rooms,(e,t)=>{((e,t)=>{try{for(const r of Object.keys(Room.manager))Room.manager[r].runRoom&&Room.manager[r].runRoom(e,t);const r=Game.rooms[t];r&&r.collapsed&&Room.collapsed.trigger(r)}catch(e){Util.logError(e.stack||e.message)}})(e,t),Game.time%MEMORY_RESYNC_INTERVAL!=0||Game.rooms[t]||"boolean"==typeof Memory.rooms[t].hostile||delete Memory.rooms[t]})}),this.cleanup=(()=>{for(const e of Object.keys(Room.manager))Room.manager[e].cleanup&&Room.manager[e].cleanup();if(_.isUndefined(Memory.pathfinder)||(CMemory.saveSegment(MEM_SEGMENTS.COSTMATRIX_CACHE,Memory.pathfinder),delete Memory.pathfinder),this.pathfinderCacheDirty&&this.pathfinderCacheLoaded){let e={};for(const t in this.pathfinderCache){const r=this.pathfinderCache[t];r.version===this.COSTMATRIX_CACHE_VERSION&&(e[t]={serializedMatrix:r.serializedMatrix||(global.COMPRESS_COST_MATRICES?CompressedMatrix.serialize(r.costMatrix):r.costMatrix.serialize()),updated:r.updated,version:r.version},r.stale&&(e[t].stale=!0))}CMemory.saveSegment(MEM_SEGMENTS.COSTMATRIX_CACHE,e),this.pathfinderCacheDirty=!1}}),this.totalSitesChanged=(()=>{const e=_.size(Game.constructionSites),t=Memory.rooms.myTotalSites||0;return e>0?Memory.rooms.myTotalSites=e:delete Memory.rooms.myTotalSites,t&&t!==e}),this.totalStructuresChanged=(()=>{const e=_.size(Game.structures),t=Memory.rooms.myTotalStructures||0;return e>0?Memory.rooms.myTotalStructures=e:delete Memory.rooms.myTotalStructures,t&&t!==e}),this.needMemoryResync=(e=>_.isUndefined(e.memory.initialized)?(e.memory.initialized=Game.time,!0):Game.time%global.MEMORY_RESYNC_INTERVAL==0||"sim"==e.name),this.routeCallback=((e,t,r)=>((_.isUndefined(e)||_.isUndefined(t))&&Util.logError("Room.routeCallback","both origin and destination must be defined - origin:"+e+" destination:"+t),o=>{if(Game.map.getRoomLinearDistance(e,o)>r.restrictDistance)return!1;if(o!==t&&ROUTE_ROOM_COST[Game.shard.name]&&ROUTE_ROOM_COST[Game.shard.name][o])return ROUTE_ROOM_COST[Game.shard.name][o];let i=!1;if(r.preferHighway){const e=/^[WE]([0-9]+)[NS]([0-9]+)$/.exec(o);i=e[1]%10==0||e[2]%10==0}let a=!1;const s=_.get(Memory.rooms[o],"hostile",!1);if(r.checkOwner){const e=Game.rooms[o];a=!s||e&&e.controller&&(e.controller.my||void 0===e.controller.owner)}return!r.allowSK&&this.isSKRoom(o)?10:!r.allowHostile&&s&&o!==t&&o!==e?Number.POSITIVE_INFINITY:a||o==e||o==t?1:i?3:Game.map.isRoomAvailable(o)?r.checkOwner||r.preferHighway?11:1:Number.POSITIVE_INFINITY})),this.getCostMatrix=(e=>{let t=Game.rooms[e];if(t)return t.costMatrix}),this.isMine=(e=>{let t=Game.rooms[e];return t&&t.my}),this.calcCardinalDirection=(e=>{const t=/^([WE])[0-9]+([NS])[0-9]+$/.exec(e);return[t[1],t[2]]}),this.calcGlobalCoordinates=((e,t)=>{if(!t)return null;const r=/^[WE]([0-9]+)[NS]([0-9]+)$/.exec(e);return t(+r[1],+r[2])}),this.calcCoordinates=((e,t)=>t?this.calcGlobalCoordinates(e,(e,r)=>t(e%10,r%10)):null),this.isCenterRoom=(e=>Room.calcCoordinates(e,(e,t)=>5===e&&5===t)),this.isCenterNineRoom=(e=>Room.calcCoordinates(e,(e,t)=>e>3&&e<7&&t>3&&t<7)),this.isControllerRoom=(e=>Room.calcCoordinates(e,(e,t)=>0!==e&&0!==t&&(e<4||e>6||t<4||t>6))),this.isSKRoom=(e=>Room.calcCoordinates(e,(e,t)=>e>3&&e<7&&t>3&&t<7&&(5!==e||5!==t))),this.isHighwayRoom=(e=>Room.calcCoordinates(e,(e,t)=>0===e||0===t)),this.adjacentRooms=(e=>{let t=e.split(/([NESW])/),r=["N","E","S","W"],o=e=>r[(r.indexOf(e)+2)%4],i=[];for(let e=parseInt(t[2])-1;e<parseInt(t[2])+2;e++)for(let r=parseInt(t[4])-1;r<parseInt(t[4])+2;r++)i.push((e<0?o(t[1])+"0":t[1]+e)+(r<0?o(t[3])+"0":t[3]+r));return i}),this.adjacentAccessibleRooms=((e,t=!0)=>{let r=[],o=Game.map.describeExits(e);return _.forEach(o,(e,o)=>{if(t){let t=Game.map.describeExits(e),i=(o+1)%8+1,a=(o+5)%8+1;t&&t[i]&&!r.includes(t[i])&&r.push(t[i]),t&&t[a]&&!r.includes(t[a])&&r.push(t[a])}r.push(e)}),r}),this.roomDistance=((e,t,r,o)=>{if(r)return Game.map.getRoomLinearDistance(e,t,o);if(e==t)return 0;let i=e.split(/([NESW])/),a=t.split(/([NESW])/);return(i[1]==a[1]?Math.abs(i[2]-a[2]):i[2]+a[2]+1)+(i[3]==a[3]?Math.abs(i[4]-a[4]):i[4]+a[4]+1)}),this.rebuildCostMatrix=(e=>{DEBUG&&Util.logSystem(e,"Invalidating costmatrix to force a rebuild when we have vision."),_.set(Room,["pathfinderCache",e,"stale"],!0),_.set(Room,["pathfinderCache",e,"updated"],Game.time),this.pathfinderCacheDirty=!0}),this.loadCostMatrixCache=(e=>{let t=0;for(const r in e)(!this.pathfinderCache[r]||this.pathfinderCache[r].updated<e[r].updated)&&(t++,this.pathfinderCache[r]=e[r]);DEBUG&&t>0&&Util.logSystem("RawMemory","loading pathfinder cache.. updated "+t+" stale entries."),this.pathfinderCacheLoaded=!0}),this.getCachedStructureMatrix=(e=>{if((e=>{if(_.isUndefined(this.pathfinderCache))return this.pathfinderCache={},this.pathfinderCache[e]={},!1;if(_.isUndefined(this.pathfinderCache[e]))return this.pathfinderCache[e]={},!1;const t=this.pathfinderCache[e],r=Game.time-t.updated;return!(t.version!==this.COSTMATRIX_CACHE_VERSION||!t.serializedMatrix&&!t.costMatrix||t.stale||!(r<COST_MATRIX_VALIDITY)||(DEBUG&&TRACE&&Util.trace("PathFinder",{roomName:e,ttl:r,PathFinder:"CostMatrix"},"cached costmatrix"),0))})(e)){const t=this.pathfinderCache[e];if(t.costMatrix)return t.costMatrix;if(t.serializedMatrix){const e=global.COMPRESS_COST_MATRICES?CompressedMatrix.deserialize(t.serializedMatrix):PathFinder.CostMatrix.deserialize(t.serializedMatrix);return t.costMatrix=e,e}Util.logError("Room.getCachedStructureMatrix",`Cached costmatrix for ${e} is invalid ${t}`),delete this.pathfinderCache[e]}}),this.getStructureMatrix=((e,t)=>{const r=Game.rooms[e];let o;return(o=this.isSKRoom(e)&&t.avoidSKCreeps?_.get(r,"avoidSKMatrix"):_.get(r,"structureMatrix"))||(o=_.get(this.getCachedStructureMatrix(e),"costMatrix")),o}),this.validFields=((e,t,r,o,i,a=!1,s=null)=>{const n=Game.rooms[e],l=a?n.lookAtArea(o,t,i,r):null;let m=[];for(let c=t;c<=r;c++)for(let t=o;t<=i;t++)if(c>1&&c<48&&t>1&&t<48&&(!a||n.isWalkable(c,t,l))){let r=new RoomPosition(c,t,e);s&&!s(r)||m.push(r)}return m}),this.fieldsInRange=(e=>{let t=e.spots.map(e=>e.pos.x+e.range),r=e.spots.map(e=>e.pos.y+e.range),o=e.spots.map(e=>e.pos.x-e.range),i=e.spots.map(e=>e.pos.y-e.range),a=Math.max(...o),s=Math.min(...t),n=Math.max(...i),l=Math.min(...r);return this.validFields(e.roomName,a,s,n,l,e.checkWalkable,e.where)}),this.shouldRepair=((e,t)=>t.hits<t.hitsMax&&(!e.my||t.hits<global.MAX_REPAIR_LIMIT[e.controller.level]||t.hits<global.LIMIT_URGENT_REPAIRING+(2*global.DECAY_AMOUNT[t.structureType]||0))&&(!DECAYABLES.includes(t.structureType)||t.hitsMax-t.hits>global.GAP_REPAIR_DECAYABLE)&&(void 0===Memory.pavementArt[e.name]||Memory.pavementArt[e.name].indexOf("x"+t.pos.x+"y"+t.pos.y+"x")<0)&&!Flag.list.some(e=>e.roomName==t.pos.roomName&&e.color==COLOR_ORANGE&&e.x==t.pos.x&&e.y==t.pos.y))}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(0);t.default=new class extends o.RoomManager{constructor(){super("construction"),this.register=(()=>{Flag.found.on(e=>Room.roomLayout(e))}),this.analyzeRoom=((e,t)=>{t&&e.processConstructionFlags(),e.roadConstruction()}),this.prototypeExtend=(()=>{this.assignRoomPrototype({constructionSites:{get(){return _.isUndefined(this._constructionSites)&&(this._constructionSites=this.find(FIND_CONSTRUCTION_SITES)),this._constructionSites}},myConstructionSites:{get(){return _.isUndefined(this._myConstructionSites)&&(this._myConstructionSites=this.find(FIND_MY_CONSTRUCTION_SITES)),this._myConstructionSites}},roadConstructionTrace:{get(){return _.isUndefined(this.memory.roadConstructionTrace)&&(this.memory.roadConstructionTrace={}),this.memory.roadConstructionTrace},set(e){this.memory.roadConstructionTrace=e}},getBestConstructionSiteFor:{value(e,t=null){let r;if(0==(r=t?this.constructionSites.filter(t):this.constructionSites).length)return null;let o=Util.fieldOrFunction(CONSTRUCTION_PRIORITY,this);return _.min(r,t=>{let r=o.indexOf(t.structureType);return e.getRangeTo(t)+(r<0?1e5:100*r)})}},roadConstruction:{value(e=ROAD_CONSTRUCTION_MIN_DEVIATION){const t=ROAD_CONSTRUCTION_FORCED_ROOMS[Game.shard.name]&&-1!=ROAD_CONSTRUCTION_FORCED_ROOMS[Game.shard.name].indexOf(this.name);if(!ROAD_CONSTRUCTION_ENABLE&&!t||Game.time%ROAD_CONSTRUCTION_INTERVAL!=0)return;if(!t&&_.isNumber(ROAD_CONSTRUCTION_ENABLE)&&(!this.my||ROAD_CONSTRUCTION_ENABLE>this.controller.level))return;let r=Object.keys(this.roadConstructionTrace).map(e=>({n:this.roadConstructionTrace[e],x:e.charCodeAt(0)-32,y:e.charCodeAt(1)-32})),o=Math.max(ROAD_CONSTRUCTION_ABS_MIN,r.reduce((e,t)=>e+t.n,0)/r.length*e);r=r.filter(e=>{if(e.n>=o){let t=this.lookForAt(LOOK_STRUCTURES,e.x,e.y);return(0===t.length||t[0].structureType===STRUCTURE_RAMPART)&&0===this.lookForAt(LOOK_CONSTRUCTION_SITES,e.x,e.y).length}return!1}),_.forEach(r,e=>{DEBUG&&Util.logSystem(this.name,`Constructing new road at ${e.x}'${e.y} (${e.n} Util.traces)`),this.createConstructionSite(e.x,e.y,STRUCTURE_ROAD)}),this.roadConstructionTrace={}}},processConstructionFlags:{value(){if(!this.my||!Util.fieldOrFunction(SEMI_AUTOMATIC_CONSTRUCTION,this))return;let e=_.size(Game.constructionSites);if(e>=100)return;const t=this.controller.level,r=[new RoomPosition(25,25,this.name),!0],o=(t,r)=>{if(e>=100)return;if(!t)return;const o=new RoomPosition(t.x,t.y,t.roomName);if(!o)return;const i=o.lookFor(LOOK_CONSTRUCTION_SITES);if(i&&i.length)return;const a=o.lookFor(LOOK_STRUCTURES).filter(e=>!(e instanceof StructureRoad||e instanceof StructureRampart));if(a&&a.length)return;const s=o.createConstructionSite(r);Util.fieldOrFunction(REMOVE_CONSTRUCTION_FLAG,this,r)&&s===OK&&(t.name&&(t=Game.flags[t.name])instanceof Flag&&t.remove(),e++)};let i=CONTROLLER_STRUCTURES[STRUCTURE_EXTENSION][t]-(this.structures.extensions.length+_.filter(this.constructionSites,e=>e.structureType===STRUCTURE_EXTENSION).length);if(i>0&&Flag.filter(FLAG_COLOR.construct,...r).splice(0,i).forEach(e=>{o(e,STRUCTURE_EXTENSION)}),(i=CONTROLLER_STRUCTURES[STRUCTURE_SPAWN][t]-(this.structures.spawns.length+_.filter(this.constructionSites,e=>e.structureType===STRUCTURE_SPAWN).length))>0&&Flag.filter(FLAG_COLOR.construct.spawn,...r).splice(0,i).forEach(e=>{o(e,STRUCTURE_SPAWN)}),(i=CONTROLLER_STRUCTURES[STRUCTURE_TOWER][t]-(this.structures.towers.length+_.filter(this.constructionSites,e=>e.structureType===STRUCTURE_TOWER).length))>0&&Flag.filter(FLAG_COLOR.construct.tower,...r).splice(0,i).forEach(e=>{o(e,STRUCTURE_TOWER)}),(i=CONTROLLER_STRUCTURES[STRUCTURE_LINK][t]-(this.structures.links.all.length+_.filter(this.constructionSites,e=>e.structureType===STRUCTURE_LINK).length))>0&&Flag.filter(FLAG_COLOR.construct.link,...r).splice(0,i).forEach(e=>{o(e,STRUCTURE_LINK)}),(i=CONTROLLER_STRUCTURES[STRUCTURE_LAB][t]-(this.structures.labs.all.length+_.filter(this.constructionSites,e=>e.structureType===STRUCTURE_LAB).length))>0&&Flag.filter(FLAG_COLOR.construct.lab,...r).splice(0,i).forEach(e=>{o(e,STRUCTURE_LAB)}),!this.storage&&CONTROLLER_STRUCTURES[STRUCTURE_STORAGE][t]>0&&Flag.filter(FLAG_COLOR.construct.storage,...r).splice(0,1).forEach(e=>{o(e,STRUCTURE_STORAGE)}),!this.terminal&&CONTROLLER_STRUCTURES[STRUCTURE_TERMINAL][t]>0&&Flag.filter(FLAG_COLOR.construct.terminal,...r).splice(0,1).forEach(e=>{o(e,STRUCTURE_TERMINAL)}),!this.structures.observer&&CONTROLLER_STRUCTURES[STRUCTURE_OBSERVER][t]>0&&Flag.filter(FLAG_COLOR.construct.observer,...r).splice(0,1).forEach(e=>{o(e,STRUCTURE_OBSERVER)}),!this.structures.nuker&&CONTROLLER_STRUCTURES[STRUCTURE_NUKER][t]>0&&Flag.filter(FLAG_COLOR.construct.nuker,...r).splice(0,1).forEach(e=>{o(e,STRUCTURE_NUKER)}),!this.structures.powerSpawn&&CONTROLLER_STRUCTURES[STRUCTURE_POWER_SPAWN][t]>0&&Flag.filter(FLAG_COLOR.construct.powerSpawn,...r).splice(0,1).forEach(e=>{o(e,STRUCTURE_POWER_SPAWN)}),CONTROLLER_STRUCTURES[STRUCTURE_EXTRACTOR][t]>0){const[e]=this.find(FIND_MINERALS),t=e.pos.lookFor(LOOK_STRUCTURES);if(t.length&&t[0]instanceof StructureExtractor)return;o(e.pos,STRUCTURE_EXTRACTOR)}}}})}),this.roomExtend=(()=>{this.assignRoom({roomLayoutArray:[[null,null,null,null,null,STRUCTURE_EXTENSION,STRUCTURE_ROAD,STRUCTURE_EXTENSION],[null,null,null,STRUCTURE_ROAD,STRUCTURE_EXTENSION,STRUCTURE_ROAD,STRUCTURE_TOWER,STRUCTURE_ROAD,STRUCTURE_EXTENSION,STRUCTURE_ROAD],[null,null,STRUCTURE_ROAD,STRUCTURE_EXTENSION,STRUCTURE_ROAD,STRUCTURE_EXTENSION,STRUCTURE_SPAWN,STRUCTURE_EXTENSION,STRUCTURE_ROAD,STRUCTURE_EXTENSION,STRUCTURE_ROAD],[null,STRUCTURE_ROAD,STRUCTURE_EXTENSION,STRUCTURE_EXTENSION,STRUCTURE_EXTENSION,STRUCTURE_ROAD,STRUCTURE_TOWER,STRUCTURE_ROAD,STRUCTURE_EXTENSION,STRUCTURE_EXTENSION,STRUCTURE_EXTENSION,STRUCTURE_ROAD],[null,STRUCTURE_EXTENSION,STRUCTURE_ROAD,STRUCTURE_EXTENSION,STRUCTURE_EXTENSION,STRUCTURE_EXTENSION,STRUCTURE_ROAD,STRUCTURE_EXTENSION,STRUCTURE_EXTENSION,STRUCTURE_EXTENSION,STRUCTURE_ROAD,STRUCTURE_EXTENSION],[STRUCTURE_EXTENSION,STRUCTURE_ROAD,STRUCTURE_EXTENSION,STRUCTURE_ROAD,STRUCTURE_EXTENSION,STRUCTURE_ROAD,STRUCTURE_NUKER,STRUCTURE_ROAD,STRUCTURE_EXTENSION,STRUCTURE_ROAD,STRUCTURE_EXTENSION,STRUCTURE_ROAD,STRUCTURE_EXTENSION],[STRUCTURE_ROAD,STRUCTURE_TOWER,STRUCTURE_EXTENSION,STRUCTURE_SPAWN,STRUCTURE_ROAD,STRUCTURE_POWER_SPAWN,STRUCTURE_LINK,STRUCTURE_TERMINAL,STRUCTURE_ROAD,STRUCTURE_OBSERVER,STRUCTURE_EXTENSION,STRUCTURE_TOWER,STRUCTURE_ROAD],[STRUCTURE_EXTENSION,STRUCTURE_ROAD,STRUCTURE_EXTENSION,STRUCTURE_ROAD,STRUCTURE_EXTENSION,STRUCTURE_ROAD,STRUCTURE_STORAGE,STRUCTURE_ROAD,STRUCTURE_EXTENSION,STRUCTURE_ROAD,STRUCTURE_EXTENSION,STRUCTURE_ROAD,STRUCTURE_EXTENSION],[null,STRUCTURE_EXTENSION,STRUCTURE_ROAD,STRUCTURE_EXTENSION,STRUCTURE_EXTENSION,STRUCTURE_EXTENSION,STRUCTURE_ROAD,STRUCTURE_EXTENSION,STRUCTURE_EXTENSION,STRUCTURE_EXTENSION,STRUCTURE_ROAD,STRUCTURE_EXTENSION],[null,STRUCTURE_ROAD,STRUCTURE_EXTENSION,STRUCTURE_EXTENSION,STRUCTURE_EXTENSION,STRUCTURE_ROAD,STRUCTURE_TOWER,STRUCTURE_ROAD,STRUCTURE_EXTENSION,STRUCTURE_EXTENSION,STRUCTURE_EXTENSION,STRUCTURE_ROAD],[null,null,STRUCTURE_ROAD,STRUCTURE_EXTENSION,STRUCTURE_ROAD,STRUCTURE_EXTENSION,STRUCTURE_SPAWN,STRUCTURE_EXTENSION,STRUCTURE_ROAD,STRUCTURE_EXTENSION,STRUCTURE_ROAD],[null,null,null,STRUCTURE_ROAD,STRUCTURE_EXTENSION,STRUCTURE_ROAD,STRUCTURE_TOWER,STRUCTURE_ROAD,STRUCTURE_EXTENSION,STRUCTURE_ROAD],[null,null,null,null,null,STRUCTURE_EXTENSION,STRUCTURE_ROAD,STRUCTURE_EXTENSION]],roomLayout:e=>{if(!Flag.compare(e,FLAG_COLOR.command.roomLayout))return;const t=(e=Game.flags[e.name]).room;if(!t)return;const r=Room.roomLayoutArray,o={[STRUCTURE_SPAWN]:FLAG_COLOR.construct.spawn,[STRUCTURE_TOWER]:FLAG_COLOR.construct.tower,[STRUCTURE_EXTENSION]:FLAG_COLOR.construct,[STRUCTURE_LINK]:FLAG_COLOR.construct.link,[STRUCTURE_STORAGE]:FLAG_COLOR.construct.storage,[STRUCTURE_TERMINAL]:FLAG_COLOR.construct.terminal,[STRUCTURE_NUKER]:FLAG_COLOR.construct.nuker,[STRUCTURE_POWER_SPAWN]:FLAG_COLOR.construct.powerSpawn,[STRUCTURE_OBSERVER]:FLAG_COLOR.construct.observer},[i,a]=[e.pos.x,e.pos.y],s=[],n=[],l=()=>(e.pos.newFlag(FLAG_COLOR.command.invalidPosition,"NO_ROOM"),e.remove(),!1);for(let e=0;e<r.length;e++)for(let m=0;m<r[e].length;m++){const c=Math.floor(i+(e-r.length/2)+1),u=Math.floor(a+(m-r.length/2)+1);if(c>=50||c<0||u>=50||u<0)return l();const d=t.getPositionAt(c,u),h=r[e]&&r[e][m];if(h){if("wall"===Game.map.getTerrainAt(d))return l();if(h===STRUCTURE_ROAD)n.push(d);else{const e=o[h];s.push({flagColour:e,pos:d})}}}s.forEach(e=>{e.pos.newFlag(e.flagColour)}),_.forEach(n,e=>{if(_.size(Game.constructionSites)>=100)return!1;e.createConstructionSite(STRUCTURE_ROAD)}),e.remove()}})})}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(0);t.default=new class extends o.RoomManager{constructor(){super("container"),this.analyzeRoom=((e,t)=>{t&&e.saveContainers()}),this.prototypeExtend=(()=>{this.assignRoomPrototype({saveContainers:{value(){let e=this.structures.all.filter(e=>e.structureType==STRUCTURE_CONTAINER);if(e.length>0){this.memory.container=[];let t=e=>{let t=this.find(FIND_MINERALS),r=e.pos.findInRange(this.sources,2),o=e.pos.findInRange(t,2),i=!!(this.my&&e.pos.getRangeTo(this.controller)<=4);this.memory.container.push({id:e.id,source:r.length>0,controller:i,mineral:o.length>0});let a=t=>t.memory.container=e.id;r.forEach(a),o.forEach(a)};e.forEach(t)}else delete this.memory.container;if(this.terminal){let e=[],t=t=>{e=_(e).concat(Room.validFields(this.name,t.pos.x-1,t.pos.x+1,t.pos.y-1,t.pos.y+1,!0))};_.forEach(this.sources,t);let r=this.terminal.pos.findClosestByRange(e,1),o=[];r&&(1==this.sources.length?o=this.sources:o.push(r.isNearTo(this.sources[0])?this.sources[0]:this.sources[1]));let i=this.terminal.pos.findInRange(this.minerals,2),a=e=>e.memory.terminal=this.terminal.id;o.forEach(a),i.forEach(a),this.terminal.pos.getRangeTo(this.controller)<4&&(this.controller.memory.storage=this.terminal.id)}if(this.storage){let e=this.storage.pos.findInRange(this.sources,2),t=this.storage.pos.findInRange(this.minerals,2),r=e=>e.memory.storage=this.storage.id;e.forEach(r),t.forEach(r),this.storage.pos.getRangeTo(this.controller)<4&&(this.controller.memory.storage=this.storage.id)}}},findContainerWith:{value(e,t){t||(t=1);let r=this.memory;if(r&&r.container&&r.container.length>0)for(let o=0;o<r.container.length;o++){let i=r.container[o],a=Game.getObjectById(i.id);if(a){let r=-a.getNeeds(e);if((!this.structures.container.out.includes(a)||e!==RESOURCE_ENERGY)&&r>0&&r>=t)return{structure:a,amount:r}}}return null}}})}),this.roomExtend=(()=>{this.assignRoom({Containers:function(e){this.room=e,Object.defineProperties(this,{all:{get(){if(_.isUndefined(this._container)){this._container=[];let e=e=>{let t=Game.getObjectById(e.id);t&&(_.assign(t,e),this._container.push(t))};_.forEach(this.room.memory.container,e)}return this._container}},controller:{get(){if(_.isUndefined(this._controller))if(this.room.my&&this.room.controller.memory.storage)this._controller=[Game.getObjectById(this.room.controller.memory.storage)],this._controller[0]||delete this.room.controller.memory.storage;else{let e=e=>1==e.controller;this._controller=_.filter(this.all,e)}return this._controller}},in:{get(){if(_.isUndefined(this._in)){let e=e=>0==e.controller;this._in=_.filter(this.all,e);let t=e=>e.sum>=e.storeCapacity*(1-MANAGED_CONTAINER_TRIGGER);this._in=this._in.concat(this.managed.filter(t))}return this._in}},out:{get(){if(_.isUndefined(this._out)){let e=e=>1==e.controller;this._out=_.filter(this.all,e);let t=e=>e.sum<=e.storeCapacity*MANAGED_CONTAINER_TRIGGER;this._out=this._out.concat(this.managed.filter(t))}return this._out}},privateers:{get(){if(_.isUndefined(this._privateers)){let e=e=>!1===e.source&&!e.mineral&&e.sum<e.storeCapacity;this._privateers=_.filter(this.all,e)}return this._privateers}},managed:{get(){if(_.isUndefined(this._managed)){let e=e=>!0===e.source&&1==e.controller;this._managed=_.filter(this.all,e)}return this._managed}}})}})})}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(0);t.default=new class extends o.RoomManager{constructor(){super("defense"),this.analyzeRoom=(e=>{(e.hostiles.length||e.memory.hostileIds&&e.memory.hostileIds.length)&&e.processInvaders()}),this.runRoom=((e,t)=>{const r=Game.rooms[t];r?(r.goneInvader.forEach(this._triggerGoneInvaders),r.hostileIds.forEach(this._triggerKnownInvaders),r.newInvader.forEach(this._triggerNewInvaders)):e.hostileIds&&_.forEach(e.hostileIds,this._triggerKnownInvaders)}),this.freshRoom=(e=>{e.newInvader=[],e.goneInvader=[]}),this._triggerNewInvaders=(e=>{const t=JSON.stringify(_.countBy(e.body,"type"));(DEBUG||NOTIFICATE_INVADER||NOTIFICATE_INTRUDER&&e.room.my||NOTIFICATE_HOSTILES)&&Util.logSystem(e.pos.roomName,`Hostile intruder (${t}) from "${e.owner.username}".`),(NOTIFICATE_INVADER||NOTIFICATE_INTRUDER&&"Source Keeper"!==e.owner.username&&e.room.my||NOTIFICATE_HOSTILES&&"Source Keeper"!==e.owner.username)&&Game.notify(`Hostile intruder ${e.id} (${t}) from "${e.owner.username}" in room ${e.pos.roomName} at ${Util.toDateTimeString(Util.toLocalDate(new Date))}`),Room.newInvader.trigger(e)}),this._triggerKnownInvaders=(e=>Room.knownInvader.trigger(e)),this._triggerGoneInvaders=(e=>Room.goneInvader.trigger(e))}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(0);t.default=new class extends o.RoomManager{constructor(){super("extension"),this.analyzeRoom=((e,t)=>{t&&e.saveExtensions()}),this.prototypeExtend=(()=>{this.assignRoomPrototype({saveExtensions:{value(){const e=this.find(FIND_MY_STRUCTURES,{filter:e=>e instanceof StructureExtension}).map(e=>e.id);e.length>0?this.memory.extensions=e:delete this.memory.extensions}}})})}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(0);t.default=new class extends o.RoomManager{constructor(){super("lab"),this.analyzeRoom=((e,t)=>{t&&e.saveLabs(),e.structures.labs.all.length>0&&e.processLabs()}),this.prototypeExtend=(()=>{this.assignRoomPrototype({saveLabs:{value(){let e=this.find(FIND_MY_STRUCTURES,{filter:e=>e.structureType==STRUCTURE_LAB});if(e.length>0){this.memory.labs=[];let t=this.storage?this.storage.pos.findInRange(e,2).map(e=>e.id):[];this.memory.labs=[];let r=e=>{this.memory.labs.find(t=>t.id==e.id)||this.memory.labs.push({id:e.id,storage:t.includes(e.id)})};e.forEach(r)}else delete this.memory.labs}},processLabs:{value(){if(Game.time%LAB_COOLDOWN!=5)return;let e=this.find(FIND_MY_STRUCTURES,{filter:e=>e.structureType==STRUCTURE_LAB});if(!this.memory.resources)return;let t=e.filter(e=>{let t=this.memory.resources.lab.find(t=>t.id==e.id);return!!t&&t.slave_a&&t.slave_b});for(let e=0;e<t.length;e++){let r=t[e];if(r.cooldown>0)continue;let o=this.memory.resources.lab.find(e=>e.id==r.id);if(!o)continue;let i=o.reactionType;if(r.mineralAmount>0&&r.mineralType!=i)continue;let a=Game.getObjectById(o.slave_a),s=Game.getObjectById(o.slave_b);a&&a.mineralType==LAB_REACTIONS[i][0]&&s&&s.mineralType==LAB_REACTIONS[i][1]&&r.runReaction(a,s)==OK&&(o.reactionAmount-=LAB_REACTION_AMOUNT,DEBUG&&TRACE&&Util.trace("Room",{roomName:this.name,actionName:"processLabs",labId:r.id,resourceType:i,amountRemaining:o.reactionAmount}),o.reactionAmount<=0&&this.cancelReactionOrder(r.id))}let r=this.memory.resources.reactions;if(r)switch(r.reactorType){case REACTOR_TYPE_FLOWER:this.processReactorFlower()}}},processReactorFlower:{value(){let e=this.memory.resources.reactions;if(!e||e.reactorType!==REACTOR_TYPE_FLOWER)return;for(let t=0;t<e.orders.length&&e.orders[t].amount<LAB_REACTION_AMOUNT;t++)e.orders.splice(t--,1);if(0===e.orders.length){let t=this.find(FIND_MY_STRUCTURES,{filter:e=>e.structureType==STRUCTURE_LAB});for(let e=0;e<t.length;e++){let r=t[e],o=this.memory.resources.lab.find(e=>e.id===r.id);!o||o.reactionState!==LAB_IDLE&&o.reactionState!==LAB_SEED||this.cancelReactionOrder(r.id)}return void(e.reactorMode=REACTOR_MODE_IDLE)}let t=e.orders[0];switch(e.reactorMode=t.mode,e.reactorMode){case REACTOR_MODE_BURST:this.processReactorFlowerBurst()}}},processReactorFlowerBurst:{value(){let e=this.memory.resources.reactions;if(!e||e.reactorType!==REACTOR_TYPE_FLOWER||e.reactorMode!==REACTOR_MODE_BURST)return;let t=e.orders[0];if(t.mode!==REACTOR_MODE_BURST)return;let r=LAB_REACTIONS[t.type][0],o=LAB_REACTIONS[t.type][1],i=Game.getObjectById(e.seed_a),a=Game.getObjectById(e.seed_b),s=_.filter(Game.rooms,{my:!0}),n=!1,l=!1,m=function(e){let t=0,r=this;for(let o of s){if(o.name===r.name)continue;let i=o.resourcesAll[e]||0;i>=MIN_OFFER_AMOUNT&&(t+=i)}return t},c=m(r),u=m(o);if(!i||!a)return;let d=this.memory.resources.lab.find(t=>t.id===e.seed_a),h=this.memory.resources.lab.find(t=>t.id===e.seed_b);if(!d||!_.some(d.orders,"type",r)){this.placeOrder(e.seed_a,r,t.amount),l=!0;let o=(this.resourcesStorage[r]||0)+(this.resourcesTerminal[r]||0)+(this.resourcesLabs[r]||0),i=(this.resourcesOffers[r]||0)+t.amount-o,a=Util.roundUpTo(i,MIN_OFFER_AMOUNT);i<TRADE_THRESHOLD&&i>0?c>=TRADE_THRESHOLD?i=TRADE_THRESHOLD:c>=a&&(i=a):i>0&&a<=c&&(i=a),i>0&&i<=c&&(this.placeRoomOrder(e.seed_a,r,i),n=!0),(d=this.memory.resources.lab.find(t=>t.id===e.seed_a)).reactionType=r}if(!h||!_.some(h.orders,"type",o)){this.placeOrder(e.seed_b,o,t.amount),l=!0;let r=(this.resourcesStorage[o]||0)+(this.resourcesTerminal[o]||0)+(this.resourcesLabs[o]||0),i=(this.resourcesOffers[o]||0)+t.amount-r,a=Util.roundUpTo(i,MIN_OFFER_AMOUNT);i<TRADE_THRESHOLD&&i>0?u>=TRADE_THRESHOLD?i=TRADE_THRESHOLD:u>=a&&(i=a):i>0&&a<=u&&(i=a),i>0&&i<=u&&(this.placeRoomOrder(e.seed_b,o,i),n=!0),(h=this.memory.resources.lab.find(t=>t.id===e.seed_b)).reactionType=o}if(!d||!h)return;let g=d.orders.find(e=>e.type===r),p=h.orders.find(e=>e.type===o);if(!g||g.amount<t.amount){let o=t.amount-(g?g.orderAmount:0);this.placeOrder(e.seed_a,r,o),l=!0;let i=(this.resourcesStorage[r]||0)+(this.resourcesTerminal[r]||0)+(this.resourcesLabs[r]||0),a=(this.resourcesOffers[r]||0)+t.amount-i,s=Util.roundUpTo(a,MIN_OFFER_AMOUNT);a<TRADE_THRESHOLD&&a>0?c>=TRADE_THRESHOLD?a=TRADE_THRESHOLD:c>=s&&(a=s):a>0&&s<=c&&(a=s),a>0&&a<=c&&(this.placeRoomOrder(e.seed_a,r,a),n=!0),a>0&&(this.placeRoomOrder(e.seed_a,r,a),n=!0)}if(!p||p.amount<t.amount){let r=t.amount-(p?p.orderAmount:0);this.placeOrder(e.seed_b,o,r),l=!0;let i=(this.resourcesStorage[o]||0)+(this.resourcesTerminal[o]||0)+(this.resourcesLabs[o]||0),a=(this.resourcesOffers[o]||0)+t.amount-i,s=Util.roundUpTo(a,MIN_OFFER_AMOUNT);a<TRADE_THRESHOLD&&a>0?u>=TRADE_THRESHOLD?a=TRADE_THRESHOLD:u>=s&&(a=s):a>0&&s<=u&&(a=s),a>0&&a<=u&&(this.placeRoomOrder(e.seed_b,o,a),n=!0),a>0&&(this.placeRoomOrder(e.seed_b,o,a),n=!0)}let f=this.memory.resources.boostTiming;n?(f.roomState="ordersPlaced",this.GCOrders()):l&&(f.roomState="ordersPlaced");let y=this.find(FIND_MY_STRUCTURES,{filter:e=>e.structureType==STRUCTURE_LAB}).filter(e=>{let t=this.memory.resources.lab.find(t=>t.id===e.id),r=this.memory.resources.reactions;return!t||t.reactionState===LAB_IDLE&&(t.id!==r.seed_a||t.id!==r.seed_b)});for(let e=0;e<y.length;e++){let r=y[e],o=this.memory.resources.lab.find(e=>e.id===r.id);o||(this.prepareReactionOrder(r.id,t.type,t.amount),o=this.memory.resources.lab.find(e=>e.id===r.id)),o&&(o.reactionType=t.type)}if(i.mineralType!==r||a.mineralType!==o)return;let R=Math.floor(Math.min(i.mineralAmount,a.mineralAmount,t.amount)/LAB_REACTION_AMOUNT);if(0===R)return;let E=0;for(let e=0;e<y.length;e++){let r=y[e];if(!(r.cooldown>0)&&(0===r.mineralAmount||r.mineralType===t.type&&r.mineralAmount<=r.mineralCapacity-LAB_REACTION_AMOUNT&&E<R)){E++;let e=r.runReaction(i,a);e===OK?(t.amount-=LAB_REACTION_AMOUNT,DEBUG&&TRACE&&Util.trace("Room",{roomName:this.name,actionName:"processLabs",reactorType:REACTOR_TYPE_FLOWER,labId:r.id,resourceType:t.type,amountRemaining:t.amount})):Util.logSystem(this.name,`${this.name} runReactions not OK. returnValue: ${Util.translateErrorCode(e)}`)}}}},cancelReactionOrder:{value(e,t){let r=this.memory.resources.lab.find(t=>t.id==e);if(!t||_.matches(t)(e)){if(r){r.slave_a&&this.cancelReactionOrder(r.slave_a,{master:e}),r.slave_b&&this.cancelReactionOrder(r.slave_b,{master:e}),[LAB_MASTER,LAB_SLAVE_1,LAB_SLAVE_2,LAB_SLAVE_3].includes(r.reactionState)&&(r.reactionState=LAB_IDLE),delete r.reactionType,delete r.reactionAmount,delete r.master,delete r.slave_a,delete r.slave_b,void 0===this.memory.resources&&(this.memory.resources={lab:[],container:[],terminal:[],storage:[]}),void 0===this.memory.resources.orders&&(this.memory.resources.orders=[]),this.memory.resources.orders;for(let e=0;e<r.orders.length;e++){let t=r.orders[e];t.type!=RESOURCE_ENERGY&&(t.orderAmount=0,t.orderRemaining=0,t.storeAmount=0)}}return OK}}},prepareReactionOrder:{value(e,t,r){if(r<=0)return OK;let o=Game.getObjectById(e);if(!this.my||!o||!o.structureType==STRUCTURE_LAB)return ERR_INVALID_TARGET;if(!LAB_REACTIONS.hasOwnProperty(t))return ERR_INVALID_ARGS;void 0===this.memory.resources&&(this.memory.resources={lab:[],container:[],terminal:[],storage:[]});let i=this.memory.resources.lab.find(t=>t.id==e);return i||(this.memory.resources.lab.push({id:e,orders:[],reactionState:LAB_IDLE}),i=this.memory.resources.lab.find(t=>t.id==e)),this.cancelReactionOrder(e),OK}},placeBasicReactionOrder:{value(e,t,r,o=1){if(r<=0)return OK;if(!LAB_REACTIONS.hasOwnProperty(t))return ERR_INVALID_ARGS;void 0===this.memory.resources&&(this.memory.resources={lab:[],container:[],terminal:[],storage:[]}),void 0===this.memory.resources.powerSpawn&&(this.memory.resources.powerSpawn=[]);let i=Game.getObjectById(e),a=LAB_REACTIONS[t][0],s=LAB_REACTIONS[t][1],n=null,l=null,m=i.pos.findInRange(FIND_MY_STRUCTURES,2,{filter:e=>e.structureType==STRUCTURE_LAB&&e.id!=i.id});for(let e=0;e<m.length;e++){let t=m[e],r=this.memory.resources.lab.find(e=>e.id==t.id);if(null==n&&r&&r.reactionType==a?n=t:null==l&&r&&r.reactionType==s&&(l=t),n&&l)break}if(!n||!l){m.sort((e,t)=>i.pos.getRangeTo(e)-i.pos.getRangeTo(t));for(let e=0;e<m.length;e++){let t=m[e],r=this.memory.resources.lab.find(e=>e.id==t.id);r&&r.reactionState&&r.reactionState!=LAB_IDLE||(null==n?n=t:null==l&&(l=t))}}if(null==n||null==l)return ERR_NOT_FOUND;let c=this.prepareReactionOrder(e,t,r);if(c!=OK)return c;if((c=this.prepareReactionOrder(n.id,t,r))!=OK)return c;if((c=this.prepareReactionOrder(l.id,t,r))!=OK)return c;let u=this.memory.resources.lab.find(t=>t.id==e),d=LAB_MASTER;u&&(u.reactionState==LAB_SLAVE_1&&(d=LAB_SLAVE_1),u.reactionState==LAB_SLAVE_2&&(d=LAB_SLAVE_2),u.reactionState=d,u.reactionType=t,u.reactionAmount=r,u.slave_a=n.id,u.slave_b=l.id),u=this.memory.resources.lab.find(e=>e.id==n.id);let h=LAB_SLAVE_1,g=1;if(d==LAB_SLAVE_1?(h=LAB_SLAVE_2,g=2):d==LAB_SLAVE_2&&(h=LAB_SLAVE_3,g=3),u){u.reactionState=h,u.reactionType=a,u.master=i.id,this.placeOrder(n.id,a,r);let e=0;if(this.memory.container)for(let t=0;t<this.memory.container.length;t++){let r=this.memory.container[t],o=Game.getObjectById(r.id);o&&o.store[a]&&(e+=o.store[a])}if(this.storage&&(e+=this.storage.store[a]||0),this.terminal&&(e+=this.terminal.store[a]||0),o>g&&g<3&&e<r&&this.placeReactionOrder(n.id,a,r-e)==OK){let t=u.orders.find(e=>e.type==a);t&&(t.orderRemaining=e)}}if(u=this.memory.resources.lab.find(e=>e.id==l.id)){u.reactionState=h,u.reactionType=s,u.master=i.id,this.placeOrder(l.id,s,r);let e=0;if(this.memory.container)for(let t=0;t<this.memory.container.length;t++){let r=this.memory.container[t],o=Game.getObjectById(r.id);o&&(e+=o.store[s]||0)}if(this.storage&&(e+=this.storage.store[s]||0),this.terminal&&(e+=this.terminal.store[s]||0),o>g&&g<3&&e<r&&this.placeReactionOrder(n.id,a,r-e)==OK){let t=u.orders.find(e=>e.type==s);t&&(t.orderRemaining=e)}}return OK}},placeFlowerReactionOrder:{value(e,t,r,o=REACTOR_MODE_BURST){if(r<=0)return OK;if(!LAB_REACTIONS.hasOwnProperty(t))return ERR_INVALID_ARGS;void 0===this.memory.resources&&(this.memory.resources={lab:[],container:[],terminal:[],storage:[]}),void 0===this.memory.resources.powerSpawn&&(this.memory.resources.powerSpawn=[]);let i=this.memory.resources;if(i.reactions){let a=i.reactions.orders.find(r=>r.id==e&&r.type==t);a?(DEBUG&&TRACE&&Util.trace("Room",{roomName:this.name,actionName:"placeReactionOrder",subAction:"update",orderId:e,resourceType:t,amount:r}),a.mode=o,a.amount=r):(DEBUG&&TRACE&&Util.trace("Room",{roomName:this.name,actionName:"placeReactionOrder",subAction:"new",orderId:e,resourceType:t,amount:r}),i.reactions.orders.push({id:e,type:t,mode:o,amount:r})),i.reactions.reactorMode=o}return OK}},placeReactionOrder:{value(e,t,r,o=REACTOR_MODE_BURST){if(r<=0)return OK;if(!LAB_REACTIONS.hasOwnProperty(t))return ERR_INVALID_ARGS;void 0===this.memory.resources&&(this.memory.resources={lab:[],container:[],terminal:[],storage:[]}),void 0===this.memory.resources.powerSpawn&&(this.memory.resources.powerSpawn=[]);let i=Game.getObjectById(e);if(i&&i.structureType===STRUCTURE_LAB)return this.placeBasicReactionOrder(e,t,r,1);let a=this.memory.resources;if(!a.reactions)return DEBUG&&TRACE&&Util.trace("Room",{roomName:this.name,actionName:"placeRoomOrder",subAction:"no_reactor"}),ERR_INVALID_TARGET;switch(a.reactions.reactorType,a.reactions.reactorType){case REACTOR_TYPE_FLOWER:this.placeFlowerReactionOrder(e,t,r,o)}return OK}},registerReactorFlower:{value(e,t){void 0===this.memory.resources&&(this.memory.resources={lab:[],container:[],terminal:[],storage:[]}),void 0===this.memory.resources.powerSpawn&&(this.memory.resources.powerSpawn=[]);let r=Game.getObjectById(e),o=Game.getObjectById(t);if(!r||!o||r.structureType!==STRUCTURE_LAB||o.structureType!==STRUCTURE_LAB)return ERR_INVALID_TARGET;let i=this.memory.resources;return void 0===i.reactions&&(i.reactions={orders:[]}),i.reactions.reactorType=REACTOR_TYPE_FLOWER,i.reactions.reactorMode=REACTOR_MODE_IDLE,i.reactions.seed_a=e,i.reactions.seed_b=t,data_a=i.lab.find(t=>t.id===e),data_a&&(data_a.reactionState=LAB_SEED),data_b=i.lab.find(e=>e.id===t),data_b&&(data_b.reactionState=LAB_SEED),OK}}})}),this.roomExtend=(()=>{this.assignRoom({Labs:function(e){this.room=e,Object.defineProperties(this,{all:{get(){if(_.isUndefined(this._all)){this._all=[];let e=e=>{let t=Game.getObjectById(e.id);t&&(_.assign(t,e),this._all.push(t))};_.forEach(this.room.memory.labs,e)}return this._all}},storage:{get(){if(_.isUndefined(this._storage)){let e=e=>!0===e.storage;this._storage=this.all.filter(e)}return this._storage}}})}})})}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(0);t.default=new class extends o.RoomManager{constructor(){super("link"),this.analyzeRoom=((e,t)=>{t&&e.saveLinks(),e.structures.links.all.length>0&&e.linkDispatcher()}),this.prototypeExtend=(()=>{this.assignRoomPrototype({saveLinks:{value(){let e=this.find(FIND_MY_STRUCTURES,{filter:e=>e.structureType==STRUCTURE_LINK});if(e.length>0){this.memory.links=[];let t=this.storage?this.storage.pos.findInRange(e,2).map(e=>e.id):[];this.memory.links=[];let r=e=>{if(!this.memory.links.find(t=>t.id==e.id)){let r=e.pos.getRangeTo(this.controller)<=4,o=!1;if(!r){let t=e.pos.findInRange(this.sources,2),r=t=>t.memory.link=e.id;t.forEach(r),o=t.length>0}this.memory.links.push({id:e.id,storage:t.includes(e.id),controller:r,source:o})}};e.forEach(r)}else delete this.memory.links}},linkDispatcher:{value(){let e=e=>0==e.cooldown&&e.energy>=e.energyCapacity*(e.source?.85:.5),t=e=>e.energy<.15*e.energyCapacity,r=this.structures.links.in.filter(e),o=this.structures.links.controller.filter(t);if(r.length>0){let e=this.structures.links.storage.filter(t),i=t=>{o.length>0?(t.transferEnergy(o[0]),o.shift()):e.length>0&&(t.transferEnergy(e[0]),e.shift())};r.forEach(i)}if(o.length>0){let t=e=>{o.length>0&&(e.transferEnergy(o[0]),o.shift())};this.structures.links.storage.filter(e).forEach(t)}}}})}),this.roomExtend=(()=>{this.assignRoom({Links:function(e){this.room=e,Object.defineProperties(this,{all:{get(){if(_.isUndefined(this._all)){this._all=[];let e=e=>{let t=Game.getObjectById(e.id);t&&(_.assign(t,e),this._all.push(t))};_.forEach(this.room.memory.links,e)}return this._all}},controller:{get(){if(_.isUndefined(this._controller)){let e=e=>!0===e.controller;this._controller=this.all.filter(e)}return this._controller}},storage:{get(){if(_.isUndefined(this._storage)){let e=e=>1==e.storage;this._storage=this.all.filter(e)}return this._storage}},in:{get(){if(_.isUndefined(this._in)){let e=e=>0==e.storage&&0==e.controller;this._in=_.filter(this.all,e)}return this._in}},privateers:{get(){if(_.isUndefined(this._privateers)){let e=e=>0==e.storage&&0==e.controller&&0==e.source&&e.energy<.85*e.energyCapacity;this._privateers=_.filter(this.all,e)}return this._privateers}}})}})})}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(0);t.default=new class extends o.RoomManager{constructor(){super("nuker"),this.analyzeRoom=((e,t)=>{t&&e.saveNuker()}),this.prototypeExtend=(()=>{this.assignRoomPrototype({saveNuker:{value(){let e=this.find(FIND_MY_STRUCTURES,{filter:e=>e.structureType==STRUCTURE_NUKER});if(e.length>0){this.memory.nukers=[];let t=e=>{this.memory.nukers.find(t=>t.id==e.id)||this.memory.nukers.push({id:e.id})};e.forEach(t)}else delete this.memory.nukers}}})}),this.roomExtend=(()=>{this.assignRoom({Nuker:function(e){this.room=e,Object.defineProperties(this,{all:{get(){if(_.isUndefined(this._all)){this._all=[];let e=e=>{let t=Game.getObjectById(e.id);t&&(_.assign(t,e),this._all.push(t))};_.forEach(this.room.memory.nukers,e)}return this._all}}})}})})}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(0);t.default=new class extends o.RoomManager{constructor(){super("observer"),this.analyzeRoom=((e,t)=>{t&&(e.saveObserver(),e.structures.observer&&e.initObserverRooms())}),this.runRoom=((e,t)=>{const r=Game.rooms[t];r&&r.structures.observer&&r.controlObserver()}),this.fresh=(()=>{Memory.observerSchedule=[]}),this.prototypeExtend=(()=>{this.assignRoomPrototype({controlObserver:{value(){const e=this.structures.observer;if(!e)return;let t;if(this.memory.observer.rooms||this.initObserverRooms(),observerRequests.length>0)for(const e of observerRequests)if(Game.map.getRoomLinearDistance(this.name,e.roomName)<=10&&!Memory.observerSchedule.includes(e.roomName)){const r=e.room||Game.rooms[e.roomName];if(r&&r.creeps&&r.creeps.length&&r.creeps.length>0)continue;Memory.observerSchedule.push(e.roomName),t=e.roomName;break}let r=0;const o=this.memory.observer.rooms;if(!t){let e=Number.isInteger(this.memory.observer.lastLookedIndex)?this.memory.observer.lastLookedIndex:o.length;do{if(t=e>=o.length?o[0]:o[e+1],e=o.indexOf(t),++r>=o.length)break}while(Memory.observerSchedule.includes(t)||t in Game.rooms);this.memory.observer.lastLookedIndex=e,Memory.observerSchedule.push(t)}e.observeRoom(t)===ERR_INVALID_ARGS&&r<o.length&&(Memory.observerSchedule.splice(Memory.observerSchedule.indexOf(t),1),this.controlObserver())}},initObserverRooms:{value(){const e=OBSERVER_OBSERVE_RANGE>10?10:OBSERVER_OBSERVE_RANGE,[t,r]=Room.calcGlobalCoordinates(this.name,(e,t)=>[e,t]),[o,i]=Room.calcCardinalDirection(this.name);this.memory.observer.rooms=[];for(let a=t-e;a<t+e;a++)for(let t=r-e;t<r+e;t++){let e=o,r=i,s=a;a<0&&(e="W"===e?"E":"W",s=Math.abs(a)-1),e+=s,s=t,t<0&&(r="N"===r?"S":"N",s=Math.abs(t)-1);const n=e+(r+=s);OBSERVER_OBSERVE_HIGHWAYS_ONLY&&!Room.isHighwayRoom(n)||n in Game.rooms&&Game.rooms[n].my||Game.map.isRoomAvailable(n)&&this.memory.observer.rooms.push(n)}}},saveObserver:{value(){this.memory.observer={},[this.memory.observer.id]=this.find(FIND_MY_STRUCTURES,{filter:e=>e instanceof StructureObserver}).map(e=>e.id),_.isUndefined(this.memory.observer.id)&&delete this.memory.observer}}})})}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(0);t.default=new class extends o.RoomManager{constructor(){super("orders"),this.analyzeRoom=((e,t)=>{if(Game.time%PROCESS_ORDERS_INTERVAL==0||"sim"===e.name){e.updateResourceOrders();let t=Util.orderingRoom();1===t.length&&e.name!==t[0].name&&(e.updateRoomOrders(),e.terminalBroker())}}),this.prototypeExtend=(()=>{this.assignRoomPrototype({updateResourceOrders:{value(){let e=this.memory.resources;if(this.my&&e){this.controller.level;for(let t in e)for(let r=0;r<e[t].length;r++){let o=e[t][r];if((t!=STRUCTURE_LAB||o.reactionState==LAB_IDLE)&&o.orders)for(let e=0;e<o.orders.length;e++){let r=o.orders[e];if(r.orderRemaining<=0){let e=0,i=this.controller.level;t==STRUCTURE_STORAGE?e=r.type==RESOURCE_ENERGY?MIN_STORAGE_ENERGY[i]:MAX_STORAGE_MINERAL:t==STRUCTURE_TERMINAL&&(e=r.type==RESOURCE_ENERGY?TERMINAL_ENERGY:0),e+=r.storeAmount;let a=0,s=Game.getObjectById(o.id);if(s)switch(t){case STRUCTURE_LAB:r.type==s.mineralType?a=s.mineralAmount:r.type==RESOURCE_ENERGY&&(a=s.energy);break;case STRUCTURE_POWER_SPAWN:r.type==RESOURCE_POWER?a=s.power:r.type==RESOURCE_ENERGY&&(a=s.energy);break;default:a=s.store[r.type]||0}a<=e&&(r.orderAmount=0,r.orderRemaining=0)}}}}}},updateRoomOrders:{value(){if(!this.memory.resources||!this.memory.resources.orders)return;let e=_.filter(Game.rooms,e=>e.my&&e.storage&&e.terminal&&e.name!==this.name),t=this.memory.resources.orders;for(let r=0;r<t.length;r++){let o=t[r],i=o.amount;for(let e=0;e<o.offers.length;e++){let t=o.offers[e];if(Memory.rooms[t.room]&&Memory.rooms[t.room].resources&&Memory.rooms[t.room].resources.offers){let e=Memory.rooms[t.room].resources.offers,r=e.indexOf(e=>e.room===this.name&&e.id===o.id&&e.type===o.type);-1!==r&&e.splice(r,1)}}if(o.offers=[],i<=0)delete t[r],t.splice(r--,1);else{e.sort((e,t)=>Game.map.getRoomLinearDistance(this.name,e.name,!0)-Game.map.getRoomLinearDistance(this.name,t.name,!0));for(let t=0;t<e.length;t++){let r=e[t];void 0===r.memory.resources&&(r.memory.resources={lab:[],container:[],terminal:[],storage:[],powerSpawn:[]}),r.memory.resources.offers||(r.memory.resources.offers=[]);let a=r.memory.resources.offers,s=r.resourcesAll[o.type]||0;if(s<MIN_OFFER_AMOUNT)continue;if(!_.isUndefined(COMPOUNDS_TO_ALLOCATE[o.type])){let e=COMPOUNDS_TO_ALLOCATE[o.type].amount+COMPOUNDS_TO_ALLOCATE[o.type].threshold;if(s<e+MIN_OFFER_AMOUNT)continue;s-=e}i<MIN_OFFER_AMOUNT&&i>0&&(i=MIN_OFFER_AMOUNT),s=Math.min(s,i);let n=o.offers.find(e=>e.room===r.name),l=a.find(e=>e.room===this.name&&e.id===o.id&&e.type===o.type);if(n?(DEBUG&&TRACE&&Util.trace("Room",{roomName:this.name,remoteRoom:r.name,actionName:"updateRoomOrders",subAction:"update",orderId:o.id,resourceType:o.type,amount:s}),i-=s-n.amount,n.amount=s):(DEBUG&&TRACE&&Util.trace("Room",{roomName:this.name,remoteRoom:r.name,actionName:"updateRoomOrders",subAction:"new",orderId:o.id,resourceType:o.type,amount:s}),DEBUG&&Util.logSystem(this.name,`Room offer from ${r.name} with id ${o.id} placed for ${s} ${o.type}.`),i-=s,o.offers.push({room:r.name,amount:s})),l?l.amount=s:a.push({room:this.name,id:o.id,type:o.type,amount:s}),i<=0)break}}}}},fillARoomOrder:{value(){if(!(this.terminal&&this.memory&&this.memory.resources&&this.memory.resources.offers))return!1;let e=this.memory.resources.offers,t=!1;for(let r=0;r<e.length;r++){let o=e[r],i=Game.rooms[o.room];if(!(i&&i.memory&&i.memory.resources&&i.memory.resources.orders))continue;let a=i.memory.resources.orders.find(e=>e.id==o.id&&e.type==o.type);if(!a)continue;let s=a.offers.findIndex(e=>e.room==this.name);if(-1==s){Util.logSystem(this.name,"Orphaned offer found and deleted"),e.splice(r--,1);continue}let n=this.terminal.store[o.type]||0,l=0,m=null;this.memory.resources.terminal[0]&&(m=this.memory.resources.terminal[0].orders.find(e=>e.type==o.type)),m&&(l=m.orderRemaining);let c=Math.max(o.amount,MIN_OFFER_AMOUNT);if(c>n+l){let e=c-(n+l);DEBUG&&TRACE&&Util.trace("Room",{actionName:"fillARoomOrder",subAction:"terminalOrder",roomName:this.name,targetRoomName:i.name,resourceType:o.type,amount:e}),this.placeOrder(this.terminal.id,o.type,e)}if(!i.terminal)continue;let u=i.terminal.storeCapacity-i.terminal.sum;c=Math.min(c,u,n);let d=Game.market.calcTransactionCost(c,this.name,i.name);if(o.type==RESOURCE_ENERGY&&(d+=c-=d),!(d>(this.terminal.store.energy||0)||c<MIN_OFFER_AMOUNT||(t=this.terminal.send(o.type,c,i.name,a.id))!=OK))return DEBUG&&TRACE&&Util.trace("Room",{actionName:"fillARoomOrder",roomName:this.name,targetRoomName:i.name,resourceType:o.type,amount:c}),DEBUG&&Util.logSystem(this.name,`Room order filled to ${i.name} for ${c} ${o.type}.`),o.amount-=c,o.amount>0?a.offers[s].amount=o.amount:(delete a.offers[s],a.offers.splice(s,1),delete e[r],e.splice(r--,1)),a.amount-=c,!0}return t}},prepareResourceOrder:{value(e,t,r){let o=Game.getObjectById(e);if(!this.my||!o||!o.room.name==this.name||o.structureType!=STRUCTURE_LAB&&o.structureType!=STRUCTURE_POWER_SPAWN&&o.structureType!=STRUCTURE_CONTAINER&&o.structureType!=STRUCTURE_STORAGE&&o.structureType!=STRUCTURE_TERMINAL)return ERR_INVALID_TARGET;if(!RESOURCES_ALL.includes(t))return ERR_INVALID_ARGS;if(void 0===this.memory.resources&&(this.memory.resources={lab:[],powerSpawn:[],container:[],terminal:[],storage:[]}),void 0===this.memory.resources.powerSpawn&&(this.memory.resources.powerSpawn=[]),this.memory.resources[o.structureType].find(t=>t.id==e)||this.memory.resources[o.structureType].push(o.structureType==STRUCTURE_LAB?{id:e,orders:[],reactionState:LAB_IDLE}:{id:e,orders:[]}),o.structureType==STRUCTURE_LAB&&t!=RESOURCE_ENERGY&&r>0){let r=this.memory.resources[STRUCTURE_LAB].find(t=>t.id==e).orders;for(let e=0;e<r.length;e++)r[e].type!=t&&r[e].type!=RESOURCE_ENERGY&&(r[e].orderAmount=0,r[e].orderRemaining=0,r[e].storeAmount=0)}return OK}},cancelOrder:{value(e,t=null){let r=Game.getObjectById(e);if(this.prepareResourceOrder(e,RESOURCE_ENERGY,0)!=OK)return ret;let o=this.memory.resources[r.structureType].find(t=>t.id==e);if(o)if(t){let e=o.orders.find(e=>e.type==t);e&&(DEBUG&&TRACE&&Util.trace("Room",{roomName:this.name,actionName:"cancelOrder",orderId:orderId,resourceType:t}),o.orders.splice(o.orders.indexOf(e),1))}else DEBUG&&TRACE&&Util.trace("Room",{roomName:this.name,actionName:"cancelOrder",orderId:orderId,resourceType:"all"}),o.orders=[];return OK}},registerBoostLab:{value(e){if(Game.getObjectById(e)){_.isUndefined(this.memory.resources)&&(this.memory.resources={lab:[],powerSpawn:[],container:[],terminal:[],storage:[]});let t=this.memory.resources.lab.findIndex(t=>t.id==e);if(t>-1)delete this.memory.resources.lab[t].reactionType,this.memory.resources.lab[t].reactionState="Storage";else{let t={id:e,orders:[],reactionState:"Storage"};this.memory.resources.lab.push(t)}}}},unRegisterBoostLab:{value(e){let t=Game.getObjectById(e),r=this.memory.resources;if(t&&r){let t=this.memory.resources.lab.findIndex(t=>t.id===e);t>-1&&(r.reactions.orders.length>0&&(this.memory.resources.lab[t].reactionType=this.memory.resources.reactions.orders[0].type),this.memory.resources.lab[t].reactionState="idle",this.memory.resources.lab[t].orders=_.filter(this.memory.resources.lab[t].orders,"type","energy"))}}},placeOrder:{value(e,t,r){let o=Game.getObjectById(e),i=this.prepareResourceOrder(e,t,r);if(i!=OK)return i;let a=this.memory.resources[o.structureType].find(t=>t.id==e);if(a){let e=a.orders.find(e=>e.type==t);if(e)e.orderAmount+=r,e.orderRemaining+=r;else{let e=0;e=o.structureType===STRUCTURE_LAB?o.mineralType==t?o.mineralAmount:0:o.store[t]||0,a.orders.push({type:t,orderAmount:r,orderRemaining:r-e,storeAmount:0}),o.structureType===STRUCTURE_LAB&&"Storage"!=a.reactionState&&(a.reactionType=t)}}return OK}},setStore:{value(e,t,r){let o=Game.getObjectById(e),i=this.prepareResourceOrder(e,t,r);if(i!=OK)return i;let a=this.memory.resources[o.structureType].find(t=>t.id==e);if(a){let e=a.orders.find(e=>e.type==t);e?e.storeAmount=r:a.orders.push({type:t,orderAmount:0,orderRemaining:0,storeAmount:r})}return OK}},cancelRoomOrder:{value(e=null,t=null){void 0===this.memory.resources&&(this.memory.resources={lab:[],container:[],terminal:[],storage:[]}),void 0===this.memory.resources.powerSpawn&&(this.memory.resources.powerSpawn=[]),void 0===this.memory.resources.orders&&(this.memory.resources.orders=[]);let r=this.memory.resources.orders;if(e&&t){let o=r.find(r=>r.id==e&&r.type==t);o&&(DEBUG&&TRACE&&Util.trace("Room",{roomName:this.name,actionName:"cancelRoomOrder",orderId:e,resourceType:t}),r.splice(r.indexOf(o),1))}else if(e){DEBUG&&TRACE&&Util.trace("Room",{roomName:this.name,actionName:"cancelRoomOrder",orderId:e,resourceType:"all"});for(let t=0;t<r.length;t++)r[t].id===e&&r.splice(t--,1)}else this.memory.resources.orders=[];return OK}},placeRoomOrder:{value(e,t,r){if(r<=0)return OK;void 0===this.memory.resources&&(this.memory.resources={lab:[],container:[],terminal:[],storage:[]}),void 0===this.memory.resources.powerSpawn&&(this.memory.resources.powerSpawn=[]),void 0===this.memory.resources.orders&&(this.memory.resources.orders=[]);let o=this.memory.resources.orders,i=o.find(r=>r.id==e&&r.type==t);return i?(DEBUG&&TRACE&&Util.trace("Room",{roomName:this.name,actionName:"placeRoomOrder",subAction:"update",orderId:e,resourceType:t,amount:r}),i.amount=r):(DEBUG&&TRACE&&Util.trace("Room",{roomName:this.name,actionName:"placeRoomOrder",subAction:"new",orderId:e,resourceType:t,amount:r}),DEBUG&&Util.logSystem(this.name,`New room order with id ${e} placed for ${r} ${t}.`),o.push({id:e,type:t,amount:r,offers:[]})),OK}},terminalBroker:{value(){if(!this.my||!this.terminal||!this.storage)return;if(this.terminal.cooldown&&this.terminal.cooldown>0)return;let e=this,t=!1;for(const r in this.terminal.store){if(r===RESOURCE_ENERGY||r===RESOURCE_POWER)continue;if((MAKE_COMPOUNDS||ALLOCATE_COMPOUNDS)&&r!==this.memory.mineralType)continue;let o=this.terminal.sum/this.terminal.storeCapacity>.8;if(this.terminal.store[r]>=MIN_MINERAL_SELL_AMOUNT){let i;AUTOMATED_RATIO_COUNT?(i=Util.countPrices("buy",r,e.name),DEBUG&&(0===i?console.log(`there is no buy order for ${r}`):console.log(`average buyRatio: ${e.name} ${r} ${i}`))):i=MIN_SELL_RATIO[r];let a=Game.market.getAllOrders(t=>!(!t.roomName||t.resourceType!=r||"buy"!=t.type||t.amount<MIN_MINERAL_SELL_AMOUNT)&&(t.range=Game.map.getRoomLinearDistance(t.roomName,e.name,!0),t.transactionAmount=Math.min(t.amount,e.terminal.store[r]),t.transactionCost=Game.market.calcTransactionCost(t.transactionAmount,e.name,t.roomName),t.transactionCost>e.terminal.store.energy&&t.transactionAmount>MIN_MINERAL_SELL_AMOUNT&&(t.transactionAmount=MIN_MINERAL_SELL_AMOUNT,t.transactionCost=Game.market.calcTransactionCost(t.transactionAmount,e.name,t.roomName)),t.credits=t.transactionAmount*t.price,t.ratio=(t.credits-t.transactionCost*ENERGY_VALUE_CREDITS)/t.transactionAmount,o||t.ratio>=i&&t.transactionCost<=e.terminal.store.energy));if(a.length>0){let o=_.max(a,"ratio");DEBUG&&(console.log("selected order: "),Util.logStringify(o));let i=Game.market.deal(o.id,o.transactionAmount,e.name);(DEBUG||SELL_NOTIFICATION)&&Util.logSystem(e.name,`Selling ${o.transactionAmount} ${r} for ${Util.roundUp(o.credits)} (${o.price} /${r}, ${o.transactionCost} e): ${Util.translateErrorCode(i)}`),SELL_NOTIFICATION&&Game.notify(`<h2>Room ${e.name} rund an order!</h2><br/>Result: ${Util.translateErrorCode(i)}<br/>Details:<br/>${JSON.stringify(o).replace(",",",<br/>")}`),t=i==OK;break}}}if(8==this.controller.level&&!t&&Util.chargeScale(this.storage.store.energy-ENERGY_BALANCE_TRANSFER_AMOUNT,MIN_STORAGE_ENERGY[this.controller.level],MAX_STORAGE_ENERGY[this.controller.level])>1&&(this.terminal.store[this.mineralType]||0)<15e4&&this.terminal.store.energy>1.1*ENERGY_BALANCE_TRANSFER_AMOUNT){let r=e=>e.my&&e.storage&&e.terminal&&e.terminal.sum<e.terminal.storeCapacity-ENERGY_BALANCE_TRANSFER_AMOUNT&&e.storage.sum<e.storage.storeCapacity*TARGET_STORAGE_SUM_RATIO&&!e._isReceivingEnergy&&e.storage.store[RESOURCE_ENERGY]<MAX_STORAGE_ENERGY[e.controller.level],o=_.min(_.filter(Game.rooms,r),"storage.store.energy");if(o instanceof Room&&Game.market.calcTransactionCost(ENERGY_BALANCE_TRANSFER_AMOUNT,this.name,o.name)<this.terminal.store.energy-ENERGY_BALANCE_TRANSFER_AMOUNT){o._isReceivingEnergy=!0;let r=this.terminal.send("energy",ENERGY_BALANCE_TRANSFER_AMOUNT,o.name,"have fun");DEBUG&&Util.logSystem(e.name,`Transferring ${Util.formatNumber(ENERGY_BALANCE_TRANSFER_AMOUNT)} energy to ${o.name}: ${Util.translateErrorCode(r)}`),t=r==OK}}t||Memory.boostTiming||!0!==(t=this.fillARoomOrder())&&(t=!1)}}})})}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(0);t.default=new class extends o.RoomManager{constructor(){super("power"),this.analyzeRoom=((e,t)=>{t&&e.savePowerSpawn(),e.structures.powerSpawn&&e.processPower()}),this.freshRoom=(e=>{e._powerBank||delete e.memory.powerBank}),this.prototypeExtend=(()=>{this.assignRoomPrototype({powerBank:{get(){return _.isUndefined(this.memory.powerBank)&&([this._powerBank]=this.find(FIND_STRUCTURES,{filter:e=>e instanceof StructurePowerBank}),this._powerBank&&(this.memory.powerBank=this._powerBank.id)),_.isUndefined(this._powerBank)&&(this._powerBank=Game.getObjectById(this.memory.powerBank)),this._powerBank}},savePowerSpawn:{value(){let e=this.find(FIND_MY_STRUCTURES,{filter:e=>e.structureType==STRUCTURE_POWER_SPAWN});if(e.length>0){this.memory.powerSpawns=[];let t=e=>{this.memory.powerSpawns.find(t=>t.id==e.id)||this.memory.powerSpawns.push({id:e.id})};e.forEach(t)}else delete this.memory.powerSpawns}},processPower:{value(){let e=this.find(FIND_MY_STRUCTURES,{filter:e=>e.structureType==STRUCTURE_POWER_SPAWN});for(let t=0;t<e.length;t++){let r=e[t];r.energy>=POWER_SPAWN_ENERGY_RATIO&&r.power>=1&&(DEBUG&&TRACE&&Util.trace("Room",{roomName:this.name,actionName:"processPower"}),r.processPower())}}}})}),this.roomExtend=(()=>{this.assignRoom({PowerSpawn:function(e){this.room=e,Object.defineProperties(this,{all:{get(){if(_.isUndefined(this._all)){this._all=[];let e=e=>{let t=Game.getObjectById(e.id);t&&(_.assign(t,e),this._all.push(t))};_.forEach(this.room.memory.powerSpawns,e)}return this._all}}})}})})}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(0);t.default=new class extends o.RoomManager{constructor(){super("resources"),this.analyzeRoom=((e,t)=>{t&&e.saveMinerals()}),this.prototypeExtend=(()=>{this.assignRoomPrototype({resourcesStorage:{get(){return _.isUndefined(this._resourcesStorage)&&(this._resourcesStorage={},_.isUndefined(this.storage)||Object.keys(this.storage.store).forEach(e=>{_.isUndefined(this._resourcesStorage[e])&&(this._resourcesStorage[e]=this.storage.store[e])})),this._resourcesStorage}},resourcesTerminal:{get(){return _.isUndefined(this._resourcesTerminal)&&(this._resourcesTerminal={},_.isUndefined(this.terminal)||Object.keys(this.terminal.store).forEach(e=>{_.isUndefined(this._resourcesTerminal[e])&&(this._resourcesTerminal[e]=this.terminal.store[e])})),this._resourcesTerminal}},resourcesLabs:{get(){if(_.isUndefined(this._resourcesLabs)){this._resourcesLabs={};let e=this.memory.resources;if(!_.isUndefined(e)&&!_.isUndefined(e.lab))for(let t of e.lab)if("Storage"!==t.reactionState){let e=Game.getObjectById(t.id),r=e.mineralType,o=e.mineralAmount;_.isUndefined(r)||(_.isUndefined(this._resourcesLabs[r])?this._resourcesLabs[r]=o:this._resourcesLabs[r]+=o)}}return this._resourcesLabs}},resourcesCreeps:{get(){if(_.isUndefined(this._resourcesCreeps)){this._resourcesCreeps={};for(let e of this.creeps)Object.keys(e.carries).forEach(t=>{_.isUndefined(this._resourcesCreeps[t])?this._resourcesCreeps[t]=e.carry[t]:this._resourcesCreeps[t]+=e.carry[t]})}return this._resourcesCreeps}},resourcesOffers:{get(){if(_.isUndefined(this._resourcesOffers)){this._resourcesOffers={};let e=this.memory.resources;_.isUndefined(e)||_.isUndefined(e.offers)||(this._resourcesOffers=Util.sumCompoundType(e.offers))}return this._resourcesOffers}},resourcesOrders:{get(){if(_.isUndefined(this._resourcesOrders)){this._resourcesOrders={};let e=this.memory.resources;_.isUndefined(e)||_.isUndefined(e.orders)||(this._resourcesOrders=Util.sumCompoundType(e.orders))}return this._resourcesOrders}},resourcesReactions:{get(){if(_.isUndefined(this._resourcesReactions)){this._resourcesReactions={};let e=this.memory.resources;if(!_.isUndefined(e)&&!_.isUndefined(e.reactions)&&!_.isUndefined(e.reactions.orders)&&1===e.reactions.orders.length){let t=e.reactions,r=t.orders[0],o=r.type,i=r.amount,a=LAB_REACTIONS[o][0],s=LAB_REACTIONS[o][1],n=Game.getObjectById(t.seed_a),l=Game.getObjectById(t.seed_b),m=n.mineralAmount,c=l.mineralAmount;this._resourcesReactions[a]=i-m,this._resourcesReactions[s]=i-c}}return this._resourcesReactions}},resourcesAll:{get(){return _.isUndefined(this._resourcesAll)&&(this._resourcesAll={},_.isUndefined(this.storage)||Object.keys(this.storage.store).forEach(e=>{_.isUndefined(this._resourcesAll[e])&&(this._resourcesAll[e]=this.storedMinerals(e))}),_.isUndefined(this.terminal)||Object.keys(this.terminal.store).forEach(e=>{_.isUndefined(this._resourcesAll[e])&&(this._resourcesAll[e]=this.storedMinerals(e))})),this._resourcesAll}},droppedResources:{get(){return _.isUndefined(this._droppedResources)&&(this._droppedResources=this.find(FIND_DROPPED_RESOURCES)),this._droppedResources}},minerals:{get(){if(_.isUndefined(this._minerals)){this._minerals=[];let e=e=>{Util.addById(this._minerals,e)};_.forEach(this.memory.minerals,e)}return this._minerals}},mineralType:{get(){if(_.isUndefined(this.memory.mineralType)){let e=this.find(FIND_MINERALS);e&&e.length>0?this.memory.mineralType=e[0].mineralType:this.memory.mineralType=""}return this.memory.mineralType}},sources:{get(){if((_.isUndefined(this.memory.sources)||"sim"==this.name)&&(this._sources=this.find(FIND_SOURCES),this._sources.length>0?this.memory.sources=this._sources.map(e=>e.id):this.memory.sources=[]),_.isUndefined(this._sources)){this._sources=[];let e=e=>{Util.addById(this._sources,e)};this.memory.sources.forEach(e)}return this._sources}},sourceAccessibleFields:{get(){if(_.isUndefined(this.memory.sourceAccessibleFields)){let e=0,t=this.sources,r=t=>e+=t.accessibleFields;_.forEach(t,r),this.memory.sourceAccessibleFields=e}return this.memory.sourceAccessibleFields}},sourceEnergyAvailable:{get(){if(_.isUndefined(this._sourceEnergyAvailable)){this._sourceEnergyAvailable=0;let e=e=>this._sourceEnergyAvailable+=e.energy;_.forEach(this.sources,e)}return this._sourceEnergyAvailable}},ticksToNextRegeneration:{get(){return _.isUndefined(this._ticksToNextRegeneration)&&(this._ticksToNextRegeneration=_(this.sources).map("ticksToRegeneration").min()||0),this._ticksToNextRegeneration}},saveMinerals:{value(){let e=this.structures.all.filter(e=>e.structureType===STRUCTURE_EXTRACTOR&&e.active).map(e=>({x:e.pos.x,y:e.pos.y}));const t=this.find(FIND_MINERALS).filter(t=>_.some(e,{x:t.pos.x,y:t.pos.y}));if(t.length>0){let e=e=>e.id;this.memory.minerals=_.map(t,e)}else delete this.memory.minerals}}})})}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(0);t.default=new class extends o.RoomManager{constructor(){super("spawn"),this.analyzeRoom=((e,t)=>{t&&e.saveSpawns()}),this.prototypeExtend=(()=>{this.assignRoomPrototype({spawnQueueHigh:{get(){return _.isUndefined(this.memory.spawnQueueHigh)&&(this.memory.spawnQueueHigh=[]),this.memory.spawnQueueHigh}},spawnQueueMedium:{get(){return _.isUndefined(this.memory.spawnQueueMedium)&&(this.memory.spawnQueueMedium=[]),this.memory.spawnQueueMedium}},spawnQueueLow:{get(){return _.isUndefined(this.memory.spawnQueueLow)&&(this.memory.spawnQueueLow=[]),this.memory.spawnQueueLow}},saveSpawns:{value(){let e=this.find(FIND_MY_SPAWNS);if(e.length>0){let t=e=>e.id;this.memory.spawns=_.map(e,t)}else delete this.memory.spawns}}})}),this.roomExtend=(()=>{this.assignRoom({bestSpawnRoomFor:e=>_.min(Game.rooms,t=>t.my?Util.routeRange(t.name,e):1/0),findSpawnRoom:e=>{if(!e||!e.targetRoom)return null;let t=_.filter(Game.rooms,t=>t.my&&(void 0===e.maxRange||Util.routeRange(t.name,e.targetRoom)<=e.maxRange)&&(void 0===e.minEnergyCapacity||e.minEnergyCapacity<=t.energyCapacityAvailable)&&(void 0===e.minEnergyAvailable||e.minEnergyAvailable<=t.energyAvailable)&&(t.name!=e.targetRoom||!0===e.allowTargetRoom)&&(void 0===e.minRCL||t.controller.level>=e.minRCL)&&(void 0===e.callBack||e.callBack(t)));if(0==t.length)return null;let r=e=>_.sum(e,e=>3*e.parts.length);return _.min(t,t=>Util.routeRange(t.name,e.targetRoom)+(8-t.controller.level)/(e.rangeRclRatio||3)+(e=>(.9*r(e.spawnQueueLow)+r(e.spawnQueueMedium)+1.1*r(e.spawnQueueHigh))/e.structures.spawns.length)(t)/(e.rangeQueueRatio||51))}})})}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(0);t.default=new class extends o.RoomManager{constructor(){super("tower"),this.analyzeRoom=((e,t)=>{t&&e.saveTowers()}),this.runRoom=((e,t)=>{const r=Game.rooms[t];r&&r.structures.towers.length>0&&StructureTower.loop(r)}),this.prototypeExtend=(()=>{this.assignRoomPrototype({towerFreeCapacity:{get(){if(_.isUndefined(this._towerFreeCapacity)){this._towerFreeCapacity=0;let e=e=>this._towerFreeCapacity+=e.energyCapacity-e.energy;_.forEach(this.structures.towers,e)}return this._towerFreeCapacity}},saveTowers:{value(){let e=this.find(FIND_MY_STRUCTURES,{filter:{structureType:STRUCTURE_TOWER}});if(e.length>0){let t=e=>e.id;this.memory.towers=_.map(e,t)}else delete this.memory.towers}}})})}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(0);t.default=new class extends o.RoomManager{constructor(){super("fillRoomOrders"),this.analyze=(()=>{this.fillRoomOrders()}),this.fillRoomOrders=(()=>{if(!MAKE_COMPOUNDS&&!ALLOCATE_COMPOUNDS)return;_.isUndefined(Memory.boostTiming)&&(Memory.boostTiming={}),_.isUndefined(Memory.boostTiming.roomTrading)&&(Memory.boostTiming.roomTrading={boostProduction:!1,boostAllocation:!1}),_.isUndefined(Memory.boostTiming.timeStamp)&&(Memory.boostTiming.timeStamp=Game.time);let e,t=Util.orderingRoom(),r=t.length,o=Memory.boostTiming.roomTrading,i=_.filter(Game.rooms,{my:!0}),a=_.some(i,e=>{let t=e.memory.resources;return!(!t||!t.boostTiming)&&"reactionPlaced"===t.boostTiming.roomState});if(a&&!1===Memory.boostTiming.roomTrading.boostProduction&&(Memory.boostTiming.roomTrading.boostProduction=!0,Memory.boostTiming.timeStamp=Game.time),1===r){let r=t[0];o.boostProduction&&(e=`BOOST_PRODUCTION since: ${Game.time-Memory.boostTiming.timeStamp}`),o.boostAllocation&&(e=`BOOST_ALLOCATION since: ${Game.time-Memory.boostTiming.timeStamp}`),Memory.boostTiming.multiOrderingRoomName?Util.logSystem(r.name,`multi ordering in progress at ${Memory.boostTiming.multiOrderingRoomName}`):Util.logSystem(r.name,`orderingRoom.name: ${r.name}, checkRoomAt: ${(r.memory.resources.boostTiming.checkRoomAt||0)-Game.time} ${e}`)}else r>1&&(console.log(`WARNING: ${r} ordering rooms!`),Util.logStringify(t));if(1===t.length&&Game.time>=t[0].memory.resources.boostTiming.checkRoomAt&&!Memory.boostTiming.multiOrderingRoomName){let e=t[0],r=e.memory.resources;if(e.ordersWithOffers()){let t=e.checkOffers();Util.logSystem(e.name,`checkOffers running from ${e.name} returnValue: ${t}`)}else Util.logSystem(e.name,`${e.name} no offers found, updating offers`),e.GCOrders(),Util.logStringify(r.orders)}else if(0===t.length){let e=Memory.boostTiming.roomTrading;!0!==e.boostProduction||a?!0===e.boostAllocation&&(e.boostAllocation=!1,Memory.boostTiming.timeStamp=Game.time):(e.boostProduction=!1,Memory.boostTiming.timeStamp=Game.time)}if((MAKE_COMPOUNDS||ALLOCATE_COMPOUNDS)&&Memory.boostTiming&&Memory.boostTiming.multiOrderingRoomName){let e=Game.rooms[Memory.boostTiming.multiOrderingRoomName],t=e.memory.resources.boostTiming.ordersReady,r=t.orderCandidates,o=!1;if(Game.time<t.time)return;if(0===r.length)return Util.logSystem(e.name,`all ready offers completed to ${Memory.boostTiming.multiOrderingRoomName} Memory.boostTiming.multiOrderingRoomName deleted.`),Game.rooms[Memory.boostTiming.multiOrderingRoomName].memory.resources.boostTiming.checkRoomAt=Game.time+CHECK_ORDERS_INTERVAL,delete Memory.boostTiming.multiOrderingRoomName,void delete e.memory.resources.boostTiming.ordersReady;for(let i=0;i<r.length;i++){let a=r[i],s=Game.rooms[a.room];if(a.readyOffers>0){if(s.terminal.cooldown>0){Util.logSystem(s.name,`${s.name} terminal.cooldown: ${s.terminal.cooldown} fillARoomOrder() delayed.`),t.time=Game.time+s.terminal.cooldown;continue}t.time=Game.time+1,Util.logSystem(e.name,`running ${a.room} fillARoomOrder() in a row, time: ${Game.time} readyOffers: ${a.readyOffers}`),!0===(o=s.fillARoomOrder())?(a.readyOffers--,a.readyOffers>=1?Util.logSystem(a.room,`has ${a.readyOffers} remains fillRoomOrders check. readyOffers: ${a.readyOffers}`):(Util.logSystem(e.name,`offers from ${a.room} are completed`),r.splice(i,1),i--)):o===ERR_TIRED?(t.time=Game.time+s.terminal.cooldown,Util.logSystem(a.room,`${a.room} offers from ${a.room} failed send to ${e.name}.  Terminal.cooldown: ${s.terminal.cooldown}`)):o===ERR_NOT_ENOUGH_RESOURCES?(Util.logSystem(e.name,`WARNING: offers from ${a.room} are not completed: not enough resources`),r.splice(i,1),i--):!0!==o&&o!==OK&&(Util.logSystem(e.name,`WARNING: offers from ${a.room} are not completed. Offers deleted. terminal.send returns: ${Util.translateErrorCode(o)}`),r.splice(i,1),i--)}}}})}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(0);t.default=new class extends o.RoomManager{constructor(){super("boostProduction"),this.analyze=(()=>{this.boostProduction()}),this.boostProduction=(()=>{if(!MAKE_COMPOUNDS)return;let e=Memory.boostTiming.roomTrading;if(!e.boostAllocation&&!e.reallocating&&Game.time%MAKE_COMPOUNDS_INTERVAL==0){let e=_.filter(Game.rooms,{my:!0}),t=Util.orderingRoom(),r=_.some(e,e=>{let t=e.memory.resources;return!(!t||!t.boostTiming)&&"reactionPlaced"===t.boostTiming.roomState}),o=t.length,i=!1;for(let t of e){let e=t.memory.resources;if(_.isUndefined(e))continue;let a=e.boostTiming,s=function(){if(0===e.reactions.orders.length)return!1;let t=e.reactions.orders[0].type;return _.some(e.lab,e=>{let r=Game.getObjectById(e.id);return r.mineralType===t&&r.mineralAmount>0})};if(0!==e.orders.length&&0!==_.sum(e.orders,"amount")||"ordersPlaced"!==a.roomState||s()&&(a.roomState="reactionMaking",a.checkRoomAt=Game.time,delete a.getOfferAttempts,Util.logSystem(t.name,`${t.name} orders done.`)),0!==o||r||i||(i=t.makeReaction()),e.reactions&&"burst"===e.reactions.reactorMode&&"reactionMaking"===e.boostTiming.roomState&&a.checkRoomAt-Game.time<=150&&Game.time%50==0){let r=e.reactions.orders[0];Util.logSystem(t.name,`${t.name}, finishing ${r.type}. checkRoomAt: ${a.checkRoomAt-Game.time}`);let o=Game.getObjectById(e.reactions.seed_a),i=Game.getObjectById(e.reactions.seed_b),s=r.type,n=LAB_REACTIONS[s][0],l=LAB_REACTIONS[s][1],m=r.amount,c=t.getSeedLabOrders(),u=c.labOrderAmountA,d=c.labOrderAmountB,h=t.resourcesAll[n],g=t.resourcesAll[l],p=o.mineralAmount+u,f=i.mineralAmount+d;if(Util.logSystem(t.name,`reactionAmount ${m}`),Util.logSystem(t.name,`labs stored: seed_a: ${o.mineralAmount} ${n} seed_b: ${i.mineralAmount} ${l}`),Util.logSystem(t.name,`labs ordered: seed_a: ${u} ${n} seed_b: ${d} ${l}`),p===m&&f===m)Util.logSystem(t.name,"lab orders OK"),m>0&&((_.isUndefined(h)||0===h)&&o.mineralAmount<LAB_REACTION_AMOUNT||(_.isUndefined(g)||0===g)&&i.mineralAmount<LAB_REACTION_AMOUNT)&&(r.amount=0,Util.logSystem(t.name,"resources NOT OK"),Util.logSystem(t.name,`resourcesA: ${h} resourcesB: ${g}`),Util.logSystem(t.name,`reactionOrders fixed: ${r.amount}`));else if(m>p||m>f){Util.logSystem(t.name,"NOT ENOUGH lab orders:"),Util.logSystem(t.name,`${t.name} reactionAmount: ${m} DIFF: labA: ${p-m} labB: ${f-m}`);let e=Math.min(p,f);e>=LAB_REACTION_AMOUNT?r.amount=e:r.amount=0,Util.logSystem(t.name,`reactionOrders fixed: ${r.amount}`)}else if(m<p||m<f){Util.logSystem(t.name,"TOO MUCH lab orders:"),Util.logSystem(t.name,`${t.name} reactionAmount: ${m} DIFF: labA: ${p-m} labB: ${f-m}`);let e=Math.min(p,f);e>=LAB_REACTION_AMOUNT?r.amount=e:r.amount=0,Util.logSystem(t.name,`reactionOrders fixed: ${r.amount}`)}}Game.time>=a.checkRoomAt&&"reactionMaking"===e.boostTiming.roomState&&(_.sum(e.reactions.orders,"amount")>0?(a.reactionMaking=Game.time,t.countCheckRoomAt(),Util.logSystem(t.name,`${t.name} checkRoomAt counted: ${a.checkRoomAt-Game.time}`)):(console.log(`Game.time: ${Game.time}`),Util.logSystem(t.name,`reactions done in in ${t.name}`),e.boostTiming={}))}}})}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(0);t.default=new class extends o.Component{constructor(){super(...arguments),this.loop=(e=>{_.forEach(e.structures.towers,e=>this.run(e))}),this.run=(e=>{if(e){if(e.room.casualties.length>0){let t=e.room.casualties[0];if(t.hitsMax-t.hits>=400||!e.room.situation.invasion)return e.heal(t),void 0===t.towers&&(t.towers=[]),void t.towers.push(e.id)}if(e.room.structures.urgentRepairable.length>0){let t=e.room.structures.urgentRepairable[0];return e.repair(t),void 0===t.towers&&(t.towers=[]),void t.towers.push(e.id)}let t=e.pos.findClosestByRange(e.room.hostiles);t&&e.attack(t)}})}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(0);t.default=new class extends o.Component{constructor(){super(...arguments),this.priorityHigh=[Creep.setup.worker,Creep.setup.miner,Creep.setup.hauler,Creep.setup.upgrader],this.priorityLow=[Creep.setup.mineralMiner,Creep.setup.privateer],this.extend=(()=>{}),this.register=(()=>{Creep.spawningCompleted.on(e=>this.handleSpawningCompleted(e))}),this.handleSpawningCompleted=(e=>{DEBUG&&TRACE&&Util.trace("Spawn",{behaviour:e.data.creepType,creepName:e.name,Spawn:"Creep.spawningCompleted"}),CENSUS_ANNOUNCEMENTS&&Util.logSystem(e.pos.roomName,Util.dye(CRAYON.birth,"Off to work "+e.name+"!"))}),this.run=(()=>{_.forEach(Game.spawns,e=>{e.room.my&&e.run()})})}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o=r(0);t.default=new class extends o.Component{constructor(){super(...arguments),this.run=(()=>{Memory.stats={tick:Game.time},Memory.stats.cpu=Game.cpu,Memory.stats.cpu.used=Game.cpu.getUsed(),Memory.stats.gcl=Game.gcl,Memory.stats.market={credits:Game.market.credits,numOrders:Game.market.orders?Object.keys(Game.market.orders).length:0},Memory.stats.rooms={};for(let e in Game.rooms){const t=Game.rooms[e];t&&t.my&&(Memory.stats.rooms[t.name]={name:t.name,spawns:{},storage:{},terminal:{},minerals:{},sources:{}},this.init(t,Memory.stats.rooms[t.name]))}}),this.init=((e,t)=>{this.controller(e,t),this.energy(e,t),this.spawns(e,t.spawns),this.storage(e,t.storage),this.terminal(e,t.terminal),this.minerals(e,t.minerals),this.sources(e,t.sources)}),this.controller=((e,t)=>{e.controller&&(t.controller={level:e.controller.level,progress:e.controller.progress,progressTotal:e.controller.progressTotal})}),this.energy=((e,t)=>{t.energy={available:e.energyAvailable,capacityAvailable:e.energyCapacityAvailable}}),this.spawns=((e,t)=>{e.structures.spawns&&e.structures.spawns.forEach(e=>{t[e.name]={name:e.name,spawning:null!==e.spawning?1:0}})}),this.storage=((e,t)=>{e.storage&&(t.store=_.sum(e.storage.store),t.resources={},Object.keys(e.storage.store).forEach(r=>t.resources[r]=e.storage.store[r]))}),this.terminal=((e,t)=>{e.terminal&&(t.store=_.sum(e.terminal.store),t.resources={},Object.keys(e.terminal.store).forEach(r=>t.resources[r]=e.terminal.store[r]))}),this.minerals=((e,t)=>{e.minerals&&e.minerals.forEach(e=>t[e.id]={id:e.id,density:e.density,mineralAmount:e.mineralAmount,mineralType:e.mineralType,ticksToRegeneration:e.ticksToRegeneration})}),this.sources=((e,t)=>{e.sources&&e.sources.forEach(e=>t[e.id]={id:e.id,energy:e.energy,energyCapacity:e.energyCapacity,ticksToRegeneration:e.ticksToRegeneration})})}}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const o="#000000",i="#FFFFFF",a="#FF0000",s="#00FF00",n="#FFFF00",l="#00FFFF";t.default=new class{constructor(){this.run=(()=>{const e=VISUALS.VISIBLE_ONLY,t=e?Util.getVisibleRooms():Object.keys(Game.rooms);_.forEach(t,t=>{const r=Game.rooms[t];if(r&&(ROOM_VISUALS_ALL||r.my)&&(e||r.controller))if(Util.set(Memory,"heatmap",!1),VISUALS.HEATMAP&&(Game.time%VISUALS.HEATMAP_INTERVAL==0&&this.setHeatMapData(r),Memory.heatmap))this.drawHeatMapData(r);else{if(VISUALS.ROOM&&r.controller&&this.drawRoomInfo(r,VISUALS.ROOM_GLOBAL),VISUALS.ROOM_ORDERS&&this.drawRoomOrders(r),VISUALS.ROOM_OFFERS&&this.drawRoomOffers(r),VISUALS.CONTROLLER&&this.drawControllerInfo(r.controller),VISUALS.SPAWN&&r.structures.spawns.filter(e=>e.spawning).forEach(e=>this.drawSpawnInfo(e)),VISUALS.MINERAL){let[e]=r.minerals;e&&this.drawMineralInfo(e)}VISUALS.SOURCE&&r.sources.forEach(e=>this.drawSourceInfo(e)),VISUALS.WALL&&this.highlightWeakest(r,STRUCTURE_WALL),VISUALS.RAMPART&&this.highlightWeakest(r,STRUCTURE_RAMPART),VISUALS.ROAD&&this.highlightWeakest(r,STRUCTURE_ROAD),VISUALS.STORAGE&&this.drawStorageInfo(r.storage),VISUALS.TERMINAL&&this.drawTerminalInfo(r.terminal),VISUALS.TRANSACTIONS&&this.drawTransactions(r),VISUALS.LABS&&r.structures.labs.all.forEach(e=>this.drawLabInfo(e)),VISUALS.CREEP&&r.creeps.forEach(e=>this.drawCreepPath(e)),VISUALS.TOWER&&r.structures.towers.forEach(e=>this.drawTowerInfo(e))}}),VISUALS.ROOM_GLOBAL&&(VISUALS.CPU&&this.collectSparklineStats(),this.drawGlobal())}),this.drawBar=((e,t,r,o,i,a,s,n={})=>{s||(s=t);const l=o+.75;e.rect(r,o,i,a,this.barStyle),e.rect(r,o,i*t,a,n),e.text(s,r+i/2,l)}),this.drawPie=((e,t,r,a,s,n,l)=>{l||(l=t);let m=1;0!==r&&(m=t/r),n={x:n.x,y:1*n.y*4.5},e.circle(n,{radius:1.1,fill:o,stroke:"rgba(255, 255, 255, 0.8)"});const c=[n],u=2*Math.PI,d=u*(m+.1),h=-Math.PI/2,g=u/32;for(let e=0;e<=d;e+=g)c.push({x:n.x+Math.cos(e+h),y:n.y-Math.cos(e)});c.push(n),e.poly(c,{fill:s,opacity:1,stroke:s,strokeWidth:.05}),e.text(Number.isFinite(l)?Util.formatNumber(l):l,n.x,n.y+.33,{color:i,font:"1 monospace",align:"center",stroke:"rgba(0, 0, 0, 0.8)",strokeWidth:.08});let p=.7;m>.35&&m<.65&&(p+=.3),e.text(a,n.x,n.y+1+p,{color:i,font:"0.6 monospace",align:"center"});const f=c[c.length-2];e.text(Math.floor(100*m)+"%",f.x+.7*(f.x-n.x),f.y+.4*(f.y-n.y)+.1,{color:i,font:"0.4 monospace",align:"center"})}),this.drawLine=((e,t,r)=>{if(e instanceof RoomObject&&(e=e.pos),t instanceof RoomObject&&(t=t.pos),!(e instanceof RoomPosition||t instanceof RoomPosition))throw new Error("Visuals: Point not a RoomPosition");if(e.roomName!==t.roomName)return;const o=new RoomVisual(e.roomName);r=r instanceof Creep?this.creepPathStyle(r):r||{},o.line(e,t,r)}),this.drawArrow=((e,t,r)=>{if(e instanceof RoomObject&&(e=e.pos),t instanceof RoomObject&&(t=t.pos),!(e instanceof RoomPosition||t instanceof RoomPosition))throw new Error("Visuals: Point not a RoomPosition");if(e.roomName!==t.roomName)return;const o=new RoomVisual(e.roomName);this.drawLine(e,t,r);const i=e.x-t.x,a=e.y-t.y,s=Math.atan2(a,i),n=.5*Math.log1p(Util.getDistance(e,t));r=r instanceof Creep?this.creepPathStyle(r):r||{},o.line(t.x,t.y,t.x+n*Math.cos(s+.610865),t.y+n*Math.sin(s+.610865),r),o.line(t.x,t.y,t.x+n*Math.cos(s-.610865),t.y+n*Math.sin(s-.610865),r)}),this.drawGlobal=(()=>{const e=this.vis;if(VISUALS.INFO_PIE_CHART){let t=2,r=.5;this.drawPie(e,Math.round(Game.gcl.progress),Game.gcl.progressTotal,`GCL ${Game.gcl.level}`,this._getColourByPercentage(Game.gcl.progress/Game.gcl.progressTotal,!0),{x:t,y:r++});const o=Game.cpu.getUsed()/Game.cpu.limit,a=Math.min(1,o);this.drawPie(e,Math.round(Game.cpu.getUsed()),Game.cpu.limit,"CPU",this._getColourByPercentage(a),{x:t,y:r++}),this.drawPie(e,Game.cpu.bucket,1e4,"Bucket",this._getColourByPercentage(Math.min(1,Game.cpu.bucket/1e4),!0),{x:t,y:r++});const s=_.size(Game.spawns);let n=_(Game.spawns).filter("spawning").size();const l=(n+=_(Game.rooms).map(e=>e.spawnQueueHigh.concat(e.spawnQueueMedium,e.spawnQueueLow)).flatten().size())/s;this.drawPie(e,l,1,"SCU",this._getColourByPercentage(l),{x:t,y:r++}),r+=15,e.text("Tick",t,r++,{color:i,align:"center"}),e.text(Game.time,t,r++,{color:i,align:"center"})}else{const t=9.8,r=this.barStyle;let o=1,i=2;const a=i-.75;if(VISUALS.ROOM){o=2+t;const s=Game.gcl.progress/Game.gcl.progressTotal;this.drawBar(e,s,o,a,t,1,`GCL: ${Game.gcl.level} (${(100*s).toFixed(2)}%)`,{fill:this._getColourByPercentage(s,!0),opacity:r.opacity}),o+=t+1;const n=Game.cpu.getUsed()/Game.cpu.limit,l=Math.min(1,n);this.drawBar(e,l,o,a,t,1,`CPU: ${(100*n).toFixed(2)}%`,{fill:this._getColourByPercentage(l),opacity:r.opacity}),o+=t+1;const m=Math.min(1,Game.cpu.bucket/1e4);this.drawBar(e,m,o,a,t,1,`Bucket: ${Game.cpu.bucket}`,{fill:this._getColourByPercentage(m,!0),opacity:r.opacity}),o+=t+1,e.text(`Tick: ${Game.time}`,o,i,{align:"left"}),o=2+t,i+=1.5;const c=_.size(Game.spawns);let u=_(Game.spawns).filter("spawning").size();const d=(u+=_(Game.rooms).map(e=>e.spawnQueueHigh.concat(e.spawnQueueMedium,e.spawnQueueLow)).flatten().size())/c;this.drawBar(e,Math.min(1,d),o,i-.75,t,1,`SCU: ${(100*d).toFixed(2)}%`,{fill:this._getColourByPercentage(Math.min(1,d)),opacity:r.opacity})}}VISUALS.CPU&&this.drawSparkline(void 0,1.5,46.5,20,2,_.map(Memory.visualStats.cpu,(e,t)=>Memory.visualStats.cpu[t]),this.sparklineStyle)}),this.collectSparklineStats=(()=>{Util.set(Memory,"visualStats.cpu",[]),Memory.visualStats.cpu.push({limit:Game.cpu.limit,bucket:Game.cpu.bucket,cpu:Game.cpu.getUsed()}),Memory.visualStats.cpu.length>=100&&Memory.visualStats.cpu.shift()}),this.drawSparkline=((e,t,r,o,i,a,s)=>{const n=e?new RoomVisual(e):this.vis;_.forEach(s,e=>{n.poly(_.map(a,(s,n)=>[t+o*(n/(a.length-1)),r+i*(1-(s[e.key]-e.min)/(e.max-e.min))]),e)})}),this.drawRoomInfo=(e=>{const t=new RoomVisual(e.name);let r,o=0;if(t.text(`Room: ${t.roomName}`,24.5,++o),VISUALS.INFO_PIE_CHART){let r,o,i=2,a=.5;VISUALS.ROOM_GLOBAL&&(i+=4);let s,n="RCL";if(8===e.controller.level?(r=1,o=1,s=" "):e.controller.reservation?(r=e.controller.reservation.ticksToEnd,o=5e3):e.controller.owner?(r=Math.min(e.controller.progress,e.controller.progressTotal),o=e.controller.progressTotal,n+=` ${e.controller.level}`):(r=0,o=1,s="N/A"),this.drawPie(t,r,o,n,this._getColourByPercentage(r/o,!0),{x:i,y:a++},s),!e.controller.reservation&&e.controller.owner){const r=e.energyAvailable/e.energyCapacityAvailable||0;this.drawPie(t,e.energyAvailable,e.energyCapacityAvailable,"Energy",this._getColourByPercentage(r,!0),{x:i,y:a++})}}else{const i=9.8,a=this.barStyle;let s,n;if(r=1,o++,8===e.controller.level?(n=1,s="RCL: 8"):e.controller.reservation?(n=0,s=`Reserved: ${e.controller.reservation.ticksToEnd}`):e.controller.owner?(n=Math.min(1,e.controller.progress/e.controller.progressTotal),s=`RCL: ${e.controller.level} (${(100*n).toFixed(2)}%)`):(n=0,s="Unowned"),this.drawBar(t,n,r,o-.75,i,1,s,{fill:this._getColourByPercentage(n,!0),opacity:a.opacity}),VISUALS.ROOM_GLOBAL?(o+=1.5,r=1):r+=i+1,!e.controller.reservation&&e.controller.owner){const s=e.energyAvailable/e.energyCapacityAvailable||0;this.drawBar(t,s,r,o-.75,i,1,`Energy: ${e.energyAvailable}/${e.energyCapacityAvailable} (${(100*s).toFixed(2)}%)`,{fill:this._getColourByPercentage(s,!0),opacity:a.opacity})}}}),this.drawSpawnInfo=(e=>{e.spawning&&new RoomVisual(e.room.name).text(`${e.spawning.name} (${((e.spawning.needTime-e.spawning.remainingTime)/e.spawning.needTime*100).toFixed(1)}%)`,e.pos.x+1,e.pos.y-.5,this.toolTipStyle)}),this.drawMineralInfo=(e=>{const t=new RoomVisual(e.room.name),r=e.pos.x+1,o=e.pos.y-.5;e.mineralAmount?t.text(`Amount: ${Util.formatNumber(e.mineralAmount)}`,r,o,this.toolTipStyle):t.text(`Regen: ${Util.formatNumber(e.ticksToRegeneration)}`,r,o,this.toolTipStyle)}),this.drawSourceInfo=(e=>{const t=new RoomVisual(e.room.name),r=e.pos.x+1,o=e.pos.y-.5;e.energy?t.text(`Amount: ${e.energy}`,r,o,this.toolTipStyle):t.text(`Regen: ${e.ticksToRegeneration}`,r,o,this.toolTipStyle)}),this.drawControllerInfo=(e=>{const t=new RoomVisual(e.room.name),r=e.pos.x+1;let o=e.pos.y-.5;const i=this.toolTipStyle;let s=`L: ${e.level}`,n=`P: ${Util.formatNumber(e.progress)}/${Util.formatNumber(e.progressTotal)} (${(e.progress/e.progressTotal*100).toFixed(2)}%)`,l=`D: ${Util.formatNumber(e.ticksToDowngrade)}`;if(8===e.level)n=void 0;else if(e.reservation)s="L: Reserved",n=`P: ${e.reservation.username}`,l=`D: ${e.reservation.ticksToEnd}`;else if(!e.owner)return;if(t.text(s,r,o,i),n&&t.text(n,r,o+=.4,i),e.ticksToDowngrade<CONTROLLER_DOWNGRADE[e.level]||e.reservation){let e=Object.assign({},i,{color:a});t.text(l,r,o+=.4,e)}}),this.highlightWeakest=((e,t)=>{const r=new RoomVisual(e.name),o=_(e.find(FIND_STRUCTURES)).filter({structureType:t}).min("hits");if(o&&o.pos){r.circle(o.pos.x,o.pos.y,this.weakestStyle);let e=o.pos.y-.5;const t=o.pos.lookFor(LOOK_STRUCTURES);if(_.find(t,e=>e instanceof StructureTower)&&VISUALS.TOWER)e+=.4;else if(_.find(t,e=>e instanceof StructureSpawn&&e.spawning)&&VISUALS.SPAWN)e+=.4;else{const r=_.find(t,e=>e instanceof StructureLab);r&&VISUALS.LABS&&(r.energy&&(e+=.4),r.mineralAmount&&(e+=.4),r.cooldown&&(e+=.4))}r.text(`H: ${Util.formatNumber(o.hits)} (${(o.hits/o.hitsMax*100).toFixed(2)}%)`,o.pos.x+1,e,this.toolTipStyle)}}),this.drawRoomOrders=(e=>{const t=new RoomVisual(e.name);let r=VISUALS.INFO_PIE_CHART?.5:4.5;if(e.memory.resources&&e.memory.resources.orders&&_.size(e.memory.resources.orders)){VISUALS.STORAGE&&e.storage&&(r+=2+.6*_.size(e.storage.store)),VISUALS.TERMINAL&&e.terminal&&(r+=2+.6*_.size(e.terminal.store)),t.text("Room Orders",43,++r,{align:"left"});for(let o of e.memory.resources.orders)t.text(`${o.type}: ${Util.formatNumber(o.amount)}`,43,r+=.6,Object.assign({color:this._getResourceColour(o.type)},this.toolTipStyle))}}),this.drawRoomOffers=(e=>{const t=new RoomVisual(e.name);let r=VISUALS.INFO_PIE_CHART?.5:4.5;if(e.memory.resources&&e.memory.resources.offers&&_.size(e.memory.resources.offers)){VISUALS.STORAGE&&e.storage&&(r+=2+.6*_.size(e.storage.store)),VISUALS.TERMINAL&&e.terminal&&(r+=2+.6*_.size(e.terminal.store)),VISUALS.ROOM_ORDERS&&e.memory.resources.orders&&(r+=2+.6*_.size(e.memory.resources.orders)),t.text("Room Offerings",43,++r,{align:"left"});for(let o of e.memory.resources.offers)t.text(`${o.type}: ${Util.formatNumber(o.amount)} (to ${o.room})`,43,r+=.6,Object.assign({color:this._getResourceColour(o.type)},this.toolTipStyle))}}),this.drawStorageInfo=(e=>{if(!e||!_.size(e.store))return;const t=new RoomVisual(e.room.name);let r=VISUALS.INFO_PIE_CHART?.5:4.5;t.text("Storage Contents",43,++r,{align:"left"}),this._storageObject(t,e.store,43,r)}),this.drawTerminalInfo=(e=>{if(!e||!_.size(e.store))return;const t=new RoomVisual(e.room.name);let r=VISUALS.INFO_PIE_CHART?.5:4.5;VISUALS.STORAGE&&e.room.storage&&(r+=2+.6*_.size(e.room.storage.store)),t.text("Terminal Contents",43,++r,{align:"left"}),this._storageObject(t,e.store,43,r)}),this.drawTransactions=(e=>{if(!e.terminal)return;const t=new RoomVisual(e.name),r=e.terminal.pos.x;let o=e.terminal.pos.y-1;const i=_(Game.market.incomingTransactions).concat(Game.market.outgoingTransactions).filter(t=>t.from===e.name||t.to===e.name).sortByOrder("time","desc").slice(0,2).value();0!==i.length&&(2===i.length&&(o-=.4),i.forEach(i=>{const n=i.sender.username===e.controller.owner.username,l=!!i.recipient&&i.sender.username===i.recipient.username,m=e.name===i.to,c=n||m?s:a,u=n?"+":"-";let d="";d=l||!i.order?`${m?i.from:i.to} : ${i.amount} ${i.resourceType}`:`${u}${i.amount*i.order.price}`,t.text(d,r,o,{font:this.toolTipStyle.font,color:c}),o+=.4}))}),this.drawLabInfo=(e=>{const t=new RoomVisual(e.room.name);if(!e.energy&&!e.mineralAmount&&!e.cooldown)return;const r=e.pos.x+.8;let o=e.pos.y-.5;e.energy&&t.text(`E: ${Util.formatNumber(e.energy)}`,r,o,Object.assign({color:this._getResourceColour(RESOURCE_ENERGY)},this.toolTipStyle)),e.mineralAmount&&t.text(`M: ${e.mineralType} (${Util.formatNumber(e.mineralAmount)})`,r,o+=.4,Object.assign({color:this._getResourceColour(e.mineralType)},this.toolTipStyle)),e.cooldown&&t.text(`C: ${e.cooldown}`,r,o+=.4,Object.assign({color:a},this.toolTipStyle))}),this.setHeatMapData=(e=>{Util.set(e.memory,"heatmap",()=>{const t={};for(let r=0;r<50;r++)for(let o=0;o<50;o++){const i=e.getPositionAt(r,o);"wall"!==Game.map.getTerrainAt(i)&&(t[`${String.fromCharCode(32+r)}${String.fromCharCode(32+o)}_x${r}-y${o}`]=0)}return t}),e.creeps.filter(e=>!e.spawning).forEach(t=>{const r=t.pos.x,o=t.pos.y,i=`${String.fromCharCode(32+r)}${String.fromCharCode(32+o)}_x${r}-y${o}`;e.memory.heatmap[i]++})}),this.drawHeatMapData=(e=>{const t=new RoomVisual(e.name),r=Object.keys(e.memory.heatmap).map(t=>({n:e.memory.heatmap[t],x:t.charCodeAt(0)-32,y:t.charCodeAt(1)-32})),o=_.filter(r,e=>e.n>0),i=_.sum(o,e=>e.n)/o.length*2;o.forEach(e=>{const r=e.n/i,o=this._getColourByPercentage(Math.min(1,r));t.rect(e.x-.5,e.y-.5,1,1,{fill:o})})}),this.drawTowerInfo=(e=>{new RoomVisual(e.room.name).text(`E: ${e.energy}/${e.energyCapacity}`,e.pos.x+1,e.pos.y-.5,this.toolTipStyle)}),this.creepPathStyle=(e=>(Util.set(e.data,"pathColour",function(){let e="#";for(;e.length<7;)e+=Math.random().toString(16).substr(-7).substr(-1);return e}),{width:.15,color:e.data.pathColour,lineStyle:"dashed"})),this.drawCreepPath=(e=>{const t=new RoomVisual(e.room.name);if(e.action&&"idle"===e.action.name)return;if(_(e.pos).pick(["x","y"]).eq(e.data.determinatedSpot))return;if(!e.memory||!e.memory._travel||!e.memory._travel.path)return;const r=e.memory._travel.path.substr(1),o=this.creepPathStyle(e);let i=e.pos.x,a=e.pos.y;const s={[TOP]:{x:0,y:-1},[TOP_RIGHT]:{x:1,y:-1},[RIGHT]:{x:1,y:0},[BOTTOM_RIGHT]:{x:1,y:1},[BOTTOM]:{x:0,y:1},[BOTTOM_LEFT]:{x:-1,y:1},[LEFT]:{x:-1,y:0},[TOP_LEFT]:{x:-1,y:-1}};if(0===e.fatigue){const t=+e.memory._travel.path[0];i+=s[t].x,a+=s[t].y}for(let e of r)e=+e,t.line(i,a,i+=s[e].x,a+=s[e].y,o)}),this._getColourByPercentage=((e,t)=>`hsl(${(120*(t?e:1-e)).toString(10)}, 100%, 50%)`),this._getResourceColour=(e=>{const t={[RESOURCE_ENERGY]:"#FFE56D",[RESOURCE_POWER]:a,[RESOURCE_CATALYST]:"#FF7A7A",[RESOURCE_GHODIUM]:i,[RESOURCE_HYDROGEN]:"#CCCCCC",[RESOURCE_KEANIUM]:"#9370FF",[RESOURCE_LEMERGIUM]:"#89F4A5",[RESOURCE_OXYGEN]:"#CCCCCC",[RESOURCE_UTRIUM]:"#88D6F7",[RESOURCE_ZYNTHIUM]:"#F2D28B"};let r=t[e];return r||t[[RESOURCE_UTRIUM,RESOURCE_LEMERGIUM,RESOURCE_KEANIUM,RESOURCE_ZYNTHIUM,RESOURCE_GHODIUM,RESOURCE_HYDROGEN,RESOURCE_OXYGEN].find(t=>e.includes(t))]}),this._storageObject=((e,t,r,o)=>{Object.keys(t).forEach(i=>e.text(`${i}: ${Util.formatNumber(t[i])}`,r,o+=.6,Object.assign({color:this._getResourceColour(i)},{align:"left",font:.5})))}),this.barStyle={fill:"#2B2B2B",opacity:.8,stroke:o},this.sparklineStyle=[{key:"limit",min:.5*Game.cpu.limit,max:1.5*Game.cpu.limit,stroke:"#808080",opacity:.25},{key:"cpu",min:.5*Game.cpu.limit,max:1.5*Game.cpu.limit,stroke:n,opacity:.5},{key:"bucket",min:0,max:1e4,stroke:l,opacity:.5}],this.toolTipStyle={align:"left",font:.4},this.weakestStyle={radius:.4,fill:a,opacity:.3,strokeWidth:0},this.vis=new RoomVisual}}}]);